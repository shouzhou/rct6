; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_eeprom_24xx.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_eeprom_24xx.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\User -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User\app\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_eeprom_24xx.crf ..\..\User\bsp\src\bsp_eeprom_24xx.c]
                          THUMB

                          AREA ||i.ee_CheckOk||, CODE, READONLY, ALIGN=1

                  ee_CheckOk PROC
;;;52     */
;;;53     uint8_t ee_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;54     {
;;;55     	if (i2c_CheckDevice(EE_DEV_ADDR) == 0)
000002  20a0              MOVS     r0,#0xa0
000004  f7fffffe          BL       i2c_CheckDevice
000008  b908              CBNZ     r0,|L1.14|
;;;56     	{
;;;57     		return 1;
00000a  2001              MOVS     r0,#1
                  |L1.12|
;;;58     	}
;;;59     	else
;;;60     	{
;;;61     		/* 失败后，切记发送I2C总线停止信号 */
;;;62     		i2c_Stop();
;;;63     		return 0;
;;;64     	}
;;;65     }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  f7fffffe          BL       i2c_Stop
000012  2000              MOVS     r0,#0                 ;63
000014  e7fa              B        |L1.12|
;;;66     
                          ENDP


                          AREA ||i.ee_ReadBytes||, CODE, READONLY, ALIGN=1

                  ee_ReadBytes PROC
;;;165    */
;;;166    uint8_t ee_ReadBytes(uint8_t *_pReadBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;167    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;168    	uint16_t i;
;;;169    
;;;170    	/* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
;;;171    
;;;172    	/* 第1步：发起I2C总线启动信号 */
;;;173    	i2c_Start();
00000a  f7fffffe          BL       i2c_Start
;;;174    
;;;175    	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;176    	#if EE_ADDR_A8 == 1
;;;177    		i2c_SendByte(EE_DEV_ADDR | I2C_WR | ((_usAddress >> 7) & 0x0E));	/* 此处是写指令 */
;;;178    	#else
;;;179    		i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
00000e  20a0              MOVS     r0,#0xa0
000010  f7fffffe          BL       i2c_SendByte
;;;180    	#endif
;;;181    
;;;182    	/* 第3步：发送ACK */
;;;183    	if (i2c_WaitAck() != 0)
000014  f7fffffe          BL       i2c_WaitAck
000018  b100              CBZ      r0,|L2.28|
;;;184    	{
;;;185    		goto cmd_fail;	/* EEPROM器件无应答 */
00001a  e025              B        |L2.104|
                  |L2.28|
;;;186    	}
;;;187    
;;;188    	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;189    	if (EE_ADDR_BYTES == 1)
;;;190    	{
;;;191    		i2c_SendByte((uint8_t)_usAddress);
00001c  b2f8              UXTB     r0,r7
00001e  f7fffffe          BL       i2c_SendByte
;;;192    		if (i2c_WaitAck() != 0)
000022  f7fffffe          BL       i2c_WaitAck
000026  b100              CBZ      r0,|L2.42|
;;;193    		{
;;;194    			goto cmd_fail;	/* EEPROM器件无应答 */
000028  e01e              B        |L2.104|
                  |L2.42|
;;;195    		}
;;;196    	}
;;;197    	else
;;;198    	{
;;;199    		i2c_SendByte(_usAddress >> 8);
;;;200    		if (i2c_WaitAck() != 0)
;;;201    		{
;;;202    			goto cmd_fail;	/* EEPROM器件无应答 */
;;;203    		}
;;;204    
;;;205    		i2c_SendByte(_usAddress);
;;;206    		if (i2c_WaitAck() != 0)
;;;207    		{
;;;208    			goto cmd_fail;	/* EEPROM器件无应答 */
;;;209    		}
;;;210    	}
;;;211    
;;;212    	/* 第6步：重新启动I2C总线。下面开始读取数据 */
;;;213    	i2c_Start();
00002a  f7fffffe          BL       i2c_Start
;;;214    
;;;215    	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;216    	#if EE_ADDR_A8 == 1
;;;217    		i2c_SendByte(EE_DEV_ADDR | I2C_RD | ((_usAddress >> 7) & 0x0E));	/* 此处是写指令 */
;;;218    	#else		
;;;219    		i2c_SendByte(EE_DEV_ADDR | I2C_RD);	/* 此处是写指令 */
00002e  20a1              MOVS     r0,#0xa1
000030  f7fffffe          BL       i2c_SendByte
;;;220    	#endif	
;;;221    
;;;222    	/* 第8步：发送ACK */
;;;223    	if (i2c_WaitAck() != 0)
000034  f7fffffe          BL       i2c_WaitAck
000038  b100              CBZ      r0,|L2.60|
;;;224    	{
;;;225    		goto cmd_fail;	/* EEPROM器件无应答 */
00003a  e015              B        |L2.104|
                  |L2.60|
;;;226    	}
;;;227    
;;;228    	/* 第9步：循环读取数据 */
;;;229    	for (i = 0; i < _usSize; i++)
00003c  2400              MOVS     r4,#0
00003e  e00c              B        |L2.90|
                  |L2.64|
;;;230    	{
;;;231    		_pReadBuf[i] = i2c_ReadByte();	/* 读1个字节 */
000040  f7fffffe          BL       i2c_ReadByte
000044  5530              STRB     r0,[r6,r4]
;;;232    
;;;233    		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;234    		if (i != _usSize - 1)
000046  1e68              SUBS     r0,r5,#1
000048  42a0              CMP      r0,r4
00004a  d002              BEQ      |L2.82|
;;;235    		{
;;;236    			i2c_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
00004c  f7fffffe          BL       i2c_Ack
000050  e001              B        |L2.86|
                  |L2.82|
;;;237    		}
;;;238    		else
;;;239    		{
;;;240    			i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
000052  f7fffffe          BL       i2c_NAck
                  |L2.86|
000056  1c60              ADDS     r0,r4,#1              ;229
000058  b284              UXTH     r4,r0                 ;229
                  |L2.90|
00005a  42ac              CMP      r4,r5                 ;229
00005c  dbf0              BLT      |L2.64|
;;;241    		}
;;;242    	}
;;;243    	/* 发送I2C总线停止信号 */
;;;244    	i2c_Stop();
00005e  f7fffffe          BL       i2c_Stop
;;;245    	return 1;	/* 执行成功 */
000062  2001              MOVS     r0,#1
                  |L2.100|
;;;246    
;;;247    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;248    	/* 发送I2C总线停止信号 */
;;;249    	i2c_Stop();
;;;250    	return 0;
;;;251    }
000064  e8bd81f0          POP      {r4-r8,pc}
                  |L2.104|
000068  f7fffffe          BL       i2c_Stop
00006c  2000              MOVS     r0,#0                 ;250
00006e  e7f9              B        |L2.100|
;;;252    
                          ENDP


                          AREA ||i.ee_ReadSaveData||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  ee_ReadSaveData PROC
;;;72     
;;;73     void ee_ReadSaveData(void)
000000  b510              PUSH     {r4,lr}
;;;74     {
;;;75         ee_ReadBytes(eeResult,0,20);
000002  2214              MOVS     r2,#0x14
000004  2100              MOVS     r1,#0
000006  4842              LDR      r0,|L3.272|
000008  f7fffffe          BL       ee_ReadBytes
;;;76         if(eeResult[0] &0x01)  //长度已经设置
00000c  4840              LDR      r0,|L3.272|
00000e  7800              LDRB     r0,[r0,#0]  ; eeResult
000010  f0000001          AND      r0,r0,#1
000014  b190              CBZ      r0,|L3.60|
;;;77         {
;;;78             g_lenth = ((uint16_t)eeResult[1]<<8)+eeResult[2];
000016  483e              LDR      r0,|L3.272|
000018  7880              LDRB     r0,[r0,#2]  ; eeResult
00001a  493d              LDR      r1,|L3.272|
00001c  7849              LDRB     r1,[r1,#1]  ; eeResult
00001e  eb002001          ADD      r0,r0,r1,LSL #8
000022  493c              LDR      r1,|L3.276|
000024  8008              STRH     r0,[r1,#0]
;;;79             #ifdef USEDEBUG
;;;80     
;;;81               printf("Read lenth = %d\r\n",g_lenth);
000026  4608              MOV      r0,r1
000028  8801              LDRH     r1,[r0,#0]  ; g_lenth
00002a  a03b              ADR      r0,|L3.280|
00002c  f7fffffe          BL       __2printf
;;;82             
;;;83             #endif 
;;;84          //   bsp_Diwen_Updatedata(0x0001,g_lenth);
;;;85             bsp_DelayMS(100);
000030  2064              MOVS     r0,#0x64
000032  f7fffffe          BL       bsp_DelayMS
;;;86            // bsp_Diwen_Updatedata(0x0001,g_lenth);
;;;87             bsp_DelayMS(100);
000036  2064              MOVS     r0,#0x64
000038  f7fffffe          BL       bsp_DelayMS
                  |L3.60|
;;;88             
;;;89         }
;;;90         if(eeResult[0] &0x02)  //宽度已经设置
00003c  4834              LDR      r0,|L3.272|
00003e  7800              LDRB     r0,[r0,#0]  ; eeResult
000040  f0000002          AND      r0,r0,#2
000044  b190              CBZ      r0,|L3.108|
;;;91         {
;;;92               g_width = ((uint16_t)eeResult[3]<<8)+eeResult[4];
000046  4832              LDR      r0,|L3.272|
000048  7900              LDRB     r0,[r0,#4]  ; eeResult
00004a  4931              LDR      r1,|L3.272|
00004c  78c9              LDRB     r1,[r1,#3]  ; eeResult
00004e  eb002001          ADD      r0,r0,r1,LSL #8
000052  4936              LDR      r1,|L3.300|
000054  8008              STRH     r0,[r1,#0]
;;;93                 #ifdef USEDEBUG
;;;94     
;;;95                 printf("Read width = %d\r\n",g_width);
000056  4608              MOV      r0,r1
000058  8801              LDRH     r1,[r0,#0]  ; g_width
00005a  a035              ADR      r0,|L3.304|
00005c  f7fffffe          BL       __2printf
;;;96                 
;;;97                 #endif 
;;;98              //   bsp_Diwen_Updatedata(0x0002,g_width);
;;;99                 bsp_DelayMS(100);
000060  2064              MOVS     r0,#0x64
000062  f7fffffe          BL       bsp_DelayMS
;;;100              //  bsp_Diwen_Updatedata(0x0002,g_width);
;;;101                bsp_DelayMS(100);
000066  2064              MOVS     r0,#0x64
000068  f7fffffe          BL       bsp_DelayMS
                  |L3.108|
;;;102        }
;;;103        if(eeResult[0] &0x04)  //高度已经设置
00006c  4828              LDR      r0,|L3.272|
00006e  7800              LDRB     r0,[r0,#0]  ; eeResult
000070  f0000004          AND      r0,r0,#4
000074  b190              CBZ      r0,|L3.156|
;;;104        {
;;;105            g_height = ((uint16_t)eeResult[5]<<8)+eeResult[6];
000076  4826              LDR      r0,|L3.272|
000078  7980              LDRB     r0,[r0,#6]  ; eeResult
00007a  4925              LDR      r1,|L3.272|
00007c  7949              LDRB     r1,[r1,#5]  ; eeResult
00007e  eb002001          ADD      r0,r0,r1,LSL #8
000082  4930              LDR      r1,|L3.324|
000084  8008              STRH     r0,[r1,#0]
;;;106            #ifdef USEDEBUG
;;;107    
;;;108            printf("Read height = %d\r\n",g_height);
000086  4608              MOV      r0,r1
000088  8801              LDRH     r1,[r0,#0]  ; g_height
00008a  a02f              ADR      r0,|L3.328|
00008c  f7fffffe          BL       __2printf
;;;109            
;;;110            #endif 
;;;111          //  bsp_Diwen_Updatedata(0x0003,g_height);
;;;112            bsp_DelayMS(100);
000090  2064              MOVS     r0,#0x64
000092  f7fffffe          BL       bsp_DelayMS
;;;113           // bsp_Diwen_Updatedata(0x0003,g_height);
;;;114            bsp_DelayMS(100);
000096  2064              MOVS     r0,#0x64
000098  f7fffffe          BL       bsp_DelayMS
                  |L3.156|
;;;115    
;;;116        }
;;;117        if(eeResult[0] &0x08)  //植株类型已经设置
00009c  481c              LDR      r0,|L3.272|
00009e  7800              LDRB     r0,[r0,#0]  ; eeResult
0000a0  f0000008          AND      r0,r0,#8
0000a4  b170              CBZ      r0,|L3.196|
;;;118        {
;;;119            g_plant = eeResult[14];
0000a6  481a              LDR      r0,|L3.272|
0000a8  7b80              LDRB     r0,[r0,#0xe]  ; eeResult
0000aa  492c              LDR      r1,|L3.348|
0000ac  7008              STRB     r0,[r1,#0]
;;;120            #ifdef USEDEBUG
;;;121    
;;;122            printf("Read g_plant = %d\r\n",g_plant);
0000ae  4608              MOV      r0,r1
0000b0  7801              LDRB     r1,[r0,#0]  ; g_plant
0000b2  a02b              ADR      r0,|L3.352|
0000b4  f7fffffe          BL       __2printf
;;;123            
;;;124            #endif 
;;;125         //   bsp_ScreenUPdateType(g_plant);
;;;126            bsp_DelayMS(100);
0000b8  2064              MOVS     r0,#0x64
0000ba  f7fffffe          BL       bsp_DelayMS
;;;127          //  bsp_ScreenUPdateType(g_plant);
;;;128            bsp_DelayMS(100);
0000be  2064              MOVS     r0,#0x64
0000c0  f7fffffe          BL       bsp_DelayMS
                  |L3.196|
;;;129    
;;;130        }
;;;131        if(eeResult[0] &0x10)  //芳香类型已经设置
0000c4  4812              LDR      r0,|L3.272|
0000c6  7800              LDRB     r0,[r0,#0]  ; eeResult
0000c8  f0000010          AND      r0,r0,#0x10
0000cc  b170              CBZ      r0,|L3.236|
;;;132        {
;;;133            g_chemical = eeResult[15];
0000ce  4810              LDR      r0,|L3.272|
0000d0  7bc0              LDRB     r0,[r0,#0xf]  ; eeResult
0000d2  4928              LDR      r1,|L3.372|
0000d4  7008              STRB     r0,[r1,#0]
;;;134            #ifdef USEDEBUG
;;;135    
;;;136            printf("Read g_chemical = %d\r\n",g_chemical);
0000d6  4608              MOV      r0,r1
0000d8  7801              LDRB     r1,[r0,#0]  ; g_chemical
0000da  a027              ADR      r0,|L3.376|
0000dc  f7fffffe          BL       __2printf
;;;137            
;;;138            #endif 
;;;139          //  bsp_ScreenUPdateChemical(g_chemical);
;;;140            bsp_DelayMS(100);
0000e0  2064              MOVS     r0,#0x64
0000e2  f7fffffe          BL       bsp_DelayMS
;;;141          //  bsp_ScreenUPdateChemical(g_chemical);
;;;142            bsp_DelayMS(100);
0000e6  2064              MOVS     r0,#0x64
0000e8  f7fffffe          BL       bsp_DelayMS
                  |L3.236|
;;;143    
;;;144        }
;;;145        g_FailTime =  eeResult[7];
0000ec  4808              LDR      r0,|L3.272|
0000ee  79c0              LDRB     r0,[r0,#7]  ; eeResult
0000f0  4927              LDR      r1,|L3.400|
0000f2  7008              STRB     r0,[r1,#0]
;;;146        #ifdef USEDEBUG
;;;147        printf("fail time = %d\r\n",g_FailTime);
0000f4  4608              MOV      r0,r1
0000f6  7801              LDRB     r1,[r0,#0]  ; g_FailTime
0000f8  a026              ADR      r0,|L3.404|
0000fa  f7fffffe          BL       __2printf
;;;148        #endif 
;;;149        if(g_FailTime >50) 
0000fe  4824              LDR      r0,|L3.400|
000100  7800              LDRB     r0,[r0,#0]  ; g_FailTime
000102  2832              CMP      r0,#0x32
000104  dd02              BLE      |L3.268|
;;;150        {
;;;151            g_WithoutOnenet = 1;
000106  2001              MOVS     r0,#1
000108  4927              LDR      r1,|L3.424|
00010a  7008              STRB     r0,[r1,#0]
                  |L3.268|
;;;152          
;;;153        }
;;;154    }
00010c  bd10              POP      {r4,pc}
;;;155    
                          ENDP

00010e  0000              DCW      0x0000
                  |L3.272|
                          DCD      eeResult
                  |L3.276|
                          DCD      g_lenth
                  |L3.280|
000118  52656164          DCB      "Read lenth = %d\r\n",0
00011c  206c656e
000120  7468203d
000124  2025640d
000128  0a00    
00012a  00                DCB      0
00012b  00                DCB      0
                  |L3.300|
                          DCD      g_width
                  |L3.304|
000130  52656164          DCB      "Read width = %d\r\n",0
000134  20776964
000138  7468203d
00013c  2025640d
000140  0a00    
000142  00                DCB      0
000143  00                DCB      0
                  |L3.324|
                          DCD      g_height
                  |L3.328|
000148  52656164          DCB      "Read height = %d\r\n",0
00014c  20686569
000150  67687420
000154  3d202564
000158  0d0a00  
00015b  00                DCB      0
                  |L3.348|
                          DCD      g_plant
                  |L3.352|
000160  52656164          DCB      "Read g_plant = %d\r\n",0
000164  20675f70
000168  6c616e74
00016c  203d2025
000170  640d0a00
                  |L3.372|
                          DCD      g_chemical
                  |L3.376|
000178  52656164          DCB      "Read g_chemical = %d\r\n",0
00017c  20675f63
000180  68656d69
000184  63616c20
000188  3d202564
00018c  0d0a00  
00018f  00                DCB      0
                  |L3.400|
                          DCD      g_FailTime
                  |L3.404|
000194  6661696c          DCB      "fail time = %d\r\n",0
000198  2074696d
00019c  65203d20
0001a0  25640d0a
0001a4  00      
0001a5  00                DCB      0
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L3.424|
                          DCD      g_WithoutOnenet

                          AREA ||i.ee_WriteBytes||, CODE, READONLY, ALIGN=1

                  ee_WriteBytes PROC
;;;263    */
;;;264    uint8_t ee_WriteBytes(uint8_t _rease, uint8_t *_pWriteBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;265    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
;;;266    	uint16_t i,m;
;;;267    	uint16_t usAddr;
;;;268    
;;;269    	/*
;;;270    		写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
;;;271    		对于24xx02，page size = 8
;;;272    		简单的处理方法为：按字节写操作模式，每写1个字节，都发送地址
;;;273    		为了提高连续写的效率: 本函数采用page wirte操作。
;;;274    	*/
;;;275    
;;;276    	/* 关闭写保护 */
;;;277    	//WP = 0;
;;;278    
;;;279    	usAddr = _usAddress;
00000c  464e              MOV      r6,r9
;;;280    	for (i = 0; i < _usSize; i++)
00000e  2500              MOVS     r5,#0
000010  e032              B        |L4.120|
                  |L4.18|
;;;281    	{
;;;282    		/* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
;;;283    		if ((i == 0) || (usAddr & (EE_PAGE_SIZE - 1)) == 0)
000012  b115              CBZ      r5,|L4.26|
000014  f0060007          AND      r0,r6,#7
000018  b9e8              CBNZ     r0,|L4.86|
                  |L4.26|
;;;284    		{
;;;285    			/*　第０步：发停止信号，启动内部写操作　*/
;;;286    			i2c_Stop();
00001a  f7fffffe          BL       i2c_Stop
;;;287    
;;;288    			/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms
;;;289    				CLK频率为200KHz时，查询次数为30次左右
;;;290    			*/
;;;291    			for (m = 0; m < 1000; m++)
00001e  2400              MOVS     r4,#0
000020  e00a              B        |L4.56|
                  |L4.34|
;;;292    			{
;;;293    				/* 第1步：发起I2C总线启动信号 */
;;;294    				i2c_Start();
000022  f7fffffe          BL       i2c_Start
;;;295    
;;;296    				/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;297    				
;;;298    				#if EE_ADDR_A8 == 1					/* 此处原版_______有BUG _usAddress */
;;;299    					i2c_SendByte(EE_DEV_ADDR | I2C_WR | ((usAddr >> 7) & 0x0E));	/* 此处是写指令 */
;;;300    				#else				
;;;301    					i2c_SendByte(EE_DEV_ADDR | I2C_WR);
000026  20a0              MOVS     r0,#0xa0
000028  f7fffffe          BL       i2c_SendByte
;;;302    				#endif
;;;303    
;;;304    				/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;305    				if (i2c_WaitAck() == 0)
00002c  f7fffffe          BL       i2c_WaitAck
000030  b900              CBNZ     r0,|L4.52|
;;;306    				{
;;;307    					break;
000032  e004              B        |L4.62|
                  |L4.52|
000034  1c60              ADDS     r0,r4,#1              ;291
000036  b284              UXTH     r4,r0                 ;291
                  |L4.56|
000038  f5b47f7a          CMP      r4,#0x3e8             ;291
00003c  dbf1              BLT      |L4.34|
                  |L4.62|
00003e  bf00              NOP      
;;;308    				}
;;;309    			}
;;;310    			if (m  == 1000)
000040  f5b47f7a          CMP      r4,#0x3e8
000044  d100              BNE      |L4.72|
;;;311    			{
;;;312    				goto cmd_fail;	/* EEPROM器件写超时 */
000046  e033              B        |L4.176|
                  |L4.72|
;;;313    			}
;;;314    
;;;315    			/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;316    			if (EE_ADDR_BYTES == 1)
;;;317    			{
;;;318    				i2c_SendByte((uint8_t)usAddr);
000048  b2f0              UXTB     r0,r6
00004a  f7fffffe          BL       i2c_SendByte
;;;319    				if (i2c_WaitAck() != 0)
00004e  f7fffffe          BL       i2c_WaitAck
000052  b100              CBZ      r0,|L4.86|
;;;320    				{
;;;321    					goto cmd_fail;	/* EEPROM器件无应答 */
000054  e02c              B        |L4.176|
                  |L4.86|
;;;322    				}
;;;323    			}
;;;324    			else
;;;325    			{
;;;326    				i2c_SendByte(usAddr >> 8);
;;;327    				if (i2c_WaitAck() != 0)
;;;328    				{
;;;329    					goto cmd_fail;	/* EEPROM器件无应答 */
;;;330    				}
;;;331    
;;;332    				i2c_SendByte(usAddr);
;;;333    				if (i2c_WaitAck() != 0)
;;;334    				{
;;;335    					goto cmd_fail;	/* EEPROM器件无应答 */
;;;336    				}
;;;337    			}
;;;338    		}
;;;339    
;;;340    		/* 第6步：开始写入数据 */
;;;341    		/* _rease>0?0xFF:_pWriteBuf[i]  夏欢欢修改 */
;;;342    		//i2c_SendByte(_rease>0?0xFF:_pWriteBuf[i]);
;;;343            i2c_SendByte(_rease>0?0x00:_pWriteBuf[i]);
000056  2f00              CMP      r7,#0
000058  dd01              BLE      |L4.94|
00005a  2100              MOVS     r1,#0
00005c  e001              B        |L4.98|
                  |L4.94|
00005e  f8181005          LDRB     r1,[r8,r5]
                  |L4.98|
000062  4608              MOV      r0,r1
000064  f7fffffe          BL       i2c_SendByte
;;;344    		/* 第7步：发送ACK */
;;;345    		if (i2c_WaitAck() != 0)
000068  f7fffffe          BL       i2c_WaitAck
00006c  b100              CBZ      r0,|L4.112|
;;;346    		{
;;;347    			goto cmd_fail;	/* EEPROM器件无应答 */
00006e  e01f              B        |L4.176|
                  |L4.112|
;;;348    		}
;;;349    
;;;350    		usAddr++;	/* 地址增1 */
000070  1c70              ADDS     r0,r6,#1
000072  b286              UXTH     r6,r0
000074  1c68              ADDS     r0,r5,#1              ;280
000076  b285              UXTH     r5,r0                 ;280
                  |L4.120|
000078  4555              CMP      r5,r10                ;280
00007a  dbca              BLT      |L4.18|
;;;351    	}
;;;352    
;;;353    	/* 命令执行成功，发送I2C总线停止信号 */
;;;354    	i2c_Stop();
00007c  f7fffffe          BL       i2c_Stop
;;;355    
;;;356    	/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms
;;;357    		CLK频率为200KHz时，查询次数为30次左右
;;;358    	*/
;;;359    	for (m = 0; m < 1000; m++)
000080  2400              MOVS     r4,#0
000082  e00a              B        |L4.154|
                  |L4.132|
;;;360    	{
;;;361    		/* 第1步：发起I2C总线启动信号 */
;;;362    		i2c_Start();
000084  f7fffffe          BL       i2c_Start
;;;363    
;;;364    		/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */	
;;;365    		#if EE_ADDR_A8 == 1											/* 这个地方改不改有待调试 */
;;;366    			i2c_SendByte(EE_DEV_ADDR | I2C_WR | ((_usAddress >> 7) & 0x0E));	/* 此处是写指令 */
;;;367    		#else		
;;;368    			i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
000088  20a0              MOVS     r0,#0xa0
00008a  f7fffffe          BL       i2c_SendByte
;;;369    		#endif
;;;370    
;;;371    		/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;372    		if (i2c_WaitAck() == 0)
00008e  f7fffffe          BL       i2c_WaitAck
000092  b900              CBNZ     r0,|L4.150|
;;;373    		{
;;;374    			break;
000094  e004              B        |L4.160|
                  |L4.150|
000096  1c60              ADDS     r0,r4,#1              ;359
000098  b284              UXTH     r4,r0                 ;359
                  |L4.154|
00009a  f5b47f7a          CMP      r4,#0x3e8             ;359
00009e  dbf1              BLT      |L4.132|
                  |L4.160|
0000a0  bf00              NOP      
;;;375    		}
;;;376    	}
;;;377    	if (m  == 1000)
0000a2  f5b47f7a          CMP      r4,#0x3e8
0000a6  d100              BNE      |L4.170|
;;;378    	{
;;;379    		goto cmd_fail;	/* EEPROM器件写超时 */
0000a8  e002              B        |L4.176|
                  |L4.170|
;;;380    	}
;;;381    
;;;382    	/* 打开写保护 */
;;;383    	//WP = 1;
;;;384    
;;;385    	return 1;
0000aa  2001              MOVS     r0,#1
                  |L4.172|
;;;386    
;;;387    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;388    	/* 发送I2C总线停止信号 */
;;;389    	i2c_Stop();
;;;390    
;;;391    	/* 打开写保护 */
;;;392    	//WP = 1;
;;;393    
;;;394    	return 0;
;;;395    }
0000ac  e8bd87f0          POP      {r4-r10,pc}
                  |L4.176|
0000b0  f7fffffe          BL       i2c_Stop
0000b4  2000              MOVS     r0,#0                 ;394
0000b6  e7f9              B        |L4.172|
;;;396    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  eeResult
                          %        256

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_eeprom_24xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH|
#line 128
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
