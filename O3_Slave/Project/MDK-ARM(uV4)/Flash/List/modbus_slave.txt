; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\modbus_slave.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\modbus_slave.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\User -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User\app\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\modbus_slave.crf ..\..\User\app\src\modbus_slave.c]
                          THUMB

                          AREA ||i.MODS_01H||, CODE, READONLY, ALIGN=2

                  MODS_01H PROC
;;;260    /* 说明:这里用LED代替继电器,便于观察现象 */
;;;261    static void MODS_01H(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;262    {
;;;263    	/*
;;;264    	 举例：
;;;265    		主机发送:
;;;266    			11 从机地址
;;;267    			01 功能码
;;;268    			00 寄存器起始地址高字节
;;;269    			13 寄存器起始地址低字节
;;;270    			00 寄存器数量高字节
;;;271    			25 寄存器数量低字节
;;;272    			0E CRC校验高字节
;;;273    			84 CRC校验低字节
;;;274    
;;;275    		从机应答: 	1代表ON，0代表OFF。若返回的线圈数不为8的倍数，则在最后数据字节未尾使用0代替. BIT0对应第1个
;;;276    			11 从机地址
;;;277    			01 功能码
;;;278    			05 返回字节数
;;;279    			CD 数据1(线圈0013H-线圈001AH)
;;;280    			6B 数据2(线圈001BH-线圈0022H)
;;;281    			B2 数据3(线圈0023H-线圈002AH)
;;;282    			0E 数据4(线圈0032H-线圈002BH)
;;;283    			1B 数据5(线圈0037H-线圈0033H)
;;;284    			45 CRC校验高字节
;;;285    			E6 CRC校验低字节
;;;286    
;;;287    		例子:
;;;288    			01 01 10 01 00 03   29 0B	--- 查询D01开始的3个继电器状态
;;;289    			01 01 10 03 00 01   09 0A   --- 查询D03继电器的状态
;;;290    	*/
;;;291    	uint16_t reg;
;;;292    	uint16_t num;
;;;293    	uint16_t i;
;;;294    	uint16_t m;
;;;295    	uint8_t status[10];
;;;296    	
;;;297    	g_tModS.RspCode = RSP_OK;
000002  2000              MOVS     r0,#0
000004  4951              LDR      r1,|L1.332|
000006  f8810043          STRB     r0,[r1,#0x43]
;;;298    
;;;299    	/* 没有外部继电器，直接应答错误 */
;;;300    	if (g_tModS.RxCount != 8)
00000a  4608              MOV      r0,r1
00000c  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModS
000010  2808              CMP      r0,#8
000012  d003              BEQ      |L1.28|
;;;301    	{
;;;302    		g_tModS.RspCode = RSP_ERR_VALUE;				/* 数据值域错误 */
000014  2003              MOVS     r0,#3
000016  f8810043          STRB     r0,[r1,#0x43]
                  |L1.26|
;;;303    		return;
;;;304    	}
;;;305    
;;;306    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 			/* 寄存器号 */
;;;307    	num = BEBufToUint16(&g_tModS.RxBuf[4]);				/* 寄存器个数 */
;;;308    
;;;309    	m = (num + 7) / 8;
;;;310    	
;;;311    	if ((reg >= REG_D01) && (num > 0) && (reg + num <= REG_DXX + 1))
;;;312    	{
;;;313    		for (i = 0; i < m; i++)
;;;314    		{
;;;315    			status[i] = 0;
;;;316    		}
;;;317    		for (i = 0; i < num; i++)
;;;318    		{
;;;319    			if (bsp_IsLedOn(i + 1 + reg - REG_D01))		/* 读LED的状态，写入状态寄存器的每一位 */
;;;320    			{  
;;;321    				status[i / 8] |= (1 << (i % 8));
;;;322    			}
;;;323    		}
;;;324    	}
;;;325    	else
;;;326    	{
;;;327    		g_tModS.RspCode = RSP_ERR_REG_ADDR;				/* 寄存器地址错误 */
;;;328    	}
;;;329    
;;;330    	if (g_tModS.RspCode == RSP_OK)						/* 正确应答 */
;;;331    	{
;;;332    		g_tModS.TxCount = 0;
;;;333    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
;;;334    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
;;;335    		g_tModS.TxBuf[g_tModS.TxCount++] = m;			/* 返回字节数 */
;;;336    
;;;337    		for (i = 0; i < m; i++)
;;;338    		{
;;;339    			g_tModS.TxBuf[g_tModS.TxCount++] = status[i];	/* 继电器状态 */
;;;340    		}
;;;341    		MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);
;;;342    	}
;;;343    	else
;;;344    	{
;;;345    		MODS_SendAckErr(g_tModS.RspCode);				/* 告诉主机命令错误 */
;;;346    	}
;;;347    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L1.28|
00001c  484b              LDR      r0,|L1.332|
00001e  1c80              ADDS     r0,r0,#2              ;306
000020  f7fffffe          BL       BEBufToUint16
000024  4607              MOV      r7,r0                 ;306
000026  4849              LDR      r0,|L1.332|
000028  1d00              ADDS     r0,r0,#4              ;307
00002a  f7fffffe          BL       BEBufToUint16
00002e  4605              MOV      r5,r0                 ;307
000030  1de8              ADDS     r0,r5,#7              ;309
000032  17c1              ASRS     r1,r0,#31             ;309
000034  eb007151          ADD      r1,r0,r1,LSR #29      ;309
000038  10ce              ASRS     r6,r1,#3              ;309
00003a  2f01              CMP      r7,#1                 ;311
00003c  db34              BLT      |L1.168|
00003e  2d00              CMP      r5,#0                 ;311
000040  dd32              BLE      |L1.168|
000042  1978              ADDS     r0,r7,r5              ;311
000044  2805              CMP      r0,#5                 ;311
000046  dc2f              BGT      |L1.168|
000048  2400              MOVS     r4,#0                 ;313
00004a  e004              B        |L1.86|
                  |L1.76|
00004c  2000              MOVS     r0,#0                 ;315
00004e  f80d0004          STRB     r0,[sp,r4]            ;315
000052  1c60              ADDS     r0,r4,#1              ;313
000054  b284              UXTH     r4,r0                 ;313
                  |L1.86|
000056  42b4              CMP      r4,r6                 ;313
000058  dbf8              BLT      |L1.76|
00005a  2400              MOVS     r4,#0                 ;317
00005c  e021              B        |L1.162|
                  |L1.94|
00005e  1c61              ADDS     r1,r4,#1              ;319
000060  4439              ADD      r1,r1,r7              ;319
000062  1e49              SUBS     r1,r1,#1              ;319
000064  b2c8              UXTB     r0,r1                 ;319
000066  f7fffffe          BL       bsp_IsLedOn
00006a  b1c0              CBZ      r0,|L1.158|
00006c  17e2              ASRS     r2,r4,#31             ;321
00006e  eb047252          ADD      r2,r4,r2,LSR #29      ;321
000072  10d2              ASRS     r2,r2,#3              ;321
000074  f81d2002          LDRB     r2,[sp,r2]            ;321
000078  4621              MOV      r1,r4                 ;321
00007a  17e3              ASRS     r3,r4,#31             ;321
00007c  eb047353          ADD      r3,r4,r3,LSR #29      ;321
000080  10db              ASRS     r3,r3,#3              ;321
000082  eba40cc3          SUB      r12,r4,r3,LSL #3      ;321
000086  2301              MOVS     r3,#1                 ;321
000088  fa03f30c          LSL      r3,r3,r12             ;321
00008c  431a              ORRS     r2,r2,r3              ;321
00008e  b2d2              UXTB     r2,r2                 ;321
000090  4620              MOV      r0,r4                 ;321
000092  17e3              ASRS     r3,r4,#31             ;321
000094  eb047353          ADD      r3,r4,r3,LSR #29      ;321
000098  10db              ASRS     r3,r3,#3              ;321
00009a  f80d2003          STRB     r2,[sp,r3]            ;321
                  |L1.158|
00009e  1c60              ADDS     r0,r4,#1              ;317
0000a0  b284              UXTH     r4,r0                 ;317
                  |L1.162|
0000a2  42ac              CMP      r4,r5                 ;317
0000a4  dbdb              BLT      |L1.94|
0000a6  e003              B        |L1.176|
                  |L1.168|
0000a8  2002              MOVS     r0,#2                 ;327
0000aa  4928              LDR      r1,|L1.332|
0000ac  f8810043          STRB     r0,[r1,#0x43]         ;327
                  |L1.176|
0000b0  4826              LDR      r0,|L1.332|
0000b2  f8900043          LDRB     r0,[r0,#0x43]         ;330  ; g_tModS
0000b6  2800              CMP      r0,#0                 ;330
0000b8  d141              BNE      |L1.318|
0000ba  4924              LDR      r1,|L1.332|
0000bc  f88100c4          STRB     r0,[r1,#0xc4]         ;332
0000c0  4608              MOV      r0,r1                 ;333
0000c2  7801              LDRB     r1,[r0,#0]            ;333  ; g_tModS
0000c4  f89020c4          LDRB     r2,[r0,#0xc4]         ;333  ; g_tModS
0000c8  f89000c4          LDRB     r0,[r0,#0xc4]         ;333  ; g_tModS
0000cc  1c40              ADDS     r0,r0,#1              ;333
0000ce  4b1f              LDR      r3,|L1.332|
0000d0  f88300c4          STRB     r0,[r3,#0xc4]         ;333
0000d4  f1030044          ADD      r0,r3,#0x44           ;333
0000d8  5481              STRB     r1,[r0,r2]            ;333
0000da  3844              SUBS     r0,r0,#0x44           ;334
0000dc  7841              LDRB     r1,[r0,#1]            ;334  ; g_tModS
0000de  f89020c4          LDRB     r2,[r0,#0xc4]         ;334  ; g_tModS
0000e2  f89000c4          LDRB     r0,[r0,#0xc4]         ;334  ; g_tModS
0000e6  1c40              ADDS     r0,r0,#1              ;334
0000e8  f88300c4          STRB     r0,[r3,#0xc4]         ;334
0000ec  f1030044          ADD      r0,r3,#0x44           ;334
0000f0  5481              STRB     r1,[r0,r2]            ;334
0000f2  3844              SUBS     r0,r0,#0x44           ;335
0000f4  f89020c4          LDRB     r2,[r0,#0xc4]         ;335  ; g_tModS
0000f8  f89000c4          LDRB     r0,[r0,#0xc4]         ;335  ; g_tModS
0000fc  1c40              ADDS     r0,r0,#1              ;335
0000fe  f88300c4          STRB     r0,[r3,#0xc4]         ;335
000102  f1030044          ADD      r0,r3,#0x44           ;335
000106  5486              STRB     r6,[r0,r2]            ;335
000108  2400              MOVS     r4,#0                 ;337
00010a  e00f              B        |L1.300|
                  |L1.268|
00010c  f81d1004          LDRB     r1,[sp,r4]            ;339
000110  480e              LDR      r0,|L1.332|
000112  f89020c4          LDRB     r2,[r0,#0xc4]         ;339  ; g_tModS
000116  f89000c4          LDRB     r0,[r0,#0xc4]         ;339  ; g_tModS
00011a  1c40              ADDS     r0,r0,#1              ;339
00011c  4b0b              LDR      r3,|L1.332|
00011e  f88300c4          STRB     r0,[r3,#0xc4]         ;339
000122  f1030044          ADD      r0,r3,#0x44           ;339
000126  5481              STRB     r1,[r0,r2]            ;339
000128  1c60              ADDS     r0,r4,#1              ;337
00012a  b284              UXTH     r4,r0                 ;337
                  |L1.300|
00012c  42b4              CMP      r4,r6                 ;337
00012e  dbed              BLT      |L1.268|
000130  4806              LDR      r0,|L1.332|
000132  f89010c4          LDRB     r1,[r0,#0xc4]         ;341  ; g_tModS
000136  3044              ADDS     r0,r0,#0x44           ;341
000138  f7fffffe          BL       MODS_SendWithCRC
00013c  e004              B        |L1.328|
                  |L1.318|
00013e  4903              LDR      r1,|L1.332|
000140  f8910043          LDRB     r0,[r1,#0x43]         ;345  ; g_tModS
000144  f7fffffe          BL       MODS_SendAckErr
                  |L1.328|
000148  bf00              NOP      
00014a  e766              B        |L1.26|
;;;348    
                          ENDP

                  |L1.332|
                          DCD      g_tModS

                          AREA ||i.MODS_02H||, CODE, READONLY, ALIGN=2

                  MODS_02H PROC
;;;356    */
;;;357    static void MODS_02H(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;358    {
;;;359    	/*
;;;360    		主机发送:
;;;361    			11 从机地址
;;;362    			02 功能码
;;;363    			00 寄存器地址高字节
;;;364    			C4 寄存器地址低字节
;;;365    			00 寄存器数量高字节
;;;366    			16 寄存器数量低字节
;;;367    			BA CRC校验高字节
;;;368    			A9 CRC校验低字节
;;;369    
;;;370    		从机应答:  响应各离散输入寄存器状态，分别对应数据区中的每位值，1 代表ON；0 代表OFF。
;;;371    		           第一个数据字节的LSB(最低字节)为查询的寻址地址，其他输入口按顺序在该字节中由低字节
;;;372    		           向高字节排列，直到填充满8位。下一个字节中的8个输入位也是从低字节到高字节排列。
;;;373    		           若返回的输入位数不是8的倍数，则在最后的数据字节中的剩余位至该字节的最高位使用0填充。
;;;374    			11 从机地址
;;;375    			02 功能码
;;;376    			03 返回字节数
;;;377    			AC 数据1(00C4H-00CBH)
;;;378    			DB 数据2(00CCH-00D3H)
;;;379    			35 数据3(00D4H-00D9H)
;;;380    			20 CRC校验高字节
;;;381    			18 CRC校验低字节
;;;382    
;;;383    		例子:
;;;384    		01 02 20 01 00 08  23CC  ---- 读取T01-08的状态
;;;385    		01 02 20 04 00 02  B3CA  ---- 读取T04-05的状态
;;;386    		01 02 20 01 00 12  A207   ---- 读 T01-18
;;;387    	*/
;;;388    
;;;389    	uint16_t reg;
;;;390    	uint16_t num;
;;;391    	uint16_t i;
;;;392    	uint16_t m;
;;;393    	uint8_t status[10];
;;;394    
;;;395    	g_tModS.RspCode = RSP_OK;
000002  2000              MOVS     r0,#0
000004  494f              LDR      r1,|L2.324|
000006  f8810043          STRB     r0,[r1,#0x43]
;;;396    
;;;397    	if (g_tModS.RxCount != 8)
00000a  4608              MOV      r0,r1
00000c  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModS
000010  2808              CMP      r0,#8
000012  d003              BEQ      |L2.28|
;;;398    	{
;;;399    		g_tModS.RspCode = RSP_ERR_VALUE;				/* 数据值域错误 */
000014  2003              MOVS     r0,#3
000016  f8810043          STRB     r0,[r1,#0x43]
                  |L2.26|
;;;400    		return;
;;;401    	}
;;;402    
;;;403    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 			/* 寄存器号 */
;;;404    	num = BEBufToUint16(&g_tModS.RxBuf[4]);				/* 寄存器个数 */
;;;405    
;;;406    	m = (num + 7) / 8;
;;;407    	if ((reg >= REG_T01) && (num > 0) && (reg + num <= REG_TXX + 1))
;;;408    	{
;;;409    		for (i = 0; i < m; i++)
;;;410    		{
;;;411    			status[i] = 0;
;;;412    		}
;;;413    		for (i = 0; i < num; i++)
;;;414    		{
;;;415    			//if (bsp_GetKeyState((KEY_ID_E)(KID_K1 + reg - REG_T01 + i)))
;;;416    			{
;;;417    				status[i / 8] |= (1 << (i % 8));
;;;418    			}
;;;419    		}
;;;420    	}
;;;421    	else
;;;422    	{
;;;423    		g_tModS.RspCode = RSP_ERR_REG_ADDR;				/* 寄存器地址错误 */
;;;424    	}
;;;425    
;;;426    	if (g_tModS.RspCode == RSP_OK)						/* 正确应答 */
;;;427    	{
;;;428    		g_tModS.TxCount = 0;
;;;429    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
;;;430    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
;;;431    		g_tModS.TxBuf[g_tModS.TxCount++] = m;			/* 返回字节数 */
;;;432    
;;;433    		for (i = 0; i < m; i++)
;;;434    		{
;;;435    			g_tModS.TxBuf[g_tModS.TxCount++] = status[i];	/* T01-02状态 */
;;;436    		}
;;;437    		MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);
;;;438    	}
;;;439    	else
;;;440    	{
;;;441    		MODS_SendAckErr(g_tModS.RspCode);				/* 告诉主机命令错误 */
;;;442    	}
;;;443    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L2.28|
00001c  4849              LDR      r0,|L2.324|
00001e  1c80              ADDS     r0,r0,#2              ;403
000020  f7fffffe          BL       BEBufToUint16
000024  4607              MOV      r7,r0                 ;403
000026  4847              LDR      r0,|L2.324|
000028  1d00              ADDS     r0,r0,#4              ;404
00002a  f7fffffe          BL       BEBufToUint16
00002e  4605              MOV      r5,r0                 ;404
000030  1de8              ADDS     r0,r5,#7              ;406
000032  17c1              ASRS     r1,r0,#31             ;406
000034  eb007151          ADD      r1,r0,r1,LSR #29      ;406
000038  10ce              ASRS     r6,r1,#3              ;406
00003a  f5b77f00          CMP      r7,#0x200             ;407
00003e  dd2e              BLE      |L2.158|
000040  2d00              CMP      r5,#0                 ;407
000042  dd2c              BLE      |L2.158|
000044  1978              ADDS     r0,r7,r5              ;407
000046  f5b07f01          CMP      r0,#0x204             ;407
00004a  dc28              BGT      |L2.158|
00004c  2400              MOVS     r4,#0                 ;409
00004e  e004              B        |L2.90|
                  |L2.80|
000050  2000              MOVS     r0,#0                 ;411
000052  f80d0004          STRB     r0,[sp,r4]            ;411
000056  1c60              ADDS     r0,r4,#1              ;409
000058  b284              UXTH     r4,r0                 ;409
                  |L2.90|
00005a  42b4              CMP      r4,r6                 ;409
00005c  dbf8              BLT      |L2.80|
00005e  2400              MOVS     r4,#0                 ;413
000060  e01a              B        |L2.152|
                  |L2.98|
000062  17e2              ASRS     r2,r4,#31             ;417
000064  eb047252          ADD      r2,r4,r2,LSR #29      ;417
000068  10d2              ASRS     r2,r2,#3              ;417
00006a  f81d2002          LDRB     r2,[sp,r2]            ;417
00006e  4621              MOV      r1,r4                 ;417
000070  17e3              ASRS     r3,r4,#31             ;417
000072  eb047353          ADD      r3,r4,r3,LSR #29      ;417
000076  10db              ASRS     r3,r3,#3              ;417
000078  eba40cc3          SUB      r12,r4,r3,LSL #3      ;417
00007c  2301              MOVS     r3,#1                 ;417
00007e  fa03f30c          LSL      r3,r3,r12             ;417
000082  431a              ORRS     r2,r2,r3              ;417
000084  b2d2              UXTB     r2,r2                 ;417
000086  4620              MOV      r0,r4                 ;417
000088  17e3              ASRS     r3,r4,#31             ;417
00008a  eb047353          ADD      r3,r4,r3,LSR #29      ;417
00008e  10db              ASRS     r3,r3,#3              ;417
000090  f80d2003          STRB     r2,[sp,r3]            ;417
000094  1c60              ADDS     r0,r4,#1              ;413
000096  b284              UXTH     r4,r0                 ;413
                  |L2.152|
000098  42ac              CMP      r4,r5                 ;413
00009a  dbe2              BLT      |L2.98|
00009c  e003              B        |L2.166|
                  |L2.158|
00009e  2002              MOVS     r0,#2                 ;423
0000a0  4928              LDR      r1,|L2.324|
0000a2  f8810043          STRB     r0,[r1,#0x43]         ;423
                  |L2.166|
0000a6  4827              LDR      r0,|L2.324|
0000a8  f8900043          LDRB     r0,[r0,#0x43]         ;426  ; g_tModS
0000ac  2800              CMP      r0,#0                 ;426
0000ae  d141              BNE      |L2.308|
0000b0  4924              LDR      r1,|L2.324|
0000b2  f88100c4          STRB     r0,[r1,#0xc4]         ;428
0000b6  4608              MOV      r0,r1                 ;429
0000b8  7801              LDRB     r1,[r0,#0]            ;429  ; g_tModS
0000ba  f89020c4          LDRB     r2,[r0,#0xc4]         ;429  ; g_tModS
0000be  f89000c4          LDRB     r0,[r0,#0xc4]         ;429  ; g_tModS
0000c2  1c40              ADDS     r0,r0,#1              ;429
0000c4  4b1f              LDR      r3,|L2.324|
0000c6  f88300c4          STRB     r0,[r3,#0xc4]         ;429
0000ca  f1030044          ADD      r0,r3,#0x44           ;429
0000ce  5481              STRB     r1,[r0,r2]            ;429
0000d0  3844              SUBS     r0,r0,#0x44           ;430
0000d2  7841              LDRB     r1,[r0,#1]            ;430  ; g_tModS
0000d4  f89020c4          LDRB     r2,[r0,#0xc4]         ;430  ; g_tModS
0000d8  f89000c4          LDRB     r0,[r0,#0xc4]         ;430  ; g_tModS
0000dc  1c40              ADDS     r0,r0,#1              ;430
0000de  f88300c4          STRB     r0,[r3,#0xc4]         ;430
0000e2  f1030044          ADD      r0,r3,#0x44           ;430
0000e6  5481              STRB     r1,[r0,r2]            ;430
0000e8  3844              SUBS     r0,r0,#0x44           ;431
0000ea  f89020c4          LDRB     r2,[r0,#0xc4]         ;431  ; g_tModS
0000ee  f89000c4          LDRB     r0,[r0,#0xc4]         ;431  ; g_tModS
0000f2  1c40              ADDS     r0,r0,#1              ;431
0000f4  f88300c4          STRB     r0,[r3,#0xc4]         ;431
0000f8  f1030044          ADD      r0,r3,#0x44           ;431
0000fc  5486              STRB     r6,[r0,r2]            ;431
0000fe  2400              MOVS     r4,#0                 ;433
000100  e00f              B        |L2.290|
                  |L2.258|
000102  f81d1004          LDRB     r1,[sp,r4]            ;435
000106  480f              LDR      r0,|L2.324|
000108  f89020c4          LDRB     r2,[r0,#0xc4]         ;435  ; g_tModS
00010c  f89000c4          LDRB     r0,[r0,#0xc4]         ;435  ; g_tModS
000110  1c40              ADDS     r0,r0,#1              ;435
000112  4b0c              LDR      r3,|L2.324|
000114  f88300c4          STRB     r0,[r3,#0xc4]         ;435
000118  f1030044          ADD      r0,r3,#0x44           ;435
00011c  5481              STRB     r1,[r0,r2]            ;435
00011e  1c60              ADDS     r0,r4,#1              ;433
000120  b284              UXTH     r4,r0                 ;433
                  |L2.290|
000122  42b4              CMP      r4,r6                 ;433
000124  dbed              BLT      |L2.258|
000126  4807              LDR      r0,|L2.324|
000128  f89010c4          LDRB     r1,[r0,#0xc4]         ;437  ; g_tModS
00012c  3044              ADDS     r0,r0,#0x44           ;437
00012e  f7fffffe          BL       MODS_SendWithCRC
000132  e004              B        |L2.318|
                  |L2.308|
000134  4903              LDR      r1,|L2.324|
000136  f8910043          LDRB     r0,[r1,#0x43]         ;441  ; g_tModS
00013a  f7fffffe          BL       MODS_SendAckErr
                  |L2.318|
00013e  bf00              NOP      
000140  e76b              B        |L2.26|
;;;444    
                          ENDP

000142  0000              DCW      0x0000
                  |L2.324|
                          DCD      g_tModS

                          AREA ||i.MODS_03H||, CODE, READONLY, ALIGN=2

                  MODS_03H PROC
;;;688    */
;;;689    static void MODS_03H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;690    {
000002  b090              SUB      sp,sp,#0x40
;;;691    	/*
;;;692    		从机地址为11H。保持寄存器的起始地址为006BH，结束地址为006DH。该次查询总共访问3个保持寄存器。
;;;693    
;;;694    		主机发送:
;;;695    			11 从机地址
;;;696    			03 功能码
;;;697    			00 寄存器地址高字节
;;;698    			6B 寄存器地址低字节
;;;699    			00 寄存器数量高字节
;;;700    			03 寄存器数量低字节
;;;701    			76 CRC高字节
;;;702    			87 CRC低字节
;;;703    
;;;704    		从机应答: 	保持寄存器的长度为2个字节。对于单个保持寄存器而言，寄存器高字节数据先被传输，
;;;705    					低字节数据后被传输。保持寄存器之间，低地址寄存器先被传输，高地址寄存器后被传输。
;;;706    			11 从机地址
;;;707    			03 功能码
;;;708    			06 字节数
;;;709    			00 数据1高字节(006BH)
;;;710    			6B 数据1低字节(006BH)
;;;711    			00 数据2高字节(006CH)
;;;712    			13 数据2 低字节(006CH)
;;;713    			00 数据3高字节(006DH)
;;;714    			00 数据3低字节(006DH)
;;;715    			38 CRC高字节
;;;716    			B9 CRC低字节
;;;717    
;;;718    		例子:
;;;719    			01 03 30 06 00 01  6B0B      ---- 读 3006H, 触发电流
;;;720    			01 03 4000 0010 51C6         ---- 读 4000H 倒数第1条浪涌记录 32字节
;;;721    			01 03 4001 0010 0006         ---- 读 4001H 倒数第1条浪涌记录 32字节
;;;722    
;;;723    			01 03 F000 0008 770C         ---- 读 F000H 倒数第1条告警记录 16字节
;;;724    			01 03 F001 0008 26CC         ---- 读 F001H 倒数第2条告警记录 16字节
;;;725    
;;;726    			01 03 7000 0020 5ED2         ---- 读 7000H 倒数第1条波形记录第1段 64字节
;;;727    			01 03 7001 0020 0F12         ---- 读 7001H 倒数第1条波形记录第2段 64字节
;;;728    
;;;729    			01 03 7040 0020 5F06         ---- 读 7040H 倒数第2条波形记录第1段 64字节
;;;730    	*/
;;;731    	uint16_t reg;
;;;732    	uint16_t num;
;;;733    	uint16_t i;
;;;734    	uint8_t reg_value[64];
;;;735    
;;;736    	g_tModS.RspCode = RSP_OK;
000004  2000              MOVS     r0,#0
000006  4949              LDR      r1,|L3.300|
000008  f8810043          STRB     r0,[r1,#0x43]
;;;737    
;;;738    	if (g_tModS.RxCount != 8)								/* 03H命令必须是8个字节 */
00000c  4608              MOV      r0,r1
00000e  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModS
000012  2808              CMP      r0,#8
000014  d003              BEQ      |L3.30|
;;;739    	{
;;;740    		g_tModS.RspCode = RSP_ERR_VALUE;					/* 数据值域错误 */
000016  2003              MOVS     r0,#3
000018  f8810043          STRB     r0,[r1,#0x43]
;;;741    		goto err_ret;
00001c  e027              B        |L3.110|
                  |L3.30|
;;;742    	}
;;;743    
;;;744    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 				/* 寄存器号 */
00001e  4843              LDR      r0,|L3.300|
000020  1c80              ADDS     r0,r0,#2
000022  f7fffffe          BL       BEBufToUint16
000026  4606              MOV      r6,r0
;;;745    	num = BEBufToUint16(&g_tModS.RxBuf[4]);					/* 寄存器个数 */
000028  4840              LDR      r0,|L3.300|
00002a  1d00              ADDS     r0,r0,#4
00002c  f7fffffe          BL       BEBufToUint16
000030  4605              MOV      r5,r0
;;;746    	if (num > sizeof(reg_value) / 2)
000032  2d20              CMP      r5,#0x20
000034  d904              BLS      |L3.64|
;;;747    	{
;;;748    		g_tModS.RspCode = RSP_ERR_VALUE;					/* 数据值域错误 */
000036  2003              MOVS     r0,#3
000038  493c              LDR      r1,|L3.300|
00003a  f8810043          STRB     r0,[r1,#0x43]
;;;749    		goto err_ret;
00003e  e016              B        |L3.110|
                  |L3.64|
;;;750    	}
;;;751    
;;;752    	for (i = 0; i < num; i++)
000040  2400              MOVS     r4,#0
000042  e010              B        |L3.102|
                  |L3.68|
;;;753    	{
;;;754    		if (MODS_ReadRegValue(reg, &reg_value[2 * i]) == 0)	/* 读出寄存器值放入reg_value */
000044  4668              MOV      r0,sp
000046  2202              MOVS     r2,#2
000048  fb020104          MLA      r1,r2,r4,r0
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       MODS_ReadRegValue
000052  b920              CBNZ     r0,|L3.94|
;;;755    		{
;;;756    			g_tModS.RspCode = RSP_ERR_REG_ADDR;				/* 寄存器地址错误 */
000054  2002              MOVS     r0,#2
000056  4935              LDR      r1,|L3.300|
000058  f8810043          STRB     r0,[r1,#0x43]
;;;757    			break;
00005c  e005              B        |L3.106|
                  |L3.94|
;;;758    		}
;;;759    		reg++;
00005e  1c70              ADDS     r0,r6,#1
000060  b286              UXTH     r6,r0
000062  1c60              ADDS     r0,r4,#1              ;752
000064  b284              UXTH     r4,r0                 ;752
                  |L3.102|
000066  42ac              CMP      r4,r5                 ;752
000068  dbec              BLT      |L3.68|
                  |L3.106|
00006a  bf00              NOP                            ;757
;;;760    	}
;;;761    
;;;762    err_ret:
00006c  bf00              NOP      
                  |L3.110|
;;;763    	if (g_tModS.RspCode == RSP_OK)							/* 正确应答 */
00006e  482f              LDR      r0,|L3.300|
000070  f8900043          LDRB     r0,[r0,#0x43]  ; g_tModS
000074  2800              CMP      r0,#0
000076  d152              BNE      |L3.286|
;;;764    	{
;;;765    		g_tModS.TxCount = 0;
000078  492c              LDR      r1,|L3.300|
00007a  f88100c4          STRB     r0,[r1,#0xc4]
;;;766    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
00007e  4608              MOV      r0,r1
000080  7801              LDRB     r1,[r0,#0]  ; g_tModS
000082  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModS
000086  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModS
00008a  1c40              ADDS     r0,r0,#1
00008c  4b27              LDR      r3,|L3.300|
00008e  f88300c4          STRB     r0,[r3,#0xc4]
000092  f1030044          ADD      r0,r3,#0x44
000096  5481              STRB     r1,[r0,r2]
;;;767    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
000098  3844              SUBS     r0,r0,#0x44
00009a  7841              LDRB     r1,[r0,#1]  ; g_tModS
00009c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModS
0000a0  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModS
0000a4  1c40              ADDS     r0,r0,#1
0000a6  f88300c4          STRB     r0,[r3,#0xc4]
0000aa  f1030044          ADD      r0,r3,#0x44
0000ae  5481              STRB     r1,[r0,r2]
;;;768    		g_tModS.TxBuf[g_tModS.TxCount++] = num * 2;			/* 返回字节数 */
0000b0  0668              LSLS     r0,r5,#25
0000b2  0e01              LSRS     r1,r0,#24
0000b4  4618              MOV      r0,r3
0000b6  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModS
0000ba  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModS
0000be  1c40              ADDS     r0,r0,#1
0000c0  f88300c4          STRB     r0,[r3,#0xc4]
0000c4  f1030044          ADD      r0,r3,#0x44
0000c8  5481              STRB     r1,[r0,r2]
;;;769    
;;;770    		for (i = 0; i < num; i++)
0000ca  2400              MOVS     r4,#0
0000cc  e01e              B        |L3.268|
                  |L3.206|
;;;771    		{
;;;772    			g_tModS.TxBuf[g_tModS.TxCount++] = reg_value[2*i];
0000ce  f81d1014          LDRB     r1,[sp,r4,LSL #1]
0000d2  4816              LDR      r0,|L3.300|
0000d4  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModS
0000d8  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModS
0000dc  1c40              ADDS     r0,r0,#1
0000de  4b13              LDR      r3,|L3.300|
0000e0  f88300c4          STRB     r0,[r3,#0xc4]
0000e4  f1030044          ADD      r0,r3,#0x44
0000e8  5481              STRB     r1,[r0,r2]
;;;773    			g_tModS.TxBuf[g_tModS.TxCount++] = reg_value[2*i+1];
0000ea  0060              LSLS     r0,r4,#1
0000ec  1c40              ADDS     r0,r0,#1
0000ee  f81d1000          LDRB     r1,[sp,r0]
0000f2  4618              MOV      r0,r3
0000f4  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModS
0000f8  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModS
0000fc  1c40              ADDS     r0,r0,#1
0000fe  f88300c4          STRB     r0,[r3,#0xc4]
000102  f1030044          ADD      r0,r3,#0x44
000106  5481              STRB     r1,[r0,r2]
000108  1c60              ADDS     r0,r4,#1              ;770
00010a  b284              UXTH     r4,r0                 ;770
                  |L3.268|
00010c  42ac              CMP      r4,r5                 ;770
00010e  dbde              BLT      |L3.206|
;;;774    		}
;;;775    		MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);	/* 发送正确应答 */
000110  4806              LDR      r0,|L3.300|
000112  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModS
000116  3044              ADDS     r0,r0,#0x44
000118  f7fffffe          BL       MODS_SendWithCRC
00011c  e004              B        |L3.296|
                  |L3.286|
;;;776    	}
;;;777    	else
;;;778    	{
;;;779    		MODS_SendAckErr(g_tModS.RspCode);					/* 发送错误应答 */
00011e  4903              LDR      r1,|L3.300|
000120  f8910043          LDRB     r0,[r1,#0x43]  ; g_tModS
000124  f7fffffe          BL       MODS_SendAckErr
                  |L3.296|
;;;780    	}
;;;781    }
000128  b010              ADD      sp,sp,#0x40
00012a  bd70              POP      {r4-r6,pc}
;;;782    
                          ENDP

                  |L3.300|
                          DCD      g_tModS

                          AREA ||i.MODS_04H||, CODE, READONLY, ALIGN=2

                  MODS_04H PROC
;;;790    */
;;;791    static void MODS_04H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;792    {
000002  b086              SUB      sp,sp,#0x18
;;;793    	/*
;;;794    		主机发送:
;;;795    			11 从机地址
;;;796    			04 功能码
;;;797    			00 寄存器起始地址高字节
;;;798    			08 寄存器起始地址低字节
;;;799    			00 寄存器个数高字节
;;;800    			02 寄存器个数低字节
;;;801    			F2 CRC高字节
;;;802    			99 CRC低字节
;;;803    
;;;804    		从机应答:  输入寄存器长度为2个字节。对于单个输入寄存器而言，寄存器高字节数据先被传输，
;;;805    				低字节数据后被传输。输入寄存器之间，低地址寄存器先被传输，高地址寄存器后被传输。
;;;806    			11 从机地址
;;;807    			04 功能码
;;;808    			04 字节数
;;;809    			00 数据1高字节(0008H)
;;;810    			0A 数据1低字节(0008H)
;;;811    			00 数据2高字节(0009H)
;;;812    			0B 数据2低字节(0009H)
;;;813    			8B CRC高字节
;;;814    			80 CRC低字节
;;;815    
;;;816    		例子:
;;;817    
;;;818    			01 04 2201 0006 2BB0  --- 读 2201H A01通道模拟量 开始的6个数据
;;;819    			01 04 2201 0001 6A72  --- 读 2201H
;;;820    
;;;821    	*/
;;;822    	uint16_t reg;
;;;823    	uint16_t num;
;;;824    	uint16_t i;
;;;825    	uint16_t status[10];
;;;826    
;;;827    	memset(status, 0, 10);
000004  210a              MOVS     r1,#0xa
000006  a801              ADD      r0,sp,#4
000008  f7fffffe          BL       __aeabi_memclr4
;;;828    
;;;829    	g_tModS.RspCode = RSP_OK;
00000c  2000              MOVS     r0,#0
00000e  494e              LDR      r1,|L4.328|
000010  f8810043          STRB     r0,[r1,#0x43]
;;;830    
;;;831    	if (g_tModS.RxCount != 8)
000014  4608              MOV      r0,r1
000016  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModS
00001a  2808              CMP      r0,#8
00001c  d003              BEQ      |L4.38|
;;;832    	{
;;;833    		g_tModS.RspCode = RSP_ERR_VALUE;	/* 数据值域错误 */
00001e  2003              MOVS     r0,#3
000020  f8810043          STRB     r0,[r1,#0x43]
;;;834    		goto err_ret;
000024  e030              B        |L4.136|
                  |L4.38|
;;;835    	}
;;;836    
;;;837    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
000026  4848              LDR      r0,|L4.328|
000028  1c80              ADDS     r0,r0,#2
00002a  f7fffffe          BL       BEBufToUint16
00002e  4606              MOV      r6,r0
;;;838    	num = BEBufToUint16(&g_tModS.RxBuf[4]);	/* 寄存器个数 */
000030  4845              LDR      r0,|L4.328|
000032  1d00              ADDS     r0,r0,#4
000034  f7fffffe          BL       BEBufToUint16
000038  4605              MOV      r5,r0
;;;839    	
;;;840    	if ((reg >= REG_A01) && (num > 0) && (reg + num <= REG_AXX + 1))
00003a  f5b66f80          CMP      r6,#0x400
00003e  dd1e              BLE      |L4.126|
000040  2d00              CMP      r5,#0
000042  dd1c              BLE      |L4.126|
000044  1970              ADDS     r0,r6,r5
000046  f2404102          MOV      r1,#0x402
00004a  4288              CMP      r0,r1
00004c  dc17              BGT      |L4.126|
;;;841    	{	
;;;842    		for (i = 0; i < num; i++)
00004e  2400              MOVS     r4,#0
000050  e012              B        |L4.120|
                  |L4.82|
;;;843    		{
;;;844    			switch (reg)
000052  f2a64001          SUB      r0,r6,#0x401
000056  b928              CBNZ     r0,|L4.100|
;;;845    			{
;;;846    				/* 测试参数 */
;;;847    				case REG_A01:
;;;848    					status[i] = g_tVar.A01;
000058  483c              LDR      r0,|L4.332|
00005a  8f80              LDRH     r0,[r0,#0x3c]  ; g_tVar
00005c  a901              ADD      r1,sp,#4
00005e  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;849    					break;
000062  e004              B        |L4.110|
                  |L4.100|
;;;850    					
;;;851    				default:
;;;852    					status[i] = 0;
000064  2000              MOVS     r0,#0
000066  a901              ADD      r1,sp,#4
000068  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;853    					break;
00006c  bf00              NOP      
                  |L4.110|
00006e  bf00              NOP                            ;849
;;;854    			}
;;;855    			reg++;
000070  1c70              ADDS     r0,r6,#1
000072  b286              UXTH     r6,r0
000074  1c60              ADDS     r0,r4,#1              ;842
000076  b284              UXTH     r4,r0                 ;842
                  |L4.120|
000078  42ac              CMP      r4,r5                 ;842
00007a  dbea              BLT      |L4.82|
00007c  e003              B        |L4.134|
                  |L4.126|
;;;856    		}
;;;857    	}
;;;858    	else
;;;859    	{
;;;860    		g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
00007e  2002              MOVS     r0,#2
000080  4931              LDR      r1,|L4.328|
000082  f8810043          STRB     r0,[r1,#0x43]
                  |L4.134|
;;;861    	}
;;;862    
;;;863    err_ret:
000086  bf00              NOP      
                  |L4.136|
;;;864    	if (g_tModS.RspCode == RSP_OK)		/* 正确应答 */
000088  482f              LDR      r0,|L4.328|
00008a  f8900043          LDRB     r0,[r0,#0x43]  ; g_tModS
00008e  2800              CMP      r0,#0
000090  d153              BNE      |L4.314|
;;;865    	{
;;;866    		g_tModS.TxCount = 0;
000092  492d              LDR      r1,|L4.328|
000094  f88100c4          STRB     r0,[r1,#0xc4]
;;;867    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
000098  4608              MOV      r0,r1
00009a  7801              LDRB     r1,[r0,#0]  ; g_tModS
00009c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModS
0000a0  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModS
0000a4  1c40              ADDS     r0,r0,#1
0000a6  4b28              LDR      r3,|L4.328|
0000a8  f88300c4          STRB     r0,[r3,#0xc4]
0000ac  f1030044          ADD      r0,r3,#0x44
0000b0  5481              STRB     r1,[r0,r2]
;;;868    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
0000b2  3844              SUBS     r0,r0,#0x44
0000b4  7841              LDRB     r1,[r0,#1]  ; g_tModS
0000b6  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModS
0000ba  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModS
0000be  1c40              ADDS     r0,r0,#1
0000c0  f88300c4          STRB     r0,[r3,#0xc4]
0000c4  f1030044          ADD      r0,r3,#0x44
0000c8  5481              STRB     r1,[r0,r2]
;;;869    		g_tModS.TxBuf[g_tModS.TxCount++] = num * 2;			/* 返回字节数 */
0000ca  0668              LSLS     r0,r5,#25
0000cc  0e01              LSRS     r1,r0,#24
0000ce  4618              MOV      r0,r3
0000d0  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModS
0000d4  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModS
0000d8  1c40              ADDS     r0,r0,#1
0000da  f88300c4          STRB     r0,[r3,#0xc4]
0000de  f1030044          ADD      r0,r3,#0x44
0000e2  5481              STRB     r1,[r0,r2]
;;;870    
;;;871    		for (i = 0; i < num; i++)
0000e4  2400              MOVS     r4,#0
0000e6  e01f              B        |L4.296|
                  |L4.232|
;;;872    		{
;;;873    			g_tModS.TxBuf[g_tModS.TxCount++] = status[i] >> 8;
0000e8  a801              ADD      r0,sp,#4
0000ea  f8300014          LDRH     r0,[r0,r4,LSL #1]
0000ee  1201              ASRS     r1,r0,#8
0000f0  4815              LDR      r0,|L4.328|
0000f2  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModS
0000f6  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModS
0000fa  1c40              ADDS     r0,r0,#1
0000fc  4b12              LDR      r3,|L4.328|
0000fe  f88300c4          STRB     r0,[r3,#0xc4]
000102  f1030044          ADD      r0,r3,#0x44
000106  5481              STRB     r1,[r0,r2]
;;;874    			g_tModS.TxBuf[g_tModS.TxCount++] = status[i] & 0xFF;
000108  a801              ADD      r0,sp,#4
00010a  f8101014          LDRB     r1,[r0,r4,LSL #1]
00010e  4618              MOV      r0,r3
000110  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModS
000114  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModS
000118  1c40              ADDS     r0,r0,#1
00011a  f88300c4          STRB     r0,[r3,#0xc4]
00011e  f1030044          ADD      r0,r3,#0x44
000122  5481              STRB     r1,[r0,r2]
000124  1c60              ADDS     r0,r4,#1              ;871
000126  b284              UXTH     r4,r0                 ;871
                  |L4.296|
000128  42ac              CMP      r4,r5                 ;871
00012a  dbdd              BLT      |L4.232|
;;;875    		}
;;;876    		MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);
00012c  4806              LDR      r0,|L4.328|
00012e  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModS
000132  3044              ADDS     r0,r0,#0x44
000134  f7fffffe          BL       MODS_SendWithCRC
000138  e004              B        |L4.324|
                  |L4.314|
;;;877    	}
;;;878    	else
;;;879    	{
;;;880    		MODS_SendAckErr(g_tModS.RspCode);	/* 告诉主机命令错误 */
00013a  4903              LDR      r1,|L4.328|
00013c  f8910043          LDRB     r0,[r1,#0x43]  ; g_tModS
000140  f7fffffe          BL       MODS_SendAckErr
                  |L4.324|
;;;881    	}
;;;882    }
000144  b006              ADD      sp,sp,#0x18
000146  bd70              POP      {r4-r6,pc}
;;;883    
                          ENDP

                  |L4.328|
                          DCD      g_tModS
                  |L4.332|
                          DCD      g_tVar

                          AREA ||i.MODS_05H||, CODE, READONLY, ALIGN=2

                  MODS_05H PROC
;;;891    */
;;;892    static void MODS_05H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;893    {
;;;894    	/*
;;;895    		主机发送: 写单个线圈寄存器。FF00H值请求线圈处于ON状态，0000H值请求线圈处于OFF状态
;;;896    		。05H指令设置单个线圈的状态，15H指令可以设置多个线圈的状态。
;;;897    			11 从机地址
;;;898    			05 功能码
;;;899    			00 寄存器地址高字节
;;;900    			AC 寄存器地址低字节
;;;901    			FF 数据1高字节
;;;902    			00 数据2低字节
;;;903    			4E CRC校验高字节
;;;904    			8B CRC校验低字节
;;;905    
;;;906    		从机应答:
;;;907    			11 从机地址
;;;908    			05 功能码
;;;909    			00 寄存器地址高字节
;;;910    			AC 寄存器地址低字节
;;;911    			FF 寄存器1高字节
;;;912    			00 寄存器1低字节
;;;913    			4E CRC校验高字节
;;;914    			8B CRC校验低字节
;;;915    
;;;916    		例子:
;;;917    		01 05 10 01 FF 00   D93A   -- D01打开
;;;918    		01 05 10 01 00 00   98CA   -- D01关闭
;;;919    
;;;920    		01 05 10 02 FF 00   293A   -- D02打开
;;;921    		01 05 10 02 00 00   68CA   -- D02关闭
;;;922    
;;;923    		01 05 10 03 FF 00   78FA   -- D03打开
;;;924    		01 05 10 03 00 00   390A   -- D03关闭
;;;925    	*/
;;;926    	uint16_t reg;
;;;927    	uint16_t value;
;;;928    
;;;929    	g_tModS.RspCode = RSP_OK;
000002  2000              MOVS     r0,#0
000004  4923              LDR      r1,|L5.148|
000006  f8810043          STRB     r0,[r1,#0x43]
;;;930    	
;;;931    	if (g_tModS.RxCount != 8)
00000a  4608              MOV      r0,r1
00000c  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModS
000010  2808              CMP      r0,#8
000012  d003              BEQ      |L5.28|
;;;932    	{
;;;933    		g_tModS.RspCode = RSP_ERR_VALUE;		/* 数据值域错误 */
000014  2003              MOVS     r0,#3
000016  f8810043          STRB     r0,[r1,#0x43]
;;;934    		goto err_ret;
00001a  e02e              B        |L5.122|
                  |L5.28|
;;;935    	}
;;;936    
;;;937    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
00001c  481d              LDR      r0,|L5.148|
00001e  1c80              ADDS     r0,r0,#2
000020  f7fffffe          BL       BEBufToUint16
000024  4605              MOV      r5,r0
;;;938    	value = BEBufToUint16(&g_tModS.RxBuf[4]);	/* 数据 */
000026  481b              LDR      r0,|L5.148|
000028  1d00              ADDS     r0,r0,#4
00002a  f7fffffe          BL       BEBufToUint16
00002e  4604              MOV      r4,r0
;;;939    	
;;;940    	//if (value != 0 && value != 1)
;;;941        if (value != 0X0000 && value != 0xFF00)
000030  b13c              CBZ      r4,|L5.66|
000032  f5b44f7f          CMP      r4,#0xff00
000036  d004              BEQ      |L5.66|
;;;942    	{
;;;943    		g_tModS.RspCode = RSP_ERR_VALUE;		/* 数据值域错误 */
000038  2003              MOVS     r0,#3
00003a  4916              LDR      r1,|L5.148|
00003c  f8810043          STRB     r0,[r1,#0x43]
;;;944    		goto err_ret;
000040  e01b              B        |L5.122|
                  |L5.66|
;;;945    	}
;;;946    	
;;;947    	if (reg == REG_D01)
000042  2d01              CMP      r5,#1
000044  d102              BNE      |L5.76|
;;;948    	{
;;;949    		g_tVar.D01 = value;
000046  4814              LDR      r0,|L5.152|
000048  87c4              STRH     r4,[r0,#0x3e]
00004a  e015              B        |L5.120|
                  |L5.76|
;;;950    	}
;;;951    	else if (reg == REG_D02)
00004c  2d02              CMP      r5,#2
00004e  d103              BNE      |L5.88|
;;;952    	{
;;;953    		g_tVar.D02 = value;
000050  4811              LDR      r0,|L5.152|
000052  f8a04040          STRH     r4,[r0,#0x40]
000056  e00f              B        |L5.120|
                  |L5.88|
;;;954    	}
;;;955    	else if (reg == REG_D03)
000058  2d03              CMP      r5,#3
00005a  d103              BNE      |L5.100|
;;;956    	{
;;;957    		g_tVar.D03 = value;
00005c  480e              LDR      r0,|L5.152|
00005e  f8a04042          STRH     r4,[r0,#0x42]
000062  e009              B        |L5.120|
                  |L5.100|
;;;958    	}
;;;959    	else if (reg == REG_D04)
000064  2d04              CMP      r5,#4
000066  d103              BNE      |L5.112|
;;;960    	{
;;;961    		g_tVar.D04 = value;
000068  480b              LDR      r0,|L5.152|
00006a  f8a04044          STRH     r4,[r0,#0x44]
00006e  e003              B        |L5.120|
                  |L5.112|
;;;962    	}
;;;963    	else
;;;964    	{
;;;965    		g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
000070  2002              MOVS     r0,#2
000072  4908              LDR      r1,|L5.148|
000074  f8810043          STRB     r0,[r1,#0x43]
                  |L5.120|
;;;966    	}
;;;967    err_ret:
000078  bf00              NOP      
                  |L5.122|
;;;968    	if (g_tModS.RspCode == RSP_OK)				/* 正确应答 */
00007a  4806              LDR      r0,|L5.148|
00007c  f8900043          LDRB     r0,[r0,#0x43]  ; g_tModS
000080  b910              CBNZ     r0,|L5.136|
;;;969    	{
;;;970    		MODS_SendAckOk();
000082  f7fffffe          BL       MODS_SendAckOk
000086  e004              B        |L5.146|
                  |L5.136|
;;;971    	}
;;;972    	else
;;;973    	{
;;;974    		MODS_SendAckErr(g_tModS.RspCode);		/* 告诉主机命令错误 */
000088  4902              LDR      r1,|L5.148|
00008a  f8910043          LDRB     r0,[r1,#0x43]  ; g_tModS
00008e  f7fffffe          BL       MODS_SendAckErr
                  |L5.146|
;;;975    	}
;;;976    }
000092  bd70              POP      {r4-r6,pc}
;;;977    
                          ENDP

                  |L5.148|
                          DCD      g_tModS
                  |L5.152|
                          DCD      g_tVar

                          AREA ||i.MODS_06H||, CODE, READONLY, ALIGN=2

                  MODS_06H PROC
;;;985    */
;;;986    static void MODS_06H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;987    {
;;;988    
;;;989    	/*
;;;990    		写保持寄存器。注意06指令只能操作单个保持寄存器，16指令可以设置单个或多个保持寄存器
;;;991    
;;;992    		主机发送:
;;;993    			11 从机地址
;;;994    			06 功能码
;;;995    			00 寄存器地址高字节
;;;996    			01 寄存器地址低字节
;;;997    			00 数据1高字节
;;;998    			01 数据1低字节
;;;999    			9A CRC校验高字节
;;;1000   			9B CRC校验低字节
;;;1001   
;;;1002   		从机响应:
;;;1003   			11 从机地址
;;;1004   			06 功能码
;;;1005   			00 寄存器地址高字节
;;;1006   			01 寄存器地址低字节
;;;1007   			00 数据1高字节
;;;1008   			01 数据1低字节
;;;1009   			1B CRC校验高字节
;;;1010   			5A	CRC校验低字节
;;;1011   
;;;1012   		例子:
;;;1013   			01 06 30 06 00 25  A710    ---- 触发电流设置为 2.5
;;;1014   			01 06 30 06 00 10  6707    ---- 触发电流设置为 1.0
;;;1015   
;;;1016   
;;;1017   			01 06 30 1B 00 00  F6CD    ---- SMA 滤波系数 = 0 关闭滤波
;;;1018   			01 06 30 1B 00 01  370D    ---- SMA 滤波系数 = 1
;;;1019   			01 06 30 1B 00 02  770C    ---- SMA 滤波系数 = 2
;;;1020   			01 06 30 1B 00 05  36CE    ---- SMA 滤波系数 = 5
;;;1021   
;;;1022   			01 06 30 07 00 01  F6CB    ---- 测试模式修改为 T1
;;;1023   			01 06 30 07 00 02  B6CA    ---- 测试模式修改为 T2
;;;1024   
;;;1025   			01 06 31 00 00 00  8736    ---- 擦除浪涌记录区
;;;1026   			01 06 31 01 00 00  D6F6    ---- 擦除告警记录区
;;;1027   
;;;1028   */
;;;1029   
;;;1030   	uint16_t reg;
;;;1031   	uint16_t value;
;;;1032   
;;;1033   	g_tModS.RspCode = RSP_OK;
000002  2000              MOVS     r0,#0
000004  4916              LDR      r1,|L6.96|
000006  f8810043          STRB     r0,[r1,#0x43]
;;;1034   
;;;1035   	if (g_tModS.RxCount != 8)
00000a  4608              MOV      r0,r1
00000c  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModS
000010  2808              CMP      r0,#8
000012  d003              BEQ      |L6.28|
;;;1036   	{
;;;1037   		g_tModS.RspCode = RSP_ERR_VALUE;		/* 数据值域错误 */
000014  2003              MOVS     r0,#3
000016  f8810043          STRB     r0,[r1,#0x43]
;;;1038   		goto err_ret;
00001a  e014              B        |L6.70|
                  |L6.28|
;;;1039   	}
;;;1040   
;;;1041   	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
00001c  4810              LDR      r0,|L6.96|
00001e  1c80              ADDS     r0,r0,#2
000020  f7fffffe          BL       BEBufToUint16
000024  4605              MOV      r5,r0
;;;1042   	value = BEBufToUint16(&g_tModS.RxBuf[4]);	/* 寄存器值 */
000026  480e              LDR      r0,|L6.96|
000028  1d00              ADDS     r0,r0,#4
00002a  f7fffffe          BL       BEBufToUint16
00002e  4604              MOV      r4,r0
;;;1043   
;;;1044   	if (MODS_WriteRegValue(reg, value) == 1)	/* 该函数会把写入的值存入寄存器 */
000030  4621              MOV      r1,r4
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       MODS_WriteRegValue
000038  2801              CMP      r0,#1
00003a  d003              BEQ      |L6.68|
;;;1045   	{
;;;1046   		;
;;;1047   	}
;;;1048   	else
;;;1049   	{
;;;1050   		g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
00003c  2002              MOVS     r0,#2
00003e  4908              LDR      r1,|L6.96|
000040  f8810043          STRB     r0,[r1,#0x43]
                  |L6.68|
;;;1051   	}
;;;1052   
;;;1053   err_ret:
000044  bf00              NOP      
                  |L6.70|
;;;1054   	if (g_tModS.RspCode == RSP_OK)				/* 正确应答 */
000046  4806              LDR      r0,|L6.96|
000048  f8900043          LDRB     r0,[r0,#0x43]  ; g_tModS
00004c  b910              CBNZ     r0,|L6.84|
;;;1055   	{
;;;1056   		MODS_SendAckOk();
00004e  f7fffffe          BL       MODS_SendAckOk
000052  e004              B        |L6.94|
                  |L6.84|
;;;1057   	}
;;;1058   	else
;;;1059   	{
;;;1060   		MODS_SendAckErr(g_tModS.RspCode);		/* 告诉主机命令错误 */
000054  4902              LDR      r1,|L6.96|
000056  f8910043          LDRB     r0,[r1,#0x43]  ; g_tModS
00005a  f7fffffe          BL       MODS_SendAckErr
                  |L6.94|
;;;1061   	}
;;;1062   }
00005e  bd70              POP      {r4-r6,pc}
;;;1063   
                          ENDP

                  |L6.96|
                          DCD      g_tModS

                          AREA ||i.MODS_10H||, CODE, READONLY, ALIGN=2

                  MODS_10H PROC
;;;1071   */
;;;1072   static void MODS_10H(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1073   {
;;;1074   	/*
;;;1075   		从机地址为11H。保持寄存器的其实地址为0001H，寄存器的结束地址为0002H。总共访问2个寄存器。
;;;1076   		保持寄存器0001H的内容为000AH，保持寄存器0002H的内容为0102H。
;;;1077   
;;;1078   		主机发送:
;;;1079   			11 从机地址
;;;1080   			10 功能码
;;;1081   			00 寄存器起始地址高字节
;;;1082   			01 寄存器起始地址低字节
;;;1083   			00 寄存器数量高字节
;;;1084   			02 寄存器数量低字节
;;;1085   			04 字节数
;;;1086   			00 数据1高字节
;;;1087   			0A 数据1低字节
;;;1088   			01 数据2高字节
;;;1089   			02 数据2低字节
;;;1090   			C6 CRC校验高字节
;;;1091   			F0 CRC校验低字节
;;;1092   
;;;1093   		从机响应:
;;;1094   			11 从机地址
;;;1095   			06 功能码
;;;1096   			00 寄存器地址高字节
;;;1097   			01 寄存器地址低字节
;;;1098   			00 数据1高字节
;;;1099   			01 数据1低字节
;;;1100   			1B CRC校验高字节
;;;1101   			5A	CRC校验低字节
;;;1102   
;;;1103   		例子:
;;;1104   			01 10 30 00 00 06 0C  07 DE  00 0A  00 01  00 08  00 0C  00 00     389A    ---- 写时钟 2014-10-01 08:12:00
;;;1105   			01 10 30 00 00 06 0C  07 DF  00 01  00 1F  00 17  00 3B  00 39     5549    ---- 写时钟 2015-01-31 23:59:57
;;;1106   
;;;1107   	*/
;;;1108   	uint16_t reg_addr;
;;;1109   	uint16_t reg_num;
;;;1110   	uint8_t byte_num;
;;;1111   	uint8_t i;
;;;1112   	uint16_t value;
;;;1113   	
;;;1114   	g_tModS.RspCode = RSP_OK;
000004  2000              MOVS     r0,#0
000006  4920              LDR      r1,|L7.136|
000008  f8810043          STRB     r0,[r1,#0x43]
;;;1115   
;;;1116   	if (g_tModS.RxCount < 11)
00000c  4608              MOV      r0,r1
00000e  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModS
000012  280b              CMP      r0,#0xb
000014  da03              BGE      |L7.30|
;;;1117   	{
;;;1118   		g_tModS.RspCode = RSP_ERR_VALUE;			/* 数据值域错误 */
000016  2003              MOVS     r0,#3
000018  f8810043          STRB     r0,[r1,#0x43]
;;;1119   		goto err_ret;
00001c  e026              B        |L7.108|
                  |L7.30|
;;;1120   	}
;;;1121   
;;;1122   	reg_addr = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
00001e  481a              LDR      r0,|L7.136|
000020  1c80              ADDS     r0,r0,#2
000022  f7fffffe          BL       BEBufToUint16
000026  4606              MOV      r6,r0
;;;1123   	reg_num = BEBufToUint16(&g_tModS.RxBuf[4]);		/* 寄存器个数 */
000028  4817              LDR      r0,|L7.136|
00002a  1d00              ADDS     r0,r0,#4
00002c  f7fffffe          BL       BEBufToUint16
000030  4605              MOV      r5,r0
;;;1124   	byte_num = g_tModS.RxBuf[6];					/* 后面的数据体字节数 */
000032  4815              LDR      r0,|L7.136|
000034  7987              LDRB     r7,[r0,#6]  ; g_tModS
;;;1125   
;;;1126   	if (byte_num != 2 * reg_num)
;;;1127   	{
;;;1128   		;
;;;1129   	}
;;;1130   	
;;;1131   	for (i = 0; i < reg_num; i++)
000036  2400              MOVS     r4,#0
000038  e014              B        |L7.100|
                  |L7.58|
;;;1132   	{
;;;1133   		value = BEBufToUint16(&g_tModS.RxBuf[7 + 2 * i]);	/* 寄存器值 */
00003a  0061              LSLS     r1,r4,#1
00003c  1dc9              ADDS     r1,r1,#7
00003e  4a12              LDR      r2,|L7.136|
000040  1888              ADDS     r0,r1,r2
000042  f7fffffe          BL       BEBufToUint16
000046  4680              MOV      r8,r0
;;;1134   
;;;1135   		if (MODS_WriteRegValue(reg_addr + i, value) == 1)
000048  1931              ADDS     r1,r6,r4
00004a  b288              UXTH     r0,r1
00004c  4641              MOV      r1,r8
00004e  f7fffffe          BL       MODS_WriteRegValue
000052  2801              CMP      r0,#1
000054  d004              BEQ      |L7.96|
;;;1136   		{
;;;1137   			;
;;;1138   		}
;;;1139   		else
;;;1140   		{
;;;1141   			g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
000056  2002              MOVS     r0,#2
000058  490b              LDR      r1,|L7.136|
00005a  f8810043          STRB     r0,[r1,#0x43]
;;;1142   			break;
00005e  e003              B        |L7.104|
                  |L7.96|
000060  1c60              ADDS     r0,r4,#1              ;1131
000062  b2c4              UXTB     r4,r0                 ;1131
                  |L7.100|
000064  42ac              CMP      r4,r5                 ;1131
000066  dbe8              BLT      |L7.58|
                  |L7.104|
000068  bf00              NOP      
;;;1143   		}
;;;1144   	}
;;;1145   
;;;1146   err_ret:
00006a  bf00              NOP      
                  |L7.108|
;;;1147   	if (g_tModS.RspCode == RSP_OK)					/* 正确应答 */
00006c  4806              LDR      r0,|L7.136|
00006e  f8900043          LDRB     r0,[r0,#0x43]  ; g_tModS
000072  b910              CBNZ     r0,|L7.122|
;;;1148   	{
;;;1149   		MODS_SendAckOk();
000074  f7fffffe          BL       MODS_SendAckOk
000078  e004              B        |L7.132|
                  |L7.122|
;;;1150   	}
;;;1151   	else
;;;1152   	{
;;;1153   		MODS_SendAckErr(g_tModS.RspCode);			/* 告诉主机命令错误 */
00007a  4903              LDR      r1,|L7.136|
00007c  f8910043          LDRB     r0,[r1,#0x43]  ; g_tModS
000080  f7fffffe          BL       MODS_SendAckErr
                  |L7.132|
;;;1154   	}
;;;1155   }
000084  e8bd81f0          POP      {r4-r8,pc}
;;;1156   
                          ENDP

                  |L7.136|
                          DCD      g_tModS

                          AREA ||i.MODS_AnalyzeApp||, CODE, READONLY, ALIGN=2

                  MODS_AnalyzeApp PROC
;;;205    */
;;;206    static void MODS_AnalyzeApp(void)
000000  b510              PUSH     {r4,lr}
;;;207    {
;;;208    	switch (g_tModS.RxBuf[1])				/* 第2个字节 功能码 */
000002  4819              LDR      r0,|L8.104|
000004  7840              LDRB     r0,[r0,#1]  ; g_tModS
000006  2804              CMP      r0,#4
000008  d017              BEQ      |L8.58|
00000a  dc06              BGT      |L8.26|
00000c  2801              CMP      r0,#1
00000e  d00b              BEQ      |L8.40|
000010  2802              CMP      r0,#2
000012  d00c              BEQ      |L8.46|
000014  2803              CMP      r0,#3
000016  d11c              BNE      |L8.82|
000018  e00c              B        |L8.52|
                  |L8.26|
00001a  2805              CMP      r0,#5
00001c  d010              BEQ      |L8.64|
00001e  2806              CMP      r0,#6
000020  d011              BEQ      |L8.70|
000022  2810              CMP      r0,#0x10
000024  d115              BNE      |L8.82|
000026  e011              B        |L8.76|
                  |L8.40|
;;;209    	{
;;;210    		case 0x01:							/* 读取线圈状态（此例程用led代替）*/
;;;211    			MODS_01H();
000028  f7fffffe          BL       MODS_01H
;;;212    			//bsp_PutMsg(MSG_MODS_01H, 0);	/* 发送消息,主程序处理 */
;;;213    			break;
00002c  e01a              B        |L8.100|
                  |L8.46|
;;;214    
;;;215    		case 0x02:							/* 读取输入状态（按键状态）*/
;;;216    			MODS_02H();
00002e  f7fffffe          BL       MODS_02H
;;;217    			//bsp_PutMsg(MSG_MODS_02H, 0);
;;;218    			break;
000032  e017              B        |L8.100|
                  |L8.52|
;;;219    		
;;;220    		case 0x03:							/* 读取保持寄存器（此例程存在g_tVar中）*/
;;;221    			MODS_03H();
000034  f7fffffe          BL       MODS_03H
;;;222    			//bsp_PutMsg(MSG_MODS_03H, 0);
;;;223    			break;
000038  e014              B        |L8.100|
                  |L8.58|
;;;224    		
;;;225    		case 0x04:							/* 读取输入寄存器（ADC的值）*/
;;;226    			MODS_04H();
00003a  f7fffffe          BL       MODS_04H
;;;227    			//bsp_PutMsg(MSG_MODS_04H, 0);
;;;228    			break;
00003e  e011              B        |L8.100|
                  |L8.64|
;;;229    		
;;;230    		case 0x05:							/* 强制单线圈（设置led）*/
;;;231    			MODS_05H();
000040  f7fffffe          BL       MODS_05H
;;;232    			//bsp_PutMsg(MSG_MODS_05H, 0);
;;;233    			break;
000044  e00e              B        |L8.100|
                  |L8.70|
;;;234    		
;;;235    		case 0x06:							/* 写单个保存寄存器（此例程改写g_tVar中的参数）*/
;;;236    			MODS_06H();	
000046  f7fffffe          BL       MODS_06H
;;;237    			//bsp_PutMsg(MSG_MODS_06H, 0);
;;;238    			break;
00004a  e00b              B        |L8.100|
                  |L8.76|
;;;239    			
;;;240    		case 0x10:							/* 写多个保存寄存器（此例程存在g_tVar中的参数）*/
;;;241    			MODS_10H();
00004c  f7fffffe          BL       MODS_10H
;;;242    			//bsp_PutMsg(MSG_MODS_10H, 0);
;;;243    			break;
000050  e008              B        |L8.100|
                  |L8.82|
;;;244    		
;;;245    		default:
;;;246    			g_tModS.RspCode = RSP_ERR_CMD;
000052  2001              MOVS     r0,#1
000054  4904              LDR      r1,|L8.104|
000056  f8810043          STRB     r0,[r1,#0x43]
;;;247    			MODS_SendAckErr(g_tModS.RspCode);	/* 告诉主机命令错误 */
00005a  f8910043          LDRB     r0,[r1,#0x43]  ; g_tModS
00005e  f7fffffe          BL       MODS_SendAckErr
;;;248    			break;
000062  bf00              NOP      
                  |L8.100|
000064  bf00              NOP                            ;213
;;;249    	}
;;;250    }
000066  bd10              POP      {r4,pc}
;;;251    
                          ENDP

                  |L8.104|
                          DCD      g_tModS

                          AREA ||i.MODS_Poll||, CODE, READONLY, ALIGN=2

                  MODS_Poll PROC
;;;39     */
;;;40     void MODS_Poll(void)
000000  b570              PUSH     {r4-r6,lr}
;;;41     {
;;;42     	uint16_t addr;
;;;43     	uint16_t crc1;
;;;44     	/* 超过3.5个字符时间后执行MODH_RxTimeOut()函数。全局变量 g_rtu_timeout = 1; 通知主程序开始解码 */
;;;45     	if (g_mods_timeout == 0)	
000002  4812              LDR      r0,|L9.76|
000004  7800              LDRB     r0,[r0,#0]  ; g_mods_timeout
000006  b900              CBNZ     r0,|L9.10|
                  |L9.8|
;;;46     	{
;;;47     		return;								/* 没有超时，继续接收。不要清零 g_tModS.RxCount */
;;;48     	}
;;;49     	
;;;50     	g_mods_timeout = 0;	 					/* 清标志 */
;;;51     
;;;52     	if (g_tModS.RxCount < 4)				/* 接收到的数据小于4个字节就认为错误 */
;;;53     	{
;;;54     		goto err_ret;
;;;55     	}
;;;56     
;;;57     	/* 计算CRC校验和 */
;;;58     	crc1 = CRC16_Modbus(g_tModS.RxBuf, g_tModS.RxCount);
;;;59     	if (crc1 != 0)
;;;60     	{
;;;61     		goto err_ret;
;;;62     	}
;;;63     
;;;64     	/* 站地址 (1字节） */
;;;65     	addr = g_tModS.RxBuf[0];				/* 第1字节 站号 */
;;;66     	if (addr != SADDR485)		 			/* 判断主机发送的命令地址是否符合 */
;;;67     	{
;;;68     		goto err_ret;
;;;69     	}
;;;70     
;;;71     	/* 分析应用层协议 */
;;;72     	MODS_AnalyzeApp();						
;;;73     	
;;;74     err_ret:
;;;75     #if 0										/* 此部分为了串口打印结果,实际运用中可不要 */
;;;76     	g_tPrint.Rxlen = g_tModS.RxCount;
;;;77     	memcpy(g_tPrint.RxBuf, g_tModS.RxBuf, g_tModS.RxCount);
;;;78     #endif
;;;79     	
;;;80     	g_tModS.RxCount = 0;					/* 必须清零计数器，方便下次帧同步 */
;;;81     }
000008  bd70              POP      {r4-r6,pc}
                  |L9.10|
00000a  2000              MOVS     r0,#0                 ;50
00000c  490f              LDR      r1,|L9.76|
00000e  7008              STRB     r0,[r1,#0]            ;50
000010  480f              LDR      r0,|L9.80|
000012  f8900040          LDRB     r0,[r0,#0x40]         ;52  ; g_tModS
000016  2804              CMP      r0,#4                 ;52
000018  da00              BGE      |L9.28|
00001a  e011              B        |L9.64|
                  |L9.28|
00001c  480c              LDR      r0,|L9.80|
00001e  f8901040          LDRB     r1,[r0,#0x40]         ;58  ; g_tModS
000022  f7fffffe          BL       CRC16_Modbus
000026  4604              MOV      r4,r0                 ;58
000028  b104              CBZ      r4,|L9.44|
00002a  e009              B        |L9.64|
                  |L9.44|
00002c  4808              LDR      r0,|L9.80|
00002e  7805              LDRB     r5,[r0,#0]            ;65  ; g_tModS
000030  4808              LDR      r0,|L9.84|
000032  7800              LDRB     r0,[r0,#0]            ;66  ; SADDR485
000034  4285              CMP      r5,r0                 ;66
000036  d000              BEQ      |L9.58|
000038  e002              B        |L9.64|
                  |L9.58|
00003a  f7fffffe          BL       MODS_AnalyzeApp
00003e  bf00              NOP                            ;74
                  |L9.64|
000040  2000              MOVS     r0,#0                 ;80
000042  4903              LDR      r1,|L9.80|
000044  f8810040          STRB     r0,[r1,#0x40]         ;80
000048  bf00              NOP      
00004a  e7dd              B        |L9.8|
;;;82     
                          ENDP

                  |L9.76|
                          DCD      g_mods_timeout
                  |L9.80|
                          DCD      g_tModS
                  |L9.84|
                          DCD      SADDR485

                          AREA ||i.MODS_ReadRegValue||, CODE, READONLY, ALIGN=2

                  MODS_ReadRegValue PROC
;;;453    */
;;;454    static uint8_t MODS_ReadRegValue(uint16_t reg_addr, uint8_t *reg_value)
000000  4602              MOV      r2,r0
;;;455    {
000002  460b              MOV      r3,r1
;;;456    	uint16_t value;
;;;457    	
;;;458    	switch (reg_addr)									/* 判断寄存器地址 */
000004  2a1e              CMP      r2,#0x1e
000006  d26a              BCS      |L10.222|
000008  e8dff002          TBB      [pc,r2]
00000c  0f121518          DCB      0x0f,0x12,0x15,0x18
000010  1b1e2124          DCB      0x1b,0x1e,0x21,0x24
000014  272a2d30          DCB      0x27,0x2a,0x2d,0x30
000018  3336393c          DCB      0x33,0x36,0x39,0x3c
00001c  3f424548          DCB      0x3f,0x42,0x45,0x48
000020  4b4e5154          DCB      0x4b,0x4e,0x51,0x54
000024  575a5d60          DCB      0x57,0x5a,0x5d,0x60
000028  6366              DCB      0x63,0x66
;;;459    	{
;;;460    		case SLAVE_REG_P01:
;;;461    			value =	g_tVar.P01;	
00002a  4831              LDR      r0,|L10.240|
00002c  8801              LDRH     r1,[r0,#0]  ; g_tVar
;;;462    			break;
00002e  e058              B        |L10.226|
;;;463    
;;;464    		case SLAVE_REG_P02:
;;;465    			value =	g_tVar.P02;							/* 将寄存器值读出 */
000030  482f              LDR      r0,|L10.240|
000032  8841              LDRH     r1,[r0,#2]  ; g_tVar
;;;466    			break;
000034  e055              B        |L10.226|
;;;467            case SLAVE_REG_P03:
;;;468    			value =	g_tVar.P03;	
000036  482e              LDR      r0,|L10.240|
000038  8881              LDRH     r1,[r0,#4]  ; g_tVar
;;;469    			break;
00003a  e052              B        |L10.226|
;;;470    
;;;471    		case SLAVE_REG_P04:
;;;472    			value =	g_tVar.P04;							/* 将寄存器值读出 */
00003c  482c              LDR      r0,|L10.240|
00003e  88c1              LDRH     r1,[r0,#6]  ; g_tVar
;;;473    			break;
000040  e04f              B        |L10.226|
;;;474            case SLAVE_REG_P05:
;;;475    			value =	g_tVar.P05;	
000042  482b              LDR      r0,|L10.240|
000044  8901              LDRH     r1,[r0,#8]  ; g_tVar
;;;476    			break;
000046  e04c              B        |L10.226|
;;;477    
;;;478    		case SLAVE_REG_P06:
;;;479    			value =	g_tVar.P06;							/* 将寄存器值读出 */
000048  4829              LDR      r0,|L10.240|
00004a  8941              LDRH     r1,[r0,#0xa]  ; g_tVar
;;;480    			break;
00004c  e049              B        |L10.226|
;;;481            case SLAVE_REG_P07:
;;;482    			value =	g_tVar.P07;							/* 将寄存器值读出 */
00004e  4828              LDR      r0,|L10.240|
000050  8981              LDRH     r1,[r0,#0xc]  ; g_tVar
;;;483    			break;
000052  e046              B        |L10.226|
;;;484            case SLAVE_REG_P08:
;;;485    			value =	g_tVar.P08;							/* 将寄存器值读出 */
000054  4826              LDR      r0,|L10.240|
000056  89c1              LDRH     r1,[r0,#0xe]  ; g_tVar
;;;486    			break;
000058  e043              B        |L10.226|
;;;487            case SLAVE_REG_P09:
;;;488    			value =	g_tVar.P09;							/* 将寄存器值读出 */
00005a  4825              LDR      r0,|L10.240|
00005c  8a01              LDRH     r1,[r0,#0x10]  ; g_tVar
;;;489    			break;
00005e  e040              B        |L10.226|
;;;490            case SLAVE_REG_P10:
;;;491    			value =	g_tVar.P10;							/* 将寄存器值读出 */
000060  4823              LDR      r0,|L10.240|
000062  8a41              LDRH     r1,[r0,#0x12]  ; g_tVar
;;;492    			break;
000064  e03d              B        |L10.226|
;;;493            case SLAVE_REG_P11:
;;;494    			value =	g_tVar.P11;							/* 将寄存器值读出 */
000066  4822              LDR      r0,|L10.240|
000068  8a81              LDRH     r1,[r0,#0x14]  ; g_tVar
;;;495    			break;
00006a  e03a              B        |L10.226|
;;;496            		case SLAVE_REG_P12:
;;;497    			value =	g_tVar.P12;							/* 将寄存器值读出 */
00006c  4820              LDR      r0,|L10.240|
00006e  8ac1              LDRH     r1,[r0,#0x16]  ; g_tVar
;;;498    			break;
000070  e037              B        |L10.226|
;;;499            case SLAVE_REG_P13:
;;;500    			value =	g_tVar.P13;							/* 将寄存器值读出 */
000072  481f              LDR      r0,|L10.240|
000074  8b01              LDRH     r1,[r0,#0x18]  ; g_tVar
;;;501    			break;
000076  e034              B        |L10.226|
;;;502            case SLAVE_REG_P14:
;;;503    			value =	g_tVar.P14;							/* 将寄存器值读出 */
000078  481d              LDR      r0,|L10.240|
00007a  8b41              LDRH     r1,[r0,#0x1a]  ; g_tVar
;;;504    			break;
00007c  e031              B        |L10.226|
;;;505            		case SLAVE_REG_P15:
;;;506    			value =	g_tVar.P15;							/* 将寄存器值读出 */
00007e  481c              LDR      r0,|L10.240|
000080  8b81              LDRH     r1,[r0,#0x1c]  ; g_tVar
;;;507    			break;
000082  e02e              B        |L10.226|
;;;508            case SLAVE_REG_P16:
;;;509    			value =	g_tVar.P16;							/* 将寄存器值读出 */
000084  481a              LDR      r0,|L10.240|
000086  8bc1              LDRH     r1,[r0,#0x1e]  ; g_tVar
;;;510    			break;
000088  e02b              B        |L10.226|
;;;511            case SLAVE_REG_P17:
;;;512    			value =	g_tVar.P17;							/* 将寄存器值读出 */
00008a  4819              LDR      r0,|L10.240|
00008c  8c01              LDRH     r1,[r0,#0x20]  ; g_tVar
;;;513    			break;
00008e  e028              B        |L10.226|
;;;514            case SLAVE_REG_P18:
;;;515    			value =	g_tVar.P18;							/* 将寄存器值读出 */
000090  4817              LDR      r0,|L10.240|
000092  8c41              LDRH     r1,[r0,#0x22]  ; g_tVar
;;;516    			break;
000094  e025              B        |L10.226|
;;;517            case SLAVE_REG_P19:
;;;518    			value =	g_tVar.P19;							/* 将寄存器值读出 */
000096  4816              LDR      r0,|L10.240|
000098  8c81              LDRH     r1,[r0,#0x24]  ; g_tVar
;;;519    			break;
00009a  e022              B        |L10.226|
;;;520            case SLAVE_REG_P20:
;;;521    			value =	g_tVar.P20;							/* 将寄存器值读出 */
00009c  4814              LDR      r0,|L10.240|
00009e  8cc1              LDRH     r1,[r0,#0x26]  ; g_tVar
;;;522    			break;
0000a0  e01f              B        |L10.226|
;;;523            case SLAVE_REG_P21:
;;;524    			value =	g_tVar.P21;							/* 将寄存器值读出 */
0000a2  4813              LDR      r0,|L10.240|
0000a4  8d01              LDRH     r1,[r0,#0x28]  ; g_tVar
;;;525    			break;
0000a6  e01c              B        |L10.226|
;;;526            case SLAVE_REG_P22:
;;;527    			value =	g_tVar.P22;							/* 将寄存器值读出 */
0000a8  4811              LDR      r0,|L10.240|
0000aa  8d41              LDRH     r1,[r0,#0x2a]  ; g_tVar
;;;528    			break;
0000ac  e019              B        |L10.226|
;;;529            case SLAVE_REG_P23:
;;;530    			value =	g_tVar.P23;							/* 将寄存器值读出 */
0000ae  4810              LDR      r0,|L10.240|
0000b0  8d81              LDRH     r1,[r0,#0x2c]  ; g_tVar
;;;531    			break;
0000b2  e016              B        |L10.226|
;;;532            case SLAVE_REG_P24:
;;;533    			value =	g_tVar.P24;							/* 将寄存器值读出 */
0000b4  480e              LDR      r0,|L10.240|
0000b6  8dc1              LDRH     r1,[r0,#0x2e]  ; g_tVar
;;;534    			break;
0000b8  e013              B        |L10.226|
;;;535            case SLAVE_REG_P25:
;;;536    			value =	g_tVar.P25;							/* 将寄存器值读出 */
0000ba  480d              LDR      r0,|L10.240|
0000bc  8e01              LDRH     r1,[r0,#0x30]  ; g_tVar
;;;537    			break;
0000be  e010              B        |L10.226|
;;;538            case SLAVE_REG_P26:
;;;539    			value =	g_tVar.P26;							/* 将寄存器值读出 */
0000c0  480b              LDR      r0,|L10.240|
0000c2  8e41              LDRH     r1,[r0,#0x32]  ; g_tVar
;;;540    			break;
0000c4  e00d              B        |L10.226|
;;;541            case SLAVE_REG_P27:
;;;542    			value =	g_tVar.P27;							/* 将寄存器值读出 */
0000c6  480a              LDR      r0,|L10.240|
0000c8  8e81              LDRH     r1,[r0,#0x34]  ; g_tVar
;;;543    			break;
0000ca  e00a              B        |L10.226|
;;;544            case SLAVE_REG_P28:
;;;545    			value =	g_tVar.P28;							/* 将寄存器值读出 */
0000cc  4808              LDR      r0,|L10.240|
0000ce  8ec1              LDRH     r1,[r0,#0x36]  ; g_tVar
;;;546    			break;
0000d0  e007              B        |L10.226|
;;;547            case SLAVE_REG_P29:
;;;548    			value =	g_tVar.P29;							/* 将寄存器值读出 */
0000d2  4807              LDR      r0,|L10.240|
0000d4  8f01              LDRH     r1,[r0,#0x38]  ; g_tVar
;;;549    			break;
0000d6  e004              B        |L10.226|
;;;550            case SLAVE_REG_P30:
;;;551    			value =	g_tVar.P30;							/* 将寄存器值读出 */
0000d8  4805              LDR      r0,|L10.240|
0000da  8f41              LDRH     r1,[r0,#0x3a]  ; g_tVar
;;;552    			break;
0000dc  e001              B        |L10.226|
                  |L10.222|
;;;553            		
;;;554    	
;;;555    		default:
;;;556    			return 0;									/* 参数异常，返回 0 */
0000de  2000              MOVS     r0,#0
                  |L10.224|
;;;557    	}
;;;558    
;;;559    	reg_value[0] = value >> 8;
;;;560    	reg_value[1] = value;
;;;561    
;;;562    	return 1;											/* 读取成功 */
;;;563    }
0000e0  4770              BX       lr
                  |L10.226|
0000e2  bf00              NOP                            ;462
0000e4  1208              ASRS     r0,r1,#8              ;559
0000e6  7018              STRB     r0,[r3,#0]            ;559
0000e8  7059              STRB     r1,[r3,#1]            ;560
0000ea  2001              MOVS     r0,#1                 ;562
0000ec  e7f8              B        |L10.224|
;;;564    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L10.240|
                          DCD      g_tVar

                          AREA ||i.MODS_ReciveNew||, CODE, READONLY, ALIGN=2

                  MODS_ReciveNew PROC
;;;90     */
;;;91     void MODS_ReciveNew(uint8_t _byte)
000000  b570              PUSH     {r4-r6,lr}
;;;92     {
000002  4604              MOV      r4,r0
;;;93     	/*
;;;94     		3.5个字符的时间间隔，只是用在RTU模式下面，因为RTU模式没有开始符和结束符，
;;;95     		两个数据包之间只能靠时间间隔来区分，Modbus定义在不同的波特率下，间隔时间是不一样的，
;;;96     		所以就是3.5个字符的时间，波特率高，这个时间间隔就小，波特率低，这个时间间隔相应就大
;;;97     
;;;98     		4800  = 7.297ms
;;;99     		9600  = 3.646ms
;;;100    		19200  = 1.771ms
;;;101    		38400  = 0.885ms
;;;102    	*/
;;;103    	uint32_t timeout;
;;;104    
;;;105    	g_mods_timeout = 0;
000004  2000              MOVS     r0,#0
000006  490d              LDR      r1,|L11.60|
000008  7008              STRB     r0,[r1,#0]
;;;106    	
;;;107    	timeout = 35000000 / SBAUD485;			/* 计算超时时间，单位us 35000000*/
00000a  f240152f          MOV      r5,#0x12f
;;;108      //  timeout = 800000000 / SBAUD485;			/* 计算超时时间，单位us 35000000*/
;;;109    	
;;;110    	/* 硬件定时中断，定时精度us 硬件定时器1用于ADC, 定时器2用于Modbus */
;;;111    	bsp_StartHardTimer(1, timeout, (void *)MODS_RxTimeOut);
00000e  4a0c              LDR      r2,|L11.64|
000010  4629              MOV      r1,r5
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       bsp_StartHardTimer
;;;112    
;;;113    	if (g_tModS.RxCount < S_RX_BUF_SIZE)
000018  480a              LDR      r0,|L11.68|
00001a  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModS
00001e  2840              CMP      r0,#0x40
000020  da0a              BGE      |L11.56|
;;;114    	{
;;;115    		g_tModS.RxBuf[g_tModS.RxCount++] = _byte;
000022  4808              LDR      r0,|L11.68|
000024  f8901040          LDRB     r1,[r0,#0x40]  ; g_tModS
000028  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModS
00002c  1c40              ADDS     r0,r0,#1
00002e  4a05              LDR      r2,|L11.68|
000030  f8820040          STRB     r0,[r2,#0x40]
000034  4610              MOV      r0,r2
000036  5444              STRB     r4,[r0,r1]
                  |L11.56|
;;;116    	}
;;;117    }
000038  bd70              POP      {r4-r6,pc}
;;;118    
                          ENDP

00003a  0000              DCW      0x0000
                  |L11.60|
                          DCD      g_mods_timeout
                  |L11.64|
                          DCD      MODS_RxTimeOut
                  |L11.68|
                          DCD      g_tModS

                          AREA ||i.MODS_RxTimeOut||, CODE, READONLY, ALIGN=2

                  MODS_RxTimeOut PROC
;;;126    */
;;;127    static void MODS_RxTimeOut(void)
000000  2001              MOVS     r0,#1
;;;128    {
;;;129    	g_mods_timeout = 1;
000002  4901              LDR      r1,|L12.8|
000004  7008              STRB     r0,[r1,#0]
;;;130    }
000006  4770              BX       lr
;;;131    
                          ENDP

                  |L12.8|
                          DCD      g_mods_timeout

                          AREA ||i.MODS_SendAckErr||, CODE, READONLY, ALIGN=2

                  MODS_SendAckErr PROC
;;;166    */
;;;167    static void MODS_SendAckErr(uint8_t _ucErrCode)
000000  b538              PUSH     {r3-r5,lr}
;;;168    {
000002  4604              MOV      r4,r0
;;;169    	uint8_t txbuf[3];
;;;170    
;;;171    	txbuf[0] = g_tModS.RxBuf[0];					/* 485地址 */
000004  4808              LDR      r0,|L13.40|
000006  7800              LDRB     r0,[r0,#0]  ; g_tModS
000008  f88d0000          STRB     r0,[sp,#0]
;;;172    	txbuf[1] = g_tModS.RxBuf[1] | 0x80;				/* 异常的功能码 */
00000c  4806              LDR      r0,|L13.40|
00000e  7840              LDRB     r0,[r0,#1]  ; g_tModS
000010  f0400080          ORR      r0,r0,#0x80
000014  f88d0001          STRB     r0,[sp,#1]
;;;173    	txbuf[2] = _ucErrCode;							/* 错误代码(01,02,03,04) */
000018  f88d4002          STRB     r4,[sp,#2]
;;;174    
;;;175    	MODS_SendWithCRC(txbuf, 3);
00001c  2103              MOVS     r1,#3
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       MODS_SendWithCRC
;;;176    }
000024  bd38              POP      {r3-r5,pc}
;;;177    
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      g_tModS

                          AREA ||i.MODS_SendAckOk||, CODE, READONLY, ALIGN=2

                  MODS_SendAckOk PROC
;;;185    */
;;;186    static void MODS_SendAckOk(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;187    {
;;;188    	uint8_t txbuf[6];
;;;189    	uint8_t i;
;;;190    
;;;191    	for (i = 0; i < 6; i++)
000002  2400              MOVS     r4,#0
000004  e005              B        |L14.18|
                  |L14.6|
;;;192    	{
;;;193    		txbuf[i] = g_tModS.RxBuf[i];
000006  4806              LDR      r0,|L14.32|
000008  5d00              LDRB     r0,[r0,r4]
00000a  f80d0004          STRB     r0,[sp,r4]
00000e  1c60              ADDS     r0,r4,#1              ;191
000010  b2c4              UXTB     r4,r0                 ;191
                  |L14.18|
000012  2c06              CMP      r4,#6                 ;191
000014  dbf7              BLT      |L14.6|
;;;194    	}
;;;195    	MODS_SendWithCRC(txbuf, 6);
000016  2106              MOVS     r1,#6
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       MODS_SendWithCRC
;;;196    }
00001e  bd1c              POP      {r2-r4,pc}
;;;197    
                          ENDP

                  |L14.32|
                          DCD      g_tModS

                          AREA ||i.MODS_SendWithCRC||, CODE, READONLY, ALIGN=2

                  MODS_SendWithCRC PROC
;;;140    */
;;;141    static void MODS_SendWithCRC(uint8_t *_pBuf, uint8_t _ucLen)
000000  b570              PUSH     {r4-r6,lr}
;;;142    {
000002  b0a0              SUB      sp,sp,#0x80
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;143    	uint16_t crc;
;;;144    	uint8_t buf[S_TX_BUF_SIZE];
;;;145    
;;;146    	memcpy(buf, _pBuf, _ucLen);
000008  4622              MOV      r2,r4
00000a  4629              MOV      r1,r5
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy
;;;147    	crc = CRC16_Modbus(_pBuf, _ucLen);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       CRC16_Modbus
00001a  4606              MOV      r6,r0
;;;148    	buf[_ucLen++] = crc >> 8;
00001c  1232              ASRS     r2,r6,#8
00001e  4620              MOV      r0,r4
000020  1c61              ADDS     r1,r4,#1
000022  b2cc              UXTB     r4,r1
000024  f80d2000          STRB     r2,[sp,r0]
;;;149    	buf[_ucLen++] = crc;
000028  b2f2              UXTB     r2,r6
00002a  4620              MOV      r0,r4
00002c  1c61              ADDS     r1,r4,#1
00002e  b2cc              UXTB     r4,r1
000030  f80d2000          STRB     r2,[sp,r0]
;;;150    
;;;151    	RS485_SendBuf(buf, _ucLen);
000034  4621              MOV      r1,r4
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       RS485_SendBuf
;;;152    	
;;;153    #if 1									/* 此部分为了串口打印结果,实际运用中可不要 */
;;;154    	g_tPrint.Txlen = _ucLen;
00003c  4804              LDR      r0,|L15.80|
00003e  f8804041          STRB     r4,[r0,#0x41]
;;;155    	memcpy(g_tPrint.TxBuf, buf, _ucLen);
000042  4622              MOV      r2,r4
000044  4669              MOV      r1,sp
000046  3042              ADDS     r0,r0,#0x42
000048  f7fffffe          BL       __aeabi_memcpy
;;;156    #endif
;;;157    }
00004c  b020              ADD      sp,sp,#0x80
00004e  bd70              POP      {r4-r6,pc}
;;;158    
                          ENDP

                  |L15.80|
                          DCD      g_tPrint

                          AREA ||i.MODS_WriteRegValue||, CODE, READONLY, ALIGN=2

                  MODS_WriteRegValue PROC
;;;573    */
;;;574    static uint8_t MODS_WriteRegValue(uint16_t reg_addr, uint16_t reg_value)
000000  4602              MOV      r2,r0
;;;575    {
;;;576    	switch (reg_addr)							/* 判断寄存器地址 */
000002  2a1e              CMP      r2,#0x1e
000004  d26a              BCS      |L16.220|
000006  e8dff002          TBB      [pc,r2]
00000a  0f12              DCB      0x0f,0x12
00000c  15181b1e          DCB      0x15,0x18,0x1b,0x1e
000010  2124272a          DCB      0x21,0x24,0x27,0x2a
000014  2d303336          DCB      0x2d,0x30,0x33,0x36
000018  393c3f42          DCB      0x39,0x3c,0x3f,0x42
00001c  45484b4e          DCB      0x45,0x48,0x4b,0x4e
000020  5154575a          DCB      0x51,0x54,0x57,0x5a
000024  5d606366          DCB      0x5d,0x60,0x63,0x66
;;;577    	{	
;;;578    		case SLAVE_REG_P01:
;;;579    			g_tVar.P01 = reg_value;				/* 将值写入保存寄存器 */
000028  482f              LDR      r0,|L16.232|
00002a  8001              STRH     r1,[r0,#0]
;;;580    			break;
00002c  e058              B        |L16.224|
;;;581    		
;;;582    		case SLAVE_REG_P02:
;;;583    			g_tVar.P02 = reg_value;				/* 将值写入保存寄存器 */
00002e  482e              LDR      r0,|L16.232|
000030  8041              STRH     r1,[r0,#2]
;;;584    			break;
000032  e055              B        |L16.224|
;;;585            case SLAVE_REG_P03:
;;;586    			g_tVar.P03 = reg_value;				/* 将值写入保存寄存器 */
000034  482c              LDR      r0,|L16.232|
000036  8081              STRH     r1,[r0,#4]
;;;587    			break;
000038  e052              B        |L16.224|
;;;588    		
;;;589    		case SLAVE_REG_P04:
;;;590    			g_tVar.P04 = reg_value;				/* 将值写入保存寄存器 */
00003a  482b              LDR      r0,|L16.232|
00003c  80c1              STRH     r1,[r0,#6]
;;;591    			break;
00003e  e04f              B        |L16.224|
;;;592            case SLAVE_REG_P05:
;;;593    			g_tVar.P05 = reg_value;				/* 将值写入保存寄存器 */
000040  4829              LDR      r0,|L16.232|
000042  8101              STRH     r1,[r0,#8]
;;;594    			break;
000044  e04c              B        |L16.224|
;;;595    		
;;;596    		case SLAVE_REG_P06:
;;;597    			g_tVar.P06 = reg_value;				/* 将值写入保存寄存器 */
000046  4828              LDR      r0,|L16.232|
000048  8141              STRH     r1,[r0,#0xa]
;;;598    			break;
00004a  e049              B        |L16.224|
;;;599            case SLAVE_REG_P07:
;;;600    			g_tVar.P07 = reg_value;				/* 将值写入保存寄存器 */
00004c  4826              LDR      r0,|L16.232|
00004e  8181              STRH     r1,[r0,#0xc]
;;;601    			break;
000050  e046              B        |L16.224|
;;;602    		
;;;603    		case SLAVE_REG_P08:
;;;604    			g_tVar.P08 = reg_value;				/* 将值写入保存寄存器 */
000052  4825              LDR      r0,|L16.232|
000054  81c1              STRH     r1,[r0,#0xe]
;;;605    			break;
000056  e043              B        |L16.224|
;;;606            case SLAVE_REG_P09:
;;;607    			g_tVar.P09 = reg_value;				/* 将值写入保存寄存器 */
000058  4823              LDR      r0,|L16.232|
00005a  8201              STRH     r1,[r0,#0x10]
;;;608    			break;
00005c  e040              B        |L16.224|
;;;609            case SLAVE_REG_P10:
;;;610    			g_tVar.P10 = reg_value;				/* 将值写入保存寄存器 */
00005e  4822              LDR      r0,|L16.232|
000060  8241              STRH     r1,[r0,#0x12]
;;;611    			break;
000062  e03d              B        |L16.224|
;;;612            case SLAVE_REG_P11:
;;;613    			g_tVar.P11 = reg_value;				/* 将值写入保存寄存器 */
000064  4820              LDR      r0,|L16.232|
000066  8281              STRH     r1,[r0,#0x14]
;;;614    			break;
000068  e03a              B        |L16.224|
;;;615            case SLAVE_REG_P12:
;;;616    			g_tVar.P12 = reg_value;				/* 将值写入保存寄存器 */
00006a  481f              LDR      r0,|L16.232|
00006c  82c1              STRH     r1,[r0,#0x16]
;;;617    			break;
00006e  e037              B        |L16.224|
;;;618            case SLAVE_REG_P13:
;;;619    			g_tVar.P13 = reg_value;				/* 将值写入保存寄存器 */
000070  481d              LDR      r0,|L16.232|
000072  8301              STRH     r1,[r0,#0x18]
;;;620    			break;
000074  e034              B        |L16.224|
;;;621            case SLAVE_REG_P14:
;;;622    			g_tVar.P14 = reg_value;				/* 将值写入保存寄存器 */
000076  481c              LDR      r0,|L16.232|
000078  8341              STRH     r1,[r0,#0x1a]
;;;623    			break;
00007a  e031              B        |L16.224|
;;;624            case SLAVE_REG_P15:
;;;625    			g_tVar.P15 = reg_value;				/* 将值写入保存寄存器 */
00007c  481a              LDR      r0,|L16.232|
00007e  8381              STRH     r1,[r0,#0x1c]
;;;626    			break;
000080  e02e              B        |L16.224|
;;;627            case SLAVE_REG_P16:
;;;628    			g_tVar.P16 = reg_value;				/* 将值写入保存寄存器 */
000082  4819              LDR      r0,|L16.232|
000084  83c1              STRH     r1,[r0,#0x1e]
;;;629    			break;
000086  e02b              B        |L16.224|
;;;630            case SLAVE_REG_P17:
;;;631    			g_tVar.P17 = reg_value;				/* 将值写入保存寄存器 */
000088  4817              LDR      r0,|L16.232|
00008a  8401              STRH     r1,[r0,#0x20]
;;;632    			break;
00008c  e028              B        |L16.224|
;;;633            case SLAVE_REG_P18:
;;;634    			g_tVar.P18 = reg_value;				/* 将值写入保存寄存器 */
00008e  4816              LDR      r0,|L16.232|
000090  8441              STRH     r1,[r0,#0x22]
;;;635    			break;
000092  e025              B        |L16.224|
;;;636            case SLAVE_REG_P19:
;;;637    			g_tVar.P19 = reg_value;				/* 将值写入保存寄存器 */
000094  4814              LDR      r0,|L16.232|
000096  8481              STRH     r1,[r0,#0x24]
;;;638    			break;
000098  e022              B        |L16.224|
;;;639            case SLAVE_REG_P20:
;;;640    			g_tVar.P20 = reg_value;				/* 将值写入保存寄存器 */
00009a  4813              LDR      r0,|L16.232|
00009c  84c1              STRH     r1,[r0,#0x26]
;;;641    			break;
00009e  e01f              B        |L16.224|
;;;642            case SLAVE_REG_P21:
;;;643    			g_tVar.P21 = reg_value;				/* 将值写入保存寄存器 */
0000a0  4811              LDR      r0,|L16.232|
0000a2  8501              STRH     r1,[r0,#0x28]
;;;644    			break;
0000a4  e01c              B        |L16.224|
;;;645            case SLAVE_REG_P22:
;;;646    			g_tVar.P22 = reg_value;				/* 将值写入保存寄存器 */
0000a6  4810              LDR      r0,|L16.232|
0000a8  8541              STRH     r1,[r0,#0x2a]
;;;647    			break;
0000aa  e019              B        |L16.224|
;;;648            case SLAVE_REG_P23:
;;;649    			g_tVar.P23 = reg_value;				/* 将值写入保存寄存器 */
0000ac  480e              LDR      r0,|L16.232|
0000ae  8581              STRH     r1,[r0,#0x2c]
;;;650    			break;
0000b0  e016              B        |L16.224|
;;;651            case SLAVE_REG_P24:
;;;652    			g_tVar.P24 = reg_value;				/* 将值写入保存寄存器 */
0000b2  480d              LDR      r0,|L16.232|
0000b4  85c1              STRH     r1,[r0,#0x2e]
;;;653    			break;
0000b6  e013              B        |L16.224|
;;;654            case SLAVE_REG_P25:
;;;655    			g_tVar.P25 = reg_value;				/* 将值写入保存寄存器 */
0000b8  480b              LDR      r0,|L16.232|
0000ba  8601              STRH     r1,[r0,#0x30]
;;;656    			break;
0000bc  e010              B        |L16.224|
;;;657            case SLAVE_REG_P26:
;;;658    			g_tVar.P26 = reg_value;				/* 将值写入保存寄存器 */
0000be  480a              LDR      r0,|L16.232|
0000c0  8641              STRH     r1,[r0,#0x32]
;;;659    			break;
0000c2  e00d              B        |L16.224|
;;;660            case SLAVE_REG_P27:
;;;661    			g_tVar.P27 = reg_value;				/* 将值写入保存寄存器 */
0000c4  4808              LDR      r0,|L16.232|
0000c6  8681              STRH     r1,[r0,#0x34]
;;;662    			break;
0000c8  e00a              B        |L16.224|
;;;663            case SLAVE_REG_P28:
;;;664    			g_tVar.P28 = reg_value;				/* 将值写入保存寄存器 */
0000ca  4807              LDR      r0,|L16.232|
0000cc  86c1              STRH     r1,[r0,#0x36]
;;;665    			break;
0000ce  e007              B        |L16.224|
;;;666            case SLAVE_REG_P29:
;;;667    			g_tVar.P29 = reg_value;				/* 将值写入保存寄存器 */
0000d0  4805              LDR      r0,|L16.232|
0000d2  8701              STRH     r1,[r0,#0x38]
;;;668    			break;
0000d4  e004              B        |L16.224|
;;;669            case SLAVE_REG_P30:
;;;670    			g_tVar.P30 = reg_value;				/* 将值写入保存寄存器 */
0000d6  4804              LDR      r0,|L16.232|
0000d8  8741              STRH     r1,[r0,#0x3a]
;;;671    			break;
0000da  e001              B        |L16.224|
                  |L16.220|
;;;672            
;;;673    		
;;;674    		default:
;;;675    			return 0;		/* 参数异常，返回 0 */
0000dc  2000              MOVS     r0,#0
                  |L16.222|
;;;676    	}
;;;677    
;;;678    	return 1;		/* 读取成功 */
;;;679    }
0000de  4770              BX       lr
                  |L16.224|
0000e0  bf00              NOP                            ;580
0000e2  2001              MOVS     r0,#1                 ;678
0000e4  e7fb              B        |L16.222|
;;;680    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L16.232|
                          DCD      g_tVar

                          AREA ||i.setDefaultvalue||, CODE, READONLY, ALIGN=2

                  setDefaultvalue PROC
;;;1157   
;;;1158   void setDefaultvalue(void)
000000  2003              MOVS     r0,#3
;;;1159   {
;;;1160       g_tVar.P01 = SLAVEADDRESS;
000002  4901              LDR      r1,|L17.8|
000004  8008              STRH     r0,[r1,#0]
;;;1161   }
000006  4770              BX       lr
;;;1162   
                          ENDP

                  |L17.8|
                          DCD      g_tVar

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_tModS
                          %        198
                  g_tVar
                          %        72

                          AREA ||.data||, DATA, ALIGN=0

                  g_mods_timeout
000000  00                DCB      0x00
                  SADDR485
000001  03                DCB      0x03

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\modbus_slave.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_modbus_slave_c_SADDR485____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_modbus_slave_c_SADDR485____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_modbus_slave_c_SADDR485____REVSH|
#line 128
|__asm___14_modbus_slave_c_SADDR485____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
