; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_user_lib.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_user_lib.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\User -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User\app\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_user_lib.crf ..\..\User\bsp\src\bsp_user_lib.c]
                          THUMB

                          AREA ||i.AsciiToUint32||, CODE, READONLY, ALIGN=1

                  AsciiToUint32 PROC
;;;418    */
;;;419    uint32_t AsciiToUint32(char *pAscii)
000000  b5f0              PUSH     {r4-r7,lr}
;;;420    {
000002  4604              MOV      r4,r0
;;;421    	char i;
;;;422    	char bTemp;
;;;423    	char bIsHex;
;;;424    	char bLen;
;;;425    	char bZeroLen;
;;;426    	uint32_t lResult;
;;;427    	uint32_t lBitValue;
;;;428    
;;;429    	/* 判断是否是16进制数 */
;;;430    	bIsHex = 0;
000004  2700              MOVS     r7,#0
;;;431    	if ((pAscii[0] == '0') && ((pAscii[1] == 'x') || (pAscii[1] == 'X')))
000006  f894c000          LDRB     r12,[r4,#0]
00000a  f1bc0f30          CMP      r12,#0x30
00000e  d10a              BNE      |L1.38|
000010  f894c001          LDRB     r12,[r4,#1]
000014  f1bc0f78          CMP      r12,#0x78
000018  d004              BEQ      |L1.36|
00001a  f894c001          LDRB     r12,[r4,#1]
00001e  f1bc0f58          CMP      r12,#0x58
000022  d100              BNE      |L1.38|
                  |L1.36|
;;;432    	{
;;;433    		bIsHex=1;
000024  2701              MOVS     r7,#1
                  |L1.38|
;;;434    	}
;;;435    
;;;436    	lResult=0;
000026  2000              MOVS     r0,#0
;;;437    	// 最大数值为 4294967295, 10位+2字符"0x" //
;;;438    	if (bIsHex == 0)
000028  2f00              CMP      r7,#0
00002a  d140              BNE      |L1.174|
;;;439    	{ // 十进制 //
;;;440    		// 求长度 //
;;;441    		lBitValue=1;
00002c  2301              MOVS     r3,#1
;;;442    
;;;443    		/* 前导去0 */
;;;444    		for (i = 0; i < 8; i++)
00002e  2100              MOVS     r1,#0
000030  e007              B        |L1.66|
                  |L1.50|
;;;445    		{
;;;446    			bTemp = pAscii[i];
000032  5c62              LDRB     r2,[r4,r1]
;;;447    			if (bTemp != '0')
000034  2a30              CMP      r2,#0x30
000036  d000              BEQ      |L1.58|
;;;448    				break;
000038  e005              B        |L1.70|
                  |L1.58|
00003a  f1010c01          ADD      r12,r1,#1             ;444
00003e  f00c01ff          AND      r1,r12,#0xff          ;444
                  |L1.66|
000042  2908              CMP      r1,#8                 ;444
000044  dbf5              BLT      |L1.50|
                  |L1.70|
000046  bf00              NOP      
;;;449    		}
;;;450    		bZeroLen = i;
000048  460e              MOV      r6,r1
;;;451    
;;;452    		for (i = 0; i < 10; i++)
00004a  2100              MOVS     r1,#0
00004c  e012              B        |L1.116|
                  |L1.78|
;;;453    		{
;;;454    			if ((pAscii[i] < '0') || (pAscii[i] > '9'))
00004e  f814c001          LDRB     r12,[r4,r1]
000052  f1bc0f30          CMP      r12,#0x30
000056  db04              BLT      |L1.98|
000058  f814c001          LDRB     r12,[r4,r1]
00005c  f1bc0f39          CMP      r12,#0x39
000060  dd00              BLE      |L1.100|
                  |L1.98|
;;;455    				break;
000062  e009              B        |L1.120|
                  |L1.100|
;;;456    			lBitValue = lBitValue * 10;
000064  eb030c83          ADD      r12,r3,r3,LSL #2
000068  ea4f034c          LSL      r3,r12,#1
00006c  f1010c01          ADD      r12,r1,#1             ;452
000070  f00c01ff          AND      r1,r12,#0xff          ;452
                  |L1.116|
000074  290a              CMP      r1,#0xa               ;452
000076  dbea              BLT      |L1.78|
                  |L1.120|
000078  bf00              NOP                            ;455
;;;457    		}
;;;458    		bLen = i;
00007a  460d              MOV      r5,r1
;;;459    		lBitValue = lBitValue / 10;
00007c  f04f0c0a          MOV      r12,#0xa
000080  fbb3f3fc          UDIV     r3,r3,r12
;;;460    		if (lBitValue == 0)
000084  b903              CBNZ     r3,|L1.136|
;;;461    			lBitValue=1;
000086  2301              MOVS     r3,#1
                  |L1.136|
;;;462    		for (i = bZeroLen; i < bLen; i++)
000088  4631              MOV      r1,r6
00008a  e00d              B        |L1.168|
                  |L1.140|
;;;463    		{
;;;464    			lResult += (pAscii[i] - '0') * lBitValue;
00008c  f814c001          LDRB     r12,[r4,r1]
000090  f1ac0c30          SUB      r12,r12,#0x30
000094  fb0c0003          MLA      r0,r12,r3,r0
;;;465    			lBitValue /= 10;
000098  f04f0c0a          MOV      r12,#0xa
00009c  fbb3f3fc          UDIV     r3,r3,r12
0000a0  f1010c01          ADD      r12,r1,#1             ;462
0000a4  f00c01ff          AND      r1,r12,#0xff          ;462
                  |L1.168|
0000a8  42a9              CMP      r1,r5                 ;462
0000aa  dbef              BLT      |L1.140|
0000ac  e059              B        |L1.354|
                  |L1.174|
;;;466    		}
;;;467    	}
;;;468    	else
;;;469    	{	/* 16进制 */
;;;470    		/* 求长度 */
;;;471    		lBitValue=1;
0000ae  2301              MOVS     r3,#1
;;;472    
;;;473    		/* 前导去0 */
;;;474    		for (i = 0; i < 8; i++)
0000b0  2100              MOVS     r1,#0
0000b2  e00a              B        |L1.202|
                  |L1.180|
;;;475    		{
;;;476    			bTemp = pAscii[i + 2];
0000b4  f1010c02          ADD      r12,r1,#2
0000b8  f814200c          LDRB     r2,[r4,r12]
;;;477    			if(bTemp!='0')
0000bc  2a30              CMP      r2,#0x30
0000be  d000              BEQ      |L1.194|
;;;478    				break;
0000c0  e005              B        |L1.206|
                  |L1.194|
0000c2  f1010c01          ADD      r12,r1,#1             ;474
0000c6  f00c01ff          AND      r1,r12,#0xff          ;474
                  |L1.202|
0000ca  2908              CMP      r1,#8                 ;474
0000cc  dbf2              BLT      |L1.180|
                  |L1.206|
0000ce  bf00              NOP      
;;;479    		}
;;;480    		bZeroLen = i;
0000d0  460e              MOV      r6,r1
;;;481    		for (; i < 8; i++)
0000d2  e016              B        |L1.258|
                  |L1.212|
;;;482    		{
;;;483    			bTemp=pAscii[i+2];
0000d4  f1010c02          ADD      r12,r1,#2
0000d8  f814200c          LDRB     r2,[r4,r12]
;;;484    			if (((bTemp >= 'A') && (bTemp <= 'F')) ||
0000dc  2a41              CMP      r2,#0x41
0000de  db01              BLT      |L1.228|
0000e0  2a46              CMP      r2,#0x46
0000e2  dd07              BLE      |L1.244|
                  |L1.228|
;;;485    				((bTemp>='a')&&(bTemp<='f')) ||
0000e4  2a61              CMP      r2,#0x61
0000e6  db01              BLT      |L1.236|
0000e8  2a66              CMP      r2,#0x66
0000ea  dd03              BLE      |L1.244|
                  |L1.236|
;;;486    				((bTemp>='0')&&(bTemp<='9')) )
0000ec  2a30              CMP      r2,#0x30
0000ee  db03              BLT      |L1.248|
0000f0  2a39              CMP      r2,#0x39
0000f2  dc01              BGT      |L1.248|
                  |L1.244|
;;;487    			{
;;;488    				lBitValue=lBitValue * 16;
0000f4  011b              LSLS     r3,r3,#4
0000f6  e000              B        |L1.250|
                  |L1.248|
;;;489    			}
;;;490    			else
;;;491    			{
;;;492    				break;
0000f8  e005              B        |L1.262|
                  |L1.250|
0000fa  f1010c01          ADD      r12,r1,#1             ;481
0000fe  f00c01ff          AND      r1,r12,#0xff          ;481
                  |L1.258|
000102  2908              CMP      r1,#8                 ;481
000104  dbe6              BLT      |L1.212|
                  |L1.262|
000106  bf00              NOP      
;;;493    			}
;;;494    		}
;;;495    		lBitValue = lBitValue / 16;
000108  091b              LSRS     r3,r3,#4
;;;496    		if (lBitValue == 0)
00010a  b903              CBNZ     r3,|L1.270|
;;;497    			lBitValue = 1;
00010c  2301              MOVS     r3,#1
                  |L1.270|
;;;498    		bLen = i;
00010e  460d              MOV      r5,r1
;;;499    		for (i = bZeroLen; i < bLen; i++)
000110  4631              MOV      r1,r6
000112  e024              B        |L1.350|
                  |L1.276|
;;;500    		{
;;;501    			bTemp = pAscii[i + 2];
000114  f1010c02          ADD      r12,r1,#2
000118  f814200c          LDRB     r2,[r4,r12]
;;;502    			if ((bTemp >= 'A') && (bTemp <= 'F'))
00011c  2a41              CMP      r2,#0x41
00011e  db06              BLT      |L1.302|
000120  2a46              CMP      r2,#0x46
000122  dc04              BGT      |L1.302|
;;;503    			{
;;;504    				bTemp -= 0x37;
000124  f1a20c37          SUB      r12,r2,#0x37
000128  f00c02ff          AND      r2,r12,#0xff
00012c  e010              B        |L1.336|
                  |L1.302|
;;;505    			}
;;;506    			else if ((bTemp >= 'a') && (bTemp <= 'f'))
00012e  2a61              CMP      r2,#0x61
000130  db06              BLT      |L1.320|
000132  2a66              CMP      r2,#0x66
000134  dc04              BGT      |L1.320|
;;;507    			{
;;;508    				bTemp -= 0x57;
000136  f1a20c57          SUB      r12,r2,#0x57
00013a  f00c02ff          AND      r2,r12,#0xff
00013e  e007              B        |L1.336|
                  |L1.320|
;;;509    			}
;;;510    			else if ((bTemp >= '0') && (bTemp <= '9'))
000140  2a30              CMP      r2,#0x30
000142  db05              BLT      |L1.336|
000144  2a39              CMP      r2,#0x39
000146  dc03              BGT      |L1.336|
;;;511    			{
;;;512    				bTemp -= '0';
000148  f1a20c30          SUB      r12,r2,#0x30
00014c  f00c02ff          AND      r2,r12,#0xff
                  |L1.336|
;;;513    			}
;;;514    			lResult += bTemp*lBitValue;
000150  fb020003          MLA      r0,r2,r3,r0
;;;515    			lBitValue /= 16;
000154  091b              LSRS     r3,r3,#4
000156  f1010c01          ADD      r12,r1,#1             ;499
00015a  f00c01ff          AND      r1,r12,#0xff          ;499
                  |L1.350|
00015e  42a9              CMP      r1,r5                 ;499
000160  dbd8              BLT      |L1.276|
                  |L1.354|
;;;516    		}
;;;517    	}
;;;518    	return lResult;
;;;519    }
000162  bdf0              POP      {r4-r7,pc}
;;;520    
                          ENDP


                          AREA ||i.BEBufToUint16||, CODE, READONLY, ALIGN=1

                  BEBufToUint16 PROC
;;;263    */
;;;264    uint16_t BEBufToUint16(uint8_t *_pBuf)
000000  4601              MOV      r1,r0
;;;265    {
;;;266        return (((uint16_t)_pBuf[0] << 8) | _pBuf[1]);
000002  7848              LDRB     r0,[r1,#1]
000004  780a              LDRB     r2,[r1,#0]
000006  ea402002          ORR      r0,r0,r2,LSL #8
;;;267    }
00000a  4770              BX       lr
;;;268    
                          ENDP


                          AREA ||i.BEBufToUint32||, CODE, READONLY, ALIGN=1

                  BEBufToUint32 PROC
;;;292    */
;;;293    uint32_t BEBufToUint32(uint8_t *_pBuf)
000000  4601              MOV      r1,r0
;;;294    {
;;;295        return (((uint32_t)_pBuf[0] << 24) | ((uint32_t)_pBuf[1] << 16) | ((uint32_t)_pBuf[2] << 8) | _pBuf[3]);
000002  7808              LDRB     r0,[r1,#0]
000004  0600              LSLS     r0,r0,#24
000006  784a              LDRB     r2,[r1,#1]
000008  ea404002          ORR      r0,r0,r2,LSL #16
00000c  788a              LDRB     r2,[r1,#2]
00000e  ea402002          ORR      r0,r0,r2,LSL #8
000012  78ca              LDRB     r2,[r1,#3]
000014  4310              ORRS     r0,r0,r2
;;;296    }
000016  4770              BX       lr
;;;297    
                          ENDP


                          AREA ||i.BcdToChar||, CODE, READONLY, ALIGN=1

                  BcdToChar PROC
;;;364    */
;;;365    char BcdToChar(uint8_t _bcd)
000000  4601              MOV      r1,r0
;;;366    {
;;;367    	if (_bcd < 10)
000002  290a              CMP      r1,#0xa
000004  da03              BGE      |L4.14|
;;;368    	{
;;;369    		return _bcd + '0';
000006  f1010030          ADD      r0,r1,#0x30
00000a  b2c0              UXTB     r0,r0
                  |L4.12|
;;;370    	}
;;;371    	else if (_bcd < 16)
;;;372    	{
;;;373    		return _bcd + 'A';
;;;374    	}
;;;375    	else
;;;376    	{
;;;377    		return 0;
;;;378    	}
;;;379    }
00000c  4770              BX       lr
                  |L4.14|
00000e  2910              CMP      r1,#0x10              ;371
000010  da03              BGE      |L4.26|
000012  f1010041          ADD      r0,r1,#0x41           ;373
000016  b2c0              UXTB     r0,r0                 ;373
000018  e7f8              B        |L4.12|
                  |L4.26|
00001a  2000              MOVS     r0,#0                 ;377
00001c  e7f6              B        |L4.12|
;;;380    
                          ENDP


                          AREA ||i.CRC16_Modbus||, CODE, READONLY, ALIGN=2

                  CRC16_Modbus PROC
;;;326    */
;;;327    uint16_t CRC16_Modbus(uint8_t *_pBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;328    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;329    	uint8_t ucCRCHi = 0xFF; /* 高CRC字节初始化 */
000006  25ff              MOVS     r5,#0xff
;;;330    	uint8_t ucCRCLo = 0xFF; /* 低CRC 字节初始化 */
000008  23ff              MOVS     r3,#0xff
;;;331    	uint16_t usIndex;  /* CRC循环中的索引 */
;;;332    
;;;333        while (_usLen--)
00000a  e009              B        |L5.32|
                  |L5.12|
;;;334        {
;;;335    		usIndex = ucCRCHi ^ *_pBuf++; /* 计算CRC */
00000c  f8120b01          LDRB     r0,[r2],#1
000010  ea800105          EOR      r1,r0,r5
;;;336    		ucCRCHi = ucCRCLo ^ s_CRCHi[usIndex];
000014  4806              LDR      r0,|L5.48|
000016  5c40              LDRB     r0,[r0,r1]
000018  ea800503          EOR      r5,r0,r3
;;;337    		ucCRCLo = s_CRCLo[usIndex];
00001c  4805              LDR      r0,|L5.52|
00001e  5c43              LDRB     r3,[r0,r1]
                  |L5.32|
000020  1e20              SUBS     r0,r4,#0              ;333
000022  f1a40601          SUB      r6,r4,#1              ;333
000026  b2b4              UXTH     r4,r6                 ;333
000028  d1f0              BNE      |L5.12|
;;;338        }
;;;339        return ((uint16_t)ucCRCHi << 8 | ucCRCLo);
00002a  ea432005          ORR      r0,r3,r5,LSL #8
;;;340    }
00002e  bd70              POP      {r4-r6,pc}
;;;341    
                          ENDP

                  |L5.48|
                          DCD      s_CRCHi
                  |L5.52|
                          DCD      s_CRCLo

                          AREA ||i.CaculTwoPoint||, CODE, READONLY, ALIGN=1

                  CaculTwoPoint PROC
;;;350    */
;;;351    int32_t  CaculTwoPoint(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t x)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;352    {
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
000008  4692              MOV      r10,r2
00000a  469b              MOV      r11,r3
;;;353    	return y1 + ((int64_t)(y2 - y1) * (x - x1)) / (x2 - x1);
00000c  ebab0104          SUB      r1,r11,r4
000010  980a              LDR      r0,[sp,#0x28]
000012  eba00009          SUB      r0,r0,r9
000016  fb817000          SMULL    r7,r0,r1,r0
00001a  4601              MOV      r1,r0
00001c  ebaa0009          SUB      r0,r10,r9
000020  17c3              ASRS     r3,r0,#31
000022  4605              MOV      r5,r0
000024  462a              MOV      r2,r5
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       __aeabi_ldivmod
00002c  1900              ADDS     r0,r0,r4
;;;354    }
00002e  e8bd9ff0          POP      {r4-r12,pc}
;;;355    
                          ENDP


                          AREA ||i.HexToAscll||, CODE, READONLY, ALIGN=1

                  HexToAscll PROC
;;;390    */
;;;391    void HexToAscll(uint8_t * _pHex, char *_pAscii, uint16_t _BinBytes)
000000  b530              PUSH     {r4,r5,lr}
;;;392    {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
000006  4615              MOV      r5,r2
;;;393    	uint16_t i;
;;;394    	
;;;395    	if (_BinBytes == 0)
000008  b915              CBNZ     r5,|L7.16|
;;;396    	{
;;;397    		_pAscii[0] = 0;
00000a  2000              MOVS     r0,#0
00000c  7018              STRB     r0,[r3,#0]
00000e  e021              B        |L7.84|
                  |L7.16|
;;;398    	}
;;;399    	else
;;;400    	{
;;;401    		for (i = 0; i < _BinBytes; i++)
000010  2200              MOVS     r2,#0
000012  e017              B        |L7.68|
                  |L7.20|
;;;402    		{
;;;403    			_pAscii[3 * i] = BcdToChar(_pHex[i] >> 4);
000014  5ca1              LDRB     r1,[r4,r2]
000016  1108              ASRS     r0,r1,#4
000018  f7fffffe          BL       BcdToChar
00001c  eb020142          ADD      r1,r2,r2,LSL #1
000020  5458              STRB     r0,[r3,r1]
;;;404    			_pAscii[3 * i + 1] = BcdToChar(_pHex[i] & 0x0F);
000022  5ca1              LDRB     r1,[r4,r2]
000024  f001000f          AND      r0,r1,#0xf
000028  f7fffffe          BL       BcdToChar
00002c  4601              MOV      r1,r0
00002e  eb020042          ADD      r0,r2,r2,LSL #1
000032  1c40              ADDS     r0,r0,#1
000034  5419              STRB     r1,[r3,r0]
;;;405    			_pAscii[3 * i + 2] = ' ';
000036  2120              MOVS     r1,#0x20
000038  eb020042          ADD      r0,r2,r2,LSL #1
00003c  1c80              ADDS     r0,r0,#2
00003e  5419              STRB     r1,[r3,r0]
000040  1c50              ADDS     r0,r2,#1              ;401
000042  b282              UXTH     r2,r0                 ;401
                  |L7.68|
000044  42aa              CMP      r2,r5                 ;401
000046  dbe5              BLT      |L7.20|
;;;406    		}
;;;407    		_pAscii[3 * (i - 1) + 2] = 0;
000048  2100              MOVS     r1,#0
00004a  1e50              SUBS     r0,r2,#1
00004c  eb000040          ADD      r0,r0,r0,LSL #1
000050  1c80              ADDS     r0,r0,#2
000052  5419              STRB     r1,[r3,r0]
                  |L7.84|
;;;408    	}
;;;409    }
000054  bd30              POP      {r4,r5,pc}
;;;410    
                          ENDP


                          AREA ||i.LEBufToUint16||, CODE, READONLY, ALIGN=1

                  LEBufToUint16 PROC
;;;276    */
;;;277    uint16_t LEBufToUint16(uint8_t *_pBuf)
000000  4601              MOV      r1,r0
;;;278    {
;;;279        return (((uint16_t)_pBuf[1] << 8) | _pBuf[0]);
000002  7808              LDRB     r0,[r1,#0]
000004  784a              LDRB     r2,[r1,#1]
000006  ea402002          ORR      r0,r0,r2,LSL #8
;;;280    }
00000a  4770              BX       lr
;;;281    
                          ENDP


                          AREA ||i.LEBufToUint32||, CODE, READONLY, ALIGN=1

                  LEBufToUint32 PROC
;;;305    */
;;;306    uint32_t LEBufToUint32(uint8_t *_pBuf)
000000  4601              MOV      r1,r0
;;;307    {
;;;308        return (((uint32_t)_pBuf[3] << 24) | ((uint32_t)_pBuf[2] << 16) | ((uint32_t)_pBuf[1] << 8) | _pBuf[0]);
000002  78c8              LDRB     r0,[r1,#3]
000004  0600              LSLS     r0,r0,#24
000006  788a              LDRB     r2,[r1,#2]
000008  ea404002          ORR      r0,r0,r2,LSL #16
00000c  784a              LDRB     r2,[r1,#1]
00000e  ea402002          ORR      r0,r0,r2,LSL #8
000012  780a              LDRB     r2,[r1,#0]
000014  4310              ORRS     r0,r0,r2
;;;309    }
000016  4770              BX       lr
;;;310    
                          ENDP


                          AREA ||i.int_to_str||, CODE, READONLY, ALIGN=1

                  int_to_str PROC
;;;158    */
;;;159    void int_to_str(int _iNumber, char *_pBuf, unsigned char _len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;160    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;161    	unsigned char i;
;;;162    	int iTemp;
;;;163    
;;;164    	if (_iNumber < 0)	/* 负数 */
00000a  2e00              CMP      r6,#0
00000c  da01              BGE      |L10.18|
;;;165    	{
;;;166    		iTemp = -_iNumber;	/* 转为正数 */
00000e  4277              RSBS     r7,r6,#0
000010  e000              B        |L10.20|
                  |L10.18|
;;;167    	}
;;;168    	else
;;;169    	{
;;;170    		iTemp = _iNumber;
000012  4637              MOV      r7,r6
                  |L10.20|
;;;171    	}
;;;172    
;;;173    	mem_set(_pBuf, ' ',_len);
000014  4642              MOV      r2,r8
000016  2120              MOVS     r1,#0x20
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       mem_set
;;;174    
;;;175    	/* 将整数转换为ASCII字符串 */
;;;176    	for (i = 0; i < _len; i++)
00001e  2400              MOVS     r4,#0
000020  e011              B        |L10.70|
                  |L10.34|
;;;177    	{
;;;178    		_pBuf[_len - 1 - i] = (iTemp % 10) + '0';
000022  200a              MOVS     r0,#0xa
000024  fb97f1f0          SDIV     r1,r7,r0
000028  fb007011          MLS      r0,r0,r1,r7
00002c  3030              ADDS     r0,r0,#0x30
00002e  b2c1              UXTB     r1,r0
000030  f1a80001          SUB      r0,r8,#1
000034  1b00              SUBS     r0,r0,r4
000036  5429              STRB     r1,[r5,r0]
;;;179    		iTemp = iTemp / 10;
000038  200a              MOVS     r0,#0xa
00003a  fb97f7f0          SDIV     r7,r7,r0
;;;180    		if (iTemp == 0)
00003e  b907              CBNZ     r7,|L10.66|
;;;181    		{
;;;182    			break;
000040  e003              B        |L10.74|
                  |L10.66|
000042  1c60              ADDS     r0,r4,#1              ;176
000044  b2c4              UXTB     r4,r0                 ;176
                  |L10.70|
000046  4544              CMP      r4,r8                 ;176
000048  dbeb              BLT      |L10.34|
                  |L10.74|
00004a  bf00              NOP      
;;;183    		}
;;;184    	}
;;;185    	_pBuf[_len] = 0;
00004c  2000              MOVS     r0,#0
00004e  f8050008          STRB     r0,[r5,r8]
;;;186    
;;;187    	if (_iNumber < 0)	/* 负数 */
000052  2e00              CMP      r6,#0
000054  da10              BGE      |L10.120|
;;;188    	{
;;;189    		for (i = 0; i < _len; i++)
000056  2400              MOVS     r4,#0
000058  e00b              B        |L10.114|
                  |L10.90|
;;;190    		{
;;;191    			if ((_pBuf[i] == ' ') && (_pBuf[i + 1] != ' '))
00005a  5d28              LDRB     r0,[r5,r4]
00005c  2820              CMP      r0,#0x20
00005e  d106              BNE      |L10.110|
000060  1c60              ADDS     r0,r4,#1
000062  5c28              LDRB     r0,[r5,r0]
000064  2820              CMP      r0,#0x20
000066  d002              BEQ      |L10.110|
;;;192    			{
;;;193    				_pBuf[i] = '-';
000068  202d              MOVS     r0,#0x2d
00006a  5528              STRB     r0,[r5,r4]
;;;194    				break;
00006c  e003              B        |L10.118|
                  |L10.110|
00006e  1c60              ADDS     r0,r4,#1              ;189
000070  b2c4              UXTB     r4,r0                 ;189
                  |L10.114|
000072  4544              CMP      r4,r8                 ;189
000074  dbf1              BLT      |L10.90|
                  |L10.118|
000076  bf00              NOP      
                  |L10.120|
;;;195    			}
;;;196    		}
;;;197    	}
;;;198    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;199    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;140    */
;;;141    void mem_set(char *_tar, char _data, int _len)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143    	while (_len--)
000002  e001              B        |L11.8|
                  |L11.4|
;;;144    	{
;;;145    		*_tar++ = _data;
000004  f8001b01          STRB     r1,[r0],#1
                  |L11.8|
000008  1e13              SUBS     r3,r2,#0              ;143
00000a  f1a20201          SUB      r2,r2,#1              ;143
00000e  d1f9              BNE      |L11.4|
;;;146    	}
;;;147    }
000010  bd10              POP      {r4,pc}
;;;148    
                          ENDP


                          AREA ||i.str_cmp||, CODE, READONLY, ALIGN=1

                  str_cmp PROC
;;;121    */
;;;122    int str_cmp(char * s1, char * s2)
000000  4602              MOV      r2,r0
;;;123    {
;;;124    	while ((*s1!=0) && (*s2!=0) && (*s1==*s2))
000002  e001              B        |L12.8|
                  |L12.4|
;;;125    	{
;;;126    		s1++;
000004  1c52              ADDS     r2,r2,#1
;;;127    		s2++;
000006  1c49              ADDS     r1,r1,#1
                  |L12.8|
000008  7810              LDRB     r0,[r2,#0]            ;124
00000a  b128              CBZ      r0,|L12.24|
00000c  7808              LDRB     r0,[r1,#0]            ;124
00000e  b118              CBZ      r0,|L12.24|
000010  7810              LDRB     r0,[r2,#0]            ;124
000012  780b              LDRB     r3,[r1,#0]            ;124
000014  4298              CMP      r0,r3                 ;124
000016  d0f5              BEQ      |L12.4|
                  |L12.24|
;;;128    	}
;;;129    	return *s1 - *s2;
000018  7810              LDRB     r0,[r2,#0]
00001a  780b              LDRB     r3,[r1,#0]
00001c  1ac0              SUBS     r0,r0,r3
;;;130    }
00001e  4770              BX       lr
;;;131    
                          ENDP


                          AREA ||i.str_cpy||, CODE, READONLY, ALIGN=1

                  str_cpy PROC
;;;103    */
;;;104    void str_cpy(char *_tar, char *_src)
000000  bf00              NOP      
                  |L13.2|
;;;105    {
;;;106    	do
;;;107    	{
;;;108    		*_tar++ = *_src;
000002  780a              LDRB     r2,[r1,#0]
000004  f8002b01          STRB     r2,[r0],#1
;;;109    	}
;;;110    	while (*_src++);
000008  f8113b01          LDRB     r3,[r1],#1
00000c  2b00              CMP      r3,#0
00000e  d1f8              BNE      |L13.2|
;;;111    }
000010  4770              BX       lr
;;;112    
                          ENDP


                          AREA ||i.str_len||, CODE, READONLY, ALIGN=1

                  str_len PROC
;;;86     */
;;;87     int str_len(char *_str)
000000  4601              MOV      r1,r0
;;;88     {
;;;89     	int len = 0;
000002  2000              MOVS     r0,#0
;;;90     
;;;91     	while (*_str++) len++;
000004  e000              B        |L14.8|
                  |L14.6|
000006  1c40              ADDS     r0,r0,#1
                  |L14.8|
000008  f8113b01          LDRB     r3,[r1],#1
00000c  2b00              CMP      r3,#0
00000e  d1fa              BNE      |L14.6|
;;;92     	return len;
;;;93     }
000010  4770              BX       lr
;;;94     
                          ENDP


                          AREA ||i.str_to_int||, CODE, READONLY, ALIGN=1

                  str_to_int PROC
;;;207    */
;;;208    int str_to_int(char *_pStr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;209    {
000002  4604              MOV      r4,r0
;;;210    	unsigned char flag;
;;;211    	char *p;
;;;212    	int ulInt;
;;;213    	unsigned char  i;
;;;214    	unsigned char  ucTemp;
;;;215    
;;;216    	p = _pStr;
000004  4621              MOV      r1,r4
;;;217    	if (*p == '-')
000006  7808              LDRB     r0,[r1,#0]
000008  282d              CMP      r0,#0x2d
00000a  d102              BNE      |L15.18|
;;;218    	{
;;;219    		flag = 1;	/* 负数 */
00000c  2501              MOVS     r5,#1
;;;220    		p++;
00000e  1c49              ADDS     r1,r1,#1
000010  e000              B        |L15.20|
                  |L15.18|
;;;221    	}
;;;222    	else
;;;223    	{
;;;224    		flag = 0;
000012  2500              MOVS     r5,#0
                  |L15.20|
;;;225    	}
;;;226    
;;;227    	ulInt = 0;
000014  2200              MOVS     r2,#0
;;;228    	for (i = 0; i < 15; i++)
000016  2600              MOVS     r6,#0
000018  e013              B        |L15.66|
                  |L15.26|
;;;229    	{
;;;230    		ucTemp = *p;
00001a  780b              LDRB     r3,[r1,#0]
;;;231    		if (ucTemp == '.')	/* 遇到小数点，自动跳过1个字节 */
00001c  2b2e              CMP      r3,#0x2e
00001e  d101              BNE      |L15.36|
;;;232    		{
;;;233    			p++;
000020  1c49              ADDS     r1,r1,#1
;;;234    			ucTemp = *p;
000022  780b              LDRB     r3,[r1,#0]
                  |L15.36|
;;;235    		}
;;;236    		if ((ucTemp >= '0') && (ucTemp <= '9'))
000024  2b30              CMP      r3,#0x30
000026  db09              BLT      |L15.60|
000028  2b39              CMP      r3,#0x39
00002a  dc07              BGT      |L15.60|
;;;237    		{
;;;238    			ulInt = ulInt * 10 + (ucTemp - '0');
00002c  f1a30030          SUB      r0,r3,#0x30
000030  eb020782          ADD      r7,r2,r2,LSL #2
000034  eb000247          ADD      r2,r0,r7,LSL #1
;;;239    			p++;
000038  1c49              ADDS     r1,r1,#1
00003a  e000              B        |L15.62|
                  |L15.60|
;;;240    		}
;;;241    		else
;;;242    		{
;;;243    			break;
00003c  e003              B        |L15.70|
                  |L15.62|
00003e  1c70              ADDS     r0,r6,#1              ;228
000040  b2c6              UXTB     r6,r0                 ;228
                  |L15.66|
000042  2e0f              CMP      r6,#0xf               ;228
000044  dbe9              BLT      |L15.26|
                  |L15.70|
000046  bf00              NOP      
;;;244    		}
;;;245    	}
;;;246    
;;;247    	if (flag == 1)
000048  2d01              CMP      r5,#1
00004a  d101              BNE      |L15.80|
;;;248    	{
;;;249    		return -ulInt;
00004c  4250              RSBS     r0,r2,#0
                  |L15.78|
;;;250    	}
;;;251    	return ulInt;
;;;252    }
00004e  bdf0              POP      {r4-r7,pc}
                  |L15.80|
000050  4610              MOV      r0,r2                 ;251
000052  e7fc              B        |L15.78|
;;;253    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  s_CRCHi
000000  00c18140          DCB      0x00,0xc1,0x81,0x40
000004  01c08041          DCB      0x01,0xc0,0x80,0x41
000008  01c08041          DCB      0x01,0xc0,0x80,0x41
00000c  00c18140          DCB      0x00,0xc1,0x81,0x40
000010  01c08041          DCB      0x01,0xc0,0x80,0x41
000014  00c18140          DCB      0x00,0xc1,0x81,0x40
000018  00c18140          DCB      0x00,0xc1,0x81,0x40
00001c  01c08041          DCB      0x01,0xc0,0x80,0x41
000020  01c08041          DCB      0x01,0xc0,0x80,0x41
000024  00c18140          DCB      0x00,0xc1,0x81,0x40
000028  00c18140          DCB      0x00,0xc1,0x81,0x40
00002c  01c08041          DCB      0x01,0xc0,0x80,0x41
000030  00c18140          DCB      0x00,0xc1,0x81,0x40
000034  01c08041          DCB      0x01,0xc0,0x80,0x41
000038  01c08041          DCB      0x01,0xc0,0x80,0x41
00003c  00c18140          DCB      0x00,0xc1,0x81,0x40
000040  01c08041          DCB      0x01,0xc0,0x80,0x41
000044  00c18140          DCB      0x00,0xc1,0x81,0x40
000048  00c18140          DCB      0x00,0xc1,0x81,0x40
00004c  01c08041          DCB      0x01,0xc0,0x80,0x41
000050  00c18140          DCB      0x00,0xc1,0x81,0x40
000054  01c08041          DCB      0x01,0xc0,0x80,0x41
000058  01c08041          DCB      0x01,0xc0,0x80,0x41
00005c  00c18140          DCB      0x00,0xc1,0x81,0x40
000060  00c18140          DCB      0x00,0xc1,0x81,0x40
000064  01c08041          DCB      0x01,0xc0,0x80,0x41
000068  01c08041          DCB      0x01,0xc0,0x80,0x41
00006c  00c18140          DCB      0x00,0xc1,0x81,0x40
000070  01c08041          DCB      0x01,0xc0,0x80,0x41
000074  00c18140          DCB      0x00,0xc1,0x81,0x40
000078  00c18140          DCB      0x00,0xc1,0x81,0x40
00007c  01c08041          DCB      0x01,0xc0,0x80,0x41
000080  01c08041          DCB      0x01,0xc0,0x80,0x41
000084  00c18140          DCB      0x00,0xc1,0x81,0x40
000088  00c18140          DCB      0x00,0xc1,0x81,0x40
00008c  01c08041          DCB      0x01,0xc0,0x80,0x41
000090  00c18140          DCB      0x00,0xc1,0x81,0x40
000094  01c08041          DCB      0x01,0xc0,0x80,0x41
000098  01c08041          DCB      0x01,0xc0,0x80,0x41
00009c  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  s_CRCLo
000100  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000104  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000108  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00010c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000110  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000114  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000118  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00011c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000120  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000124  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000128  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00012c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000130  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000134  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000138  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00013c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000140  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000144  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000148  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00014c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000150  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000154  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000158  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00015c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000160  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000164  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000168  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00016c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000170  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000174  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000178  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00017c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000180  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000184  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000188  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00018c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000190  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000194  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000198  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00019c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0001a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0001a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0001a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0001ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0001b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0001b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0001b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0001bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0001c0  50909151          DCB      0x50,0x90,0x91,0x51
0001c4  93535292          DCB      0x93,0x53,0x52,0x92
0001c8  96565797          DCB      0x96,0x56,0x57,0x97
0001cc  55959454          DCB      0x55,0x95,0x94,0x54
0001d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0001d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0001d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0001dc  99595898          DCB      0x99,0x59,0x58,0x98
0001e0  88484989          DCB      0x88,0x48,0x49,0x89
0001e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0001e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0001ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0001f0  44848545          DCB      0x44,0x84,0x85,0x45
0001f4  87474686          DCB      0x87,0x47,0x46,0x86
0001f8  82424383          DCB      0x82,0x42,0x43,0x83
0001fc  41818040          DCB      0x41,0x81,0x80,0x40

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_user_lib.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_user_lib_c_s_CRCLo____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_bsp_user_lib_c_s_CRCLo____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_user_lib_c_s_CRCLo____REVSH|
#line 128
|__asm___14_bsp_user_lib_c_s_CRCLo____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
