; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_hc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_hc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\User -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User\app\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_hc.crf ..\..\User\bsp\src\bsp_hc.c]
                          THUMB

                          AREA ||i.HC_Analyze||, CODE, READONLY, ALIGN=2

                  HC_Analyze PROC
;;;54     }
;;;55     void HC_Analyze(void)
000000  b510              PUSH     {r4,lr}
;;;56     {
;;;57         if (g_hc_timeout == 0)	
000002  4839              LDR      r0,|L1.232|
000004  7800              LDRB     r0,[r0,#0]  ; g_hc_timeout
000006  b900              CBNZ     r0,|L1.10|
                  |L1.8|
;;;58     	{
;;;59     		return;								/* 没有超时，继续接收。不要清零 g_tHC.RxCount */
;;;60     	}
;;;61     	
;;;62     	g_hc_timeout = 0;	 					/* 清标志 */
;;;63     
;;;64     	if (g_tHC.RxCount < 10)				/* 接收到的数据小于个字节就认为错误 */
;;;65     	{
;;;66     		goto err_ret;
;;;67     	}
;;;68     
;;;69     //	g_hum  = (g_tHC.RxBuf[13]-0x30)*1000+(g_tHC.RxBuf[14]-0x30)*100+(g_tHC.RxBuf[16]-0x30)*10+(g_tHC.RxBuf[17]-0x30);
;;;70     //    g_temp = (g_tHC.RxBuf[30]-0x30)*1000+(g_tHC.RxBuf[31]-0x30)*100+(g_tHC.RxBuf[33]-0x30)*10+(g_tHC.RxBuf[34]-0x30);
;;;71         g_hum  = (g_tHC.RxBuf[5]-0x30)*1000+(g_tHC.RxBuf[6]-0x30)*100+(g_tHC.RxBuf[8]-0x30)*10+(g_tHC.RxBuf[9]-0x30);
;;;72         g_temp = (g_tHC.RxBuf[22]-0x30)*1000+(g_tHC.RxBuf[23]-0x30)*100+(g_tHC.RxBuf[25]-0x30)*10+(g_tHC.RxBuf[26]-0x30);
;;;73     	
;;;74         if(g_hum<10000)
;;;75         g_tVar.P01 = g_hum ;
;;;76         if(g_temp<10000)
;;;77         g_tVar.P02 = g_temp;
;;;78     	 bsp_LedToggle(3); //传感器数据接收一次 闪烁一次	D6			
;;;79     	
;;;80     err_ret:
;;;81     #if 1										/* 此部分为了串口打印结果,实际运用中可不要 */
;;;82     	g_tPrint.Rxlen = g_tHC.RxCount;
;;;83     	memcpy(g_tPrint.RxBuf, g_tHC.RxBuf, g_tHC.RxCount);
;;;84     #endif
;;;85     	
;;;86     	g_tHC.RxCount = 0;					/* 必须清零计数器，方便下次帧同步 */
;;;87         g_hcRevOK =1; //表示接受解码ok
;;;88     }
000008  bd10              POP      {r4,pc}
                  |L1.10|
00000a  2000              MOVS     r0,#0                 ;62
00000c  4936              LDR      r1,|L1.232|
00000e  7008              STRB     r0,[r1,#0]            ;62
000010  4836              LDR      r0,|L1.236|
000012  f8900080          LDRB     r0,[r0,#0x80]         ;64  ; g_tHC
000016  280a              CMP      r0,#0xa               ;64
000018  da00              BGE      |L1.28|
00001a  e04f              B        |L1.188|
                  |L1.28|
00001c  4833              LDR      r0,|L1.236|
00001e  7940              LDRB     r0,[r0,#5]            ;71  ; g_tHC
000020  3830              SUBS     r0,r0,#0x30           ;71
000022  f44f717a          MOV      r1,#0x3e8             ;71
000026  4348              MULS     r0,r1,r0              ;71
000028  4930              LDR      r1,|L1.236|
00002a  7989              LDRB     r1,[r1,#6]            ;71  ; g_tHC
00002c  3930              SUBS     r1,r1,#0x30           ;71
00002e  eb0102c1          ADD      r2,r1,r1,LSL #3       ;71
000032  eb021101          ADD      r1,r2,r1,LSL #4       ;71
000036  eb000181          ADD      r1,r0,r1,LSL #2       ;71
00003a  482c              LDR      r0,|L1.236|
00003c  7a00              LDRB     r0,[r0,#8]            ;71  ; g_tHC
00003e  3830              SUBS     r0,r0,#0x30           ;71
000040  eb000080          ADD      r0,r0,r0,LSL #2       ;71
000044  eb010140          ADD      r1,r1,r0,LSL #1       ;71
000048  4828              LDR      r0,|L1.236|
00004a  7a40              LDRB     r0,[r0,#9]            ;71  ; g_tHC
00004c  3830              SUBS     r0,r0,#0x30           ;71
00004e  4408              ADD      r0,r0,r1              ;71
000050  4927              LDR      r1,|L1.240|
000052  8008              STRH     r0,[r1,#0]            ;71
000054  4825              LDR      r0,|L1.236|
000056  7d80              LDRB     r0,[r0,#0x16]         ;72  ; g_tHC
000058  3830              SUBS     r0,r0,#0x30           ;72
00005a  f44f717a          MOV      r1,#0x3e8             ;72
00005e  4348              MULS     r0,r1,r0              ;72
000060  4922              LDR      r1,|L1.236|
000062  7dc9              LDRB     r1,[r1,#0x17]         ;72  ; g_tHC
000064  3930              SUBS     r1,r1,#0x30           ;72
000066  eb0102c1          ADD      r2,r1,r1,LSL #3       ;72
00006a  eb021101          ADD      r1,r2,r1,LSL #4       ;72
00006e  eb000181          ADD      r1,r0,r1,LSL #2       ;72
000072  481e              LDR      r0,|L1.236|
000074  7e40              LDRB     r0,[r0,#0x19]         ;72  ; g_tHC
000076  3830              SUBS     r0,r0,#0x30           ;72
000078  eb000080          ADD      r0,r0,r0,LSL #2       ;72
00007c  eb010140          ADD      r1,r1,r0,LSL #1       ;72
000080  481a              LDR      r0,|L1.236|
000082  7e80              LDRB     r0,[r0,#0x1a]         ;72  ; g_tHC
000084  3830              SUBS     r0,r0,#0x30           ;72
000086  4408              ADD      r0,r0,r1              ;72
000088  491a              LDR      r1,|L1.244|
00008a  8008              STRH     r0,[r1,#0]            ;72
00008c  4818              LDR      r0,|L1.240|
00008e  8800              LDRH     r0,[r0,#0]            ;74  ; g_hum
000090  f2427110          MOV      r1,#0x2710            ;74
000094  4288              CMP      r0,r1                 ;74
000096  da03              BGE      |L1.160|
000098  4815              LDR      r0,|L1.240|
00009a  8800              LDRH     r0,[r0,#0]            ;75  ; g_hum
00009c  4916              LDR      r1,|L1.248|
00009e  8008              STRH     r0,[r1,#0]            ;75
                  |L1.160|
0000a0  4814              LDR      r0,|L1.244|
0000a2  8800              LDRH     r0,[r0,#0]            ;76  ; g_temp
0000a4  f2427110          MOV      r1,#0x2710            ;76
0000a8  4288              CMP      r0,r1                 ;76
0000aa  da03              BGE      |L1.180|
0000ac  4811              LDR      r0,|L1.244|
0000ae  8800              LDRH     r0,[r0,#0]            ;77  ; g_temp
0000b0  4911              LDR      r1,|L1.248|
0000b2  8048              STRH     r0,[r1,#2]            ;77
                  |L1.180|
0000b4  2003              MOVS     r0,#3                 ;78
0000b6  f7fffffe          BL       bsp_LedToggle
0000ba  bf00              NOP                            ;80
                  |L1.188|
0000bc  480b              LDR      r0,|L1.236|
0000be  f8900080          LDRB     r0,[r0,#0x80]         ;82  ; g_tHC
0000c2  490e              LDR      r1,|L1.252|
0000c4  7008              STRB     r0,[r1,#0]            ;82
0000c6  4809              LDR      r0,|L1.236|
0000c8  f8902080          LDRB     r2,[r0,#0x80]         ;83  ; g_tHC
0000cc  4601              MOV      r1,r0                 ;83
0000ce  480b              LDR      r0,|L1.252|
0000d0  1c40              ADDS     r0,r0,#1              ;83
0000d2  f7fffffe          BL       __aeabi_memcpy
0000d6  2000              MOVS     r0,#0                 ;86
0000d8  4904              LDR      r1,|L1.236|
0000da  f8810080          STRB     r0,[r1,#0x80]         ;86
0000de  2001              MOVS     r0,#1                 ;87
0000e0  4907              LDR      r1,|L1.256|
0000e2  7008              STRB     r0,[r1,#0]            ;87
0000e4  bf00              NOP      
0000e6  e78f              B        |L1.8|
                          ENDP

                  |L1.232|
                          DCD      g_hc_timeout
                  |L1.236|
                          DCD      g_tHC
                  |L1.240|
                          DCD      g_hum
                  |L1.244|
                          DCD      g_temp
                  |L1.248|
                          DCD      g_tVar
                  |L1.252|
                          DCD      g_tPrint
                  |L1.256|
                          DCD      g_hcRevOK

                          AREA ||i.HC_AskForData||, CODE, READONLY, ALIGN=2

                  HC_AskForData PROC
;;;49     
;;;50     void HC_AskForData(void)
000000  b510              PUSH     {r4,lr}
;;;51     {
;;;52        comSendBuf(COM2, send,9);
000002  2209              MOVS     r2,#9
000004  4902              LDR      r1,|L2.16|
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       comSendBuf
;;;53         
;;;54     }
00000c  bd10              POP      {r4,pc}
;;;55     void HC_Analyze(void)
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      send

                          AREA ||i.HC_ReciveNew||, CODE, READONLY, ALIGN=2

                  HC_ReciveNew PROC
;;;21     }
;;;22     void HC_ReciveNew(uint8_t _data)
000000  b570              PUSH     {r4-r6,lr}
;;;23     {
000002  4604              MOV      r4,r0
;;;24             /*
;;;25     		3.5个字符的时间间隔，只是用在RTU模式下面，因为RTU模式没有开始符和结束符，
;;;26     		两个数据包之间只能靠时间间隔来区分，Modbus定义在不同的波特率下，间隔时间是不一样的，
;;;27     		所以就是3.5个字符的时间，波特率高，这个时间间隔就小，波特率低，这个时间间隔相应就大
;;;28     
;;;29     		4800  = 7.297ms
;;;30     		9600  = 3.646ms
;;;31     		19200  = 1.771ms
;;;32     		38400  = 0.885ms
;;;33     	*/
;;;34     	uint32_t timeout;
;;;35     
;;;36     	g_hc_timeout = 0;
000004  2000              MOVS     r0,#0
000006  490d              LDR      r1,|L3.60|
000008  7008              STRB     r0,[r1,#0]
;;;37     	
;;;38     	timeout = 45000000 / UART2_BAUD;		/* 计算超时时间，单位us 35000000*/
00000a  f6401527          MOV      r5,#0x927
;;;39     	
;;;40     	/* 硬件定时中断，定时精度us 硬件定时器2用于MODBUS从机, 定时器3用于MODBUS从机主机*/
;;;41     	bsp_StartHardTimer(3, timeout, (void *)HC_RxTimeOut);
00000e  4a0c              LDR      r2,|L3.64|
000010  4629              MOV      r1,r5
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       bsp_StartHardTimer
;;;42     
;;;43     	if (g_tHC.RxCount < HC_RX_BUF_SIZE)
000018  480a              LDR      r0,|L3.68|
00001a  f8900080          LDRB     r0,[r0,#0x80]  ; g_tHC
00001e  2880              CMP      r0,#0x80
000020  da0a              BGE      |L3.56|
;;;44     	{
;;;45     		g_tHC.RxBuf[g_tHC.RxCount++] = _data;
000022  4808              LDR      r0,|L3.68|
000024  f8901080          LDRB     r1,[r0,#0x80]  ; g_tHC
000028  f8900080          LDRB     r0,[r0,#0x80]  ; g_tHC
00002c  1c40              ADDS     r0,r0,#1
00002e  4a05              LDR      r2,|L3.68|
000030  f8820080          STRB     r0,[r2,#0x80]
000034  4610              MOV      r0,r2
000036  5444              STRB     r4,[r0,r1]
                  |L3.56|
;;;46     	}
;;;47         
;;;48     }
000038  bd70              POP      {r4-r6,pc}
;;;49     
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
                          DCD      g_hc_timeout
                  |L3.64|
                          DCD      HC_RxTimeOut
                  |L3.68|
                          DCD      g_tHC

                          AREA ||i.HC_RxTimeOut||, CODE, READONLY, ALIGN=2

                  HC_RxTimeOut PROC
;;;17     */
;;;18     static void HC_RxTimeOut(void)
000000  2001              MOVS     r0,#1
;;;19     {
;;;20     	g_hc_timeout = 1;
000002  4901              LDR      r1,|L4.8|
000004  7008              STRB     r0,[r1,#0]
;;;21     }
000006  4770              BX       lr
;;;22     void HC_ReciveNew(uint8_t _data)
                          ENDP

                  |L4.8|
                          DCD      g_hc_timeout

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_tHC
                          %        160

                          AREA ||.data||, DATA, ALIGN=1

                  send
000000  7b463034          DCB      0x7b,0x46,0x30,0x34
000004  5244447d          DCB      0x52,0x44,0x44,0x7d
000008  0d00              DCB      0x0d,0x00
                  g_hc_timeout
00000a  0000              DCB      0x00,0x00
                  g_hum
00000c  0000              DCB      0x00,0x00
                  g_temp
00000e  0000              DCB      0x00,0x00
                  g_hcRevOK
000010  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_hc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_bsp_hc_c_send____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_bsp_hc_c_send____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_bsp_hc_c_send____REVSH|
#line 128
|__asm___8_bsp_hc_c_send____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
