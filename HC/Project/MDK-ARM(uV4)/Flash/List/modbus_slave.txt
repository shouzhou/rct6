; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\modbus_slave.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\modbus_slave.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\User -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User\app\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\modbus_slave.crf ..\..\User\app\src\modbus_slave.c]
                          THUMB

                          AREA ||i.MODS_01H||, CODE, READONLY, ALIGN=2

                  MODS_01H PROC
;;;269    /* 说明:这里用LED代替继电器,便于观察现象 */
;;;270    static void MODS_01H(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;271    {
;;;272    	/*
;;;273    	 举例：
;;;274    		主机发送:
;;;275    			11 从机地址
;;;276    			01 功能码
;;;277    			00 寄存器起始地址高字节
;;;278    			13 寄存器起始地址低字节
;;;279    			00 寄存器数量高字节
;;;280    			25 寄存器数量低字节
;;;281    			0E CRC校验高字节
;;;282    			84 CRC校验低字节
;;;283    
;;;284    		从机应答: 	1代表ON，0代表OFF。若返回的线圈数不为8的倍数，则在最后数据字节未尾使用0代替. BIT0对应第1个
;;;285    			11 从机地址
;;;286    			01 功能码
;;;287    			05 返回字节数
;;;288    			CD 数据1(线圈0013H-线圈001AH)
;;;289    			6B 数据2(线圈001BH-线圈0022H)
;;;290    			B2 数据3(线圈0023H-线圈002AH)
;;;291    			0E 数据4(线圈0032H-线圈002BH)
;;;292    			1B 数据5(线圈0037H-线圈0033H)
;;;293    			45 CRC校验高字节
;;;294    			E6 CRC校验低字节
;;;295    
;;;296    		例子:
;;;297    			01 01 10 01 00 03   29 0B	--- 查询D01开始的3个继电器状态
;;;298    			01 01 10 03 00 01   09 0A   --- 查询D03继电器的状态
;;;299    	*/
;;;300    	uint16_t reg;
;;;301    	uint16_t num;
;;;302    	uint16_t i;
;;;303    	uint16_t m;
;;;304    	uint8_t status[10];
;;;305    	
;;;306    	g_tModS.RspCode = RSP_OK;
000002  2000              MOVS     r0,#0
000004  4952              LDR      r1,|L1.336|
000006  f8810021          STRB     r0,[r1,#0x21]
;;;307    
;;;308    	/* 没有外部继电器，直接应答错误 */
;;;309    	if (g_tModS.RxCount != 8)
00000a  4608              MOV      r0,r1
00000c  7f80              LDRB     r0,[r0,#0x1e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d003              BEQ      |L1.26|
;;;310    	{
;;;311    		g_tModS.RspCode = RSP_ERR_VALUE;				/* 数据值域错误 */
000012  2003              MOVS     r0,#3
000014  f8810021          STRB     r0,[r1,#0x21]
                  |L1.24|
;;;312    		return;
;;;313    	}
;;;314    
;;;315    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 			/* 寄存器号 */
;;;316    	num = BEBufToUint16(&g_tModS.RxBuf[4]);				/* 寄存器个数 */
;;;317    
;;;318    	m = (num + 7) / 8;
;;;319    	
;;;320    	if ((reg >= REG_D01) && (num > 0) && (reg + num <= REG_DXX + 1))
;;;321    	{
;;;322    		for (i = 0; i < m; i++)
;;;323    		{
;;;324    			status[i] = 0;
;;;325    		}
;;;326    		for (i = 0; i < num; i++)
;;;327    		{
;;;328    			if (bsp_IsLedOn(i + 1 + reg - REG_D01))		/* 读LED的状态，写入状态寄存器的每一位 */
;;;329    			{  
;;;330    				status[i / 8] |= (1 << (i % 8));
;;;331    			}
;;;332    		}
;;;333    	}
;;;334    	else
;;;335    	{
;;;336    		g_tModS.RspCode = RSP_ERR_REG_ADDR;				/* 寄存器地址错误 */
;;;337    	}
;;;338    
;;;339    	if (g_tModS.RspCode == RSP_OK)						/* 正确应答 */
;;;340    	{
;;;341    		g_tModS.TxCount = 0;
;;;342    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
;;;343    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
;;;344    		g_tModS.TxBuf[g_tModS.TxCount++] = m;			/* 返回字节数 */
;;;345    
;;;346    		for (i = 0; i < m; i++)
;;;347    		{
;;;348    			g_tModS.TxBuf[g_tModS.TxCount++] = status[i];	/* 继电器状态 */
;;;349    		}
;;;350    		MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);
;;;351    	}
;;;352    	else
;;;353    	{
;;;354    		MODS_SendAckErr(g_tModS.RspCode);				/* 告诉主机命令错误 */
;;;355    	}
;;;356    }
000018  bdfe              POP      {r1-r7,pc}
                  |L1.26|
00001a  484d              LDR      r0,|L1.336|
00001c  1c80              ADDS     r0,r0,#2              ;315
00001e  f7fffffe          BL       BEBufToUint16
000022  4607              MOV      r7,r0                 ;315
000024  484a              LDR      r0,|L1.336|
000026  1d00              ADDS     r0,r0,#4              ;316
000028  f7fffffe          BL       BEBufToUint16
00002c  4605              MOV      r5,r0                 ;316
00002e  1de8              ADDS     r0,r5,#7              ;318
000030  17c1              ASRS     r1,r0,#31             ;318
000032  eb007151          ADD      r1,r0,r1,LSR #29      ;318
000036  10ce              ASRS     r6,r1,#3              ;318
000038  f5b77f80          CMP      r7,#0x100             ;320
00003c  dd35              BLE      |L1.170|
00003e  2d00              CMP      r5,#0                 ;320
000040  dd33              BLE      |L1.170|
000042  1978              ADDS     r0,r7,r5              ;320
000044  f5b07f83          CMP      r0,#0x106             ;320
000048  da2f              BGE      |L1.170|
00004a  2400              MOVS     r4,#0                 ;322
00004c  e004              B        |L1.88|
                  |L1.78|
00004e  2000              MOVS     r0,#0                 ;324
000050  f80d0004          STRB     r0,[sp,r4]            ;324
000054  1c60              ADDS     r0,r4,#1              ;322
000056  b284              UXTH     r4,r0                 ;322
                  |L1.88|
000058  42b4              CMP      r4,r6                 ;322
00005a  dbf8              BLT      |L1.78|
00005c  2400              MOVS     r4,#0                 ;326
00005e  e021              B        |L1.164|
                  |L1.96|
000060  1c61              ADDS     r1,r4,#1              ;328
000062  4439              ADD      r1,r1,r7              ;328
000064  1e49              SUBS     r1,r1,#1              ;328
000066  b2c8              UXTB     r0,r1                 ;328
000068  f7fffffe          BL       bsp_IsLedOn
00006c  b1c0              CBZ      r0,|L1.160|
00006e  17e2              ASRS     r2,r4,#31             ;330
000070  eb047252          ADD      r2,r4,r2,LSR #29      ;330
000074  10d2              ASRS     r2,r2,#3              ;330
000076  f81d2002          LDRB     r2,[sp,r2]            ;330
00007a  4621              MOV      r1,r4                 ;330
00007c  17e3              ASRS     r3,r4,#31             ;330
00007e  eb047353          ADD      r3,r4,r3,LSR #29      ;330
000082  10db              ASRS     r3,r3,#3              ;330
000084  eba40cc3          SUB      r12,r4,r3,LSL #3      ;330
000088  2301              MOVS     r3,#1                 ;330
00008a  fa03f30c          LSL      r3,r3,r12             ;330
00008e  431a              ORRS     r2,r2,r3              ;330
000090  b2d2              UXTB     r2,r2                 ;330
000092  4620              MOV      r0,r4                 ;330
000094  17e3              ASRS     r3,r4,#31             ;330
000096  eb047353          ADD      r3,r4,r3,LSR #29      ;330
00009a  10db              ASRS     r3,r3,#3              ;330
00009c  f80d2003          STRB     r2,[sp,r3]            ;330
                  |L1.160|
0000a0  1c60              ADDS     r0,r4,#1              ;326
0000a2  b284              UXTH     r4,r0                 ;326
                  |L1.164|
0000a4  42ac              CMP      r4,r5                 ;326
0000a6  dbdb              BLT      |L1.96|
0000a8  e003              B        |L1.178|
                  |L1.170|
0000aa  2002              MOVS     r0,#2                 ;336
0000ac  4928              LDR      r1,|L1.336|
0000ae  f8810021          STRB     r0,[r1,#0x21]         ;336
                  |L1.178|
0000b2  4827              LDR      r0,|L1.336|
0000b4  f8900021          LDRB     r0,[r0,#0x21]         ;339  ; g_tModS
0000b8  2800              CMP      r0,#0                 ;339
0000ba  d141              BNE      |L1.320|
0000bc  4924              LDR      r1,|L1.336|
0000be  f88100a2          STRB     r0,[r1,#0xa2]         ;341
0000c2  4608              MOV      r0,r1                 ;342
0000c4  7801              LDRB     r1,[r0,#0]            ;342  ; g_tModS
0000c6  f89020a2          LDRB     r2,[r0,#0xa2]         ;342  ; g_tModS
0000ca  f89000a2          LDRB     r0,[r0,#0xa2]         ;342  ; g_tModS
0000ce  1c40              ADDS     r0,r0,#1              ;342
0000d0  4b1f              LDR      r3,|L1.336|
0000d2  f88300a2          STRB     r0,[r3,#0xa2]         ;342
0000d6  f1030022          ADD      r0,r3,#0x22           ;342
0000da  5481              STRB     r1,[r0,r2]            ;342
0000dc  3822              SUBS     r0,r0,#0x22           ;343
0000de  7841              LDRB     r1,[r0,#1]            ;343  ; g_tModS
0000e0  f89020a2          LDRB     r2,[r0,#0xa2]         ;343  ; g_tModS
0000e4  f89000a2          LDRB     r0,[r0,#0xa2]         ;343  ; g_tModS
0000e8  1c40              ADDS     r0,r0,#1              ;343
0000ea  f88300a2          STRB     r0,[r3,#0xa2]         ;343
0000ee  f1030022          ADD      r0,r3,#0x22           ;343
0000f2  5481              STRB     r1,[r0,r2]            ;343
0000f4  3822              SUBS     r0,r0,#0x22           ;344
0000f6  f89020a2          LDRB     r2,[r0,#0xa2]         ;344  ; g_tModS
0000fa  f89000a2          LDRB     r0,[r0,#0xa2]         ;344  ; g_tModS
0000fe  1c40              ADDS     r0,r0,#1              ;344
000100  f88300a2          STRB     r0,[r3,#0xa2]         ;344
000104  f1030022          ADD      r0,r3,#0x22           ;344
000108  5486              STRB     r6,[r0,r2]            ;344
00010a  2400              MOVS     r4,#0                 ;346
00010c  e00f              B        |L1.302|
                  |L1.270|
00010e  f81d1004          LDRB     r1,[sp,r4]            ;348
000112  480f              LDR      r0,|L1.336|
000114  f89020a2          LDRB     r2,[r0,#0xa2]         ;348  ; g_tModS
000118  f89000a2          LDRB     r0,[r0,#0xa2]         ;348  ; g_tModS
00011c  1c40              ADDS     r0,r0,#1              ;348
00011e  4b0c              LDR      r3,|L1.336|
000120  f88300a2          STRB     r0,[r3,#0xa2]         ;348
000124  f1030022          ADD      r0,r3,#0x22           ;348
000128  5481              STRB     r1,[r0,r2]            ;348
00012a  1c60              ADDS     r0,r4,#1              ;346
00012c  b284              UXTH     r4,r0                 ;346
                  |L1.302|
00012e  42b4              CMP      r4,r6                 ;346
000130  dbed              BLT      |L1.270|
000132  4807              LDR      r0,|L1.336|
000134  f89010a2          LDRB     r1,[r0,#0xa2]         ;350  ; g_tModS
000138  3022              ADDS     r0,r0,#0x22           ;350
00013a  f7fffffe          BL       MODS_SendWithCRC
00013e  e004              B        |L1.330|
                  |L1.320|
000140  4903              LDR      r1,|L1.336|
000142  f8910021          LDRB     r0,[r1,#0x21]         ;354  ; g_tModS
000146  f7fffffe          BL       MODS_SendAckErr
                  |L1.330|
00014a  bf00              NOP      
00014c  e764              B        |L1.24|
;;;357    
                          ENDP

00014e  0000              DCW      0x0000
                  |L1.336|
                          DCD      g_tModS

                          AREA ||i.MODS_02H||, CODE, READONLY, ALIGN=2

                  MODS_02H PROC
;;;365    */
;;;366    static void MODS_02H(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;367    {
;;;368    	/*
;;;369    		主机发送:
;;;370    			11 从机地址
;;;371    			02 功能码
;;;372    			00 寄存器地址高字节
;;;373    			C4 寄存器地址低字节
;;;374    			00 寄存器数量高字节
;;;375    			16 寄存器数量低字节
;;;376    			BA CRC校验高字节
;;;377    			A9 CRC校验低字节
;;;378    
;;;379    		从机应答:  响应各离散输入寄存器状态，分别对应数据区中的每位值，1 代表ON；0 代表OFF。
;;;380    		           第一个数据字节的LSB(最低字节)为查询的寻址地址，其他输入口按顺序在该字节中由低字节
;;;381    		           向高字节排列，直到填充满8位。下一个字节中的8个输入位也是从低字节到高字节排列。
;;;382    		           若返回的输入位数不是8的倍数，则在最后的数据字节中的剩余位至该字节的最高位使用0填充。
;;;383    			11 从机地址
;;;384    			02 功能码
;;;385    			03 返回字节数
;;;386    			AC 数据1(00C4H-00CBH)
;;;387    			DB 数据2(00CCH-00D3H)
;;;388    			35 数据3(00D4H-00D9H)
;;;389    			20 CRC校验高字节
;;;390    			18 CRC校验低字节
;;;391    
;;;392    		例子:
;;;393    		01 02 20 01 00 08  23CC  ---- 读取T01-08的状态
;;;394    		01 02 20 04 00 02  B3CA  ---- 读取T04-05的状态
;;;395    		01 02 20 01 00 12  A207   ---- 读 T01-18
;;;396    	*/
;;;397    
;;;398    	uint16_t reg;
;;;399    	uint16_t num;
;;;400    	uint16_t i;
;;;401    	uint16_t m;
;;;402    	uint8_t status[10];
;;;403    
;;;404    	g_tModS.RspCode = RSP_OK;
000002  2000              MOVS     r0,#0
000004  4951              LDR      r1,|L2.332|
000006  f8810021          STRB     r0,[r1,#0x21]
;;;405    
;;;406    	if (g_tModS.RxCount != 8)
00000a  4608              MOV      r0,r1
00000c  7f80              LDRB     r0,[r0,#0x1e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d003              BEQ      |L2.26|
;;;407    	{
;;;408    		g_tModS.RspCode = RSP_ERR_VALUE;				/* 数据值域错误 */
000012  2003              MOVS     r0,#3
000014  f8810021          STRB     r0,[r1,#0x21]
                  |L2.24|
;;;409    		return;
;;;410    	}
;;;411    
;;;412    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 			/* 寄存器号 */
;;;413    	num = BEBufToUint16(&g_tModS.RxBuf[4]);				/* 寄存器个数 */
;;;414    
;;;415    	m = (num + 7) / 8;
;;;416    	if ((reg >= REG_T01) && (num > 0) && (reg + num <= REG_TXX + 1))
;;;417    	{
;;;418    		for (i = 0; i < m; i++)
;;;419    		{
;;;420    			status[i] = 0;
;;;421    		}
;;;422    		for (i = 0; i < num; i++)
;;;423    		{
;;;424    			if (bsp_GetKeyState((KEY_ID_E)(KID_K1 + reg - REG_T01 + i)))
;;;425    			{
;;;426    				status[i / 8] |= (1 << (i % 8));
;;;427    			}
;;;428    		}
;;;429    	}
;;;430    	else
;;;431    	{
;;;432    		g_tModS.RspCode = RSP_ERR_REG_ADDR;				/* 寄存器地址错误 */
;;;433    	}
;;;434    
;;;435    	if (g_tModS.RspCode == RSP_OK)						/* 正确应答 */
;;;436    	{
;;;437    		g_tModS.TxCount = 0;
;;;438    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
;;;439    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
;;;440    		g_tModS.TxBuf[g_tModS.TxCount++] = m;			/* 返回字节数 */
;;;441    
;;;442    		for (i = 0; i < m; i++)
;;;443    		{
;;;444    			g_tModS.TxBuf[g_tModS.TxCount++] = status[i];	/* T01-02状态 */
;;;445    		}
;;;446    		MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);
;;;447    	}
;;;448    	else
;;;449    	{
;;;450    		MODS_SendAckErr(g_tModS.RspCode);				/* 告诉主机命令错误 */
;;;451    	}
;;;452    }
000018  bdfe              POP      {r1-r7,pc}
                  |L2.26|
00001a  484c              LDR      r0,|L2.332|
00001c  1c80              ADDS     r0,r0,#2              ;412
00001e  f7fffffe          BL       BEBufToUint16
000022  4606              MOV      r6,r0                 ;412
000024  4849              LDR      r0,|L2.332|
000026  1d00              ADDS     r0,r0,#4              ;413
000028  f7fffffe          BL       BEBufToUint16
00002c  4605              MOV      r5,r0                 ;413
00002e  1de8              ADDS     r0,r5,#7              ;415
000030  17c1              ASRS     r1,r0,#31             ;415
000032  eb007151          ADD      r1,r0,r1,LSR #29      ;415
000036  10cf              ASRS     r7,r1,#3              ;415
000038  f5b67f00          CMP      r6,#0x200             ;416
00003c  dd34              BLE      |L2.168|
00003e  2d00              CMP      r5,#0                 ;416
000040  dd32              BLE      |L2.168|
000042  1970              ADDS     r0,r6,r5              ;416
000044  f5b07f01          CMP      r0,#0x204             ;416
000048  dc2e              BGT      |L2.168|
00004a  2400              MOVS     r4,#0                 ;418
00004c  e004              B        |L2.88|
                  |L2.78|
00004e  2000              MOVS     r0,#0                 ;420
000050  f80d0004          STRB     r0,[sp,r4]            ;420
000054  1c60              ADDS     r0,r4,#1              ;418
000056  b284              UXTH     r4,r0                 ;418
                  |L2.88|
000058  42bc              CMP      r4,r7                 ;418
00005a  dbf8              BLT      |L2.78|
00005c  2400              MOVS     r4,#0                 ;422
00005e  e020              B        |L2.162|
                  |L2.96|
000060  1e71              SUBS     r1,r6,#1              ;424
000062  4421              ADD      r1,r1,r4              ;424
000064  b2c8              UXTB     r0,r1                 ;424
000066  f7fffffe          BL       bsp_GetKeyState
00006a  b1c0              CBZ      r0,|L2.158|
00006c  17e2              ASRS     r2,r4,#31             ;426
00006e  eb047252          ADD      r2,r4,r2,LSR #29      ;426
000072  10d2              ASRS     r2,r2,#3              ;426
000074  f81d2002          LDRB     r2,[sp,r2]            ;426
000078  4621              MOV      r1,r4                 ;426
00007a  17e3              ASRS     r3,r4,#31             ;426
00007c  eb047353          ADD      r3,r4,r3,LSR #29      ;426
000080  10db              ASRS     r3,r3,#3              ;426
000082  eba40cc3          SUB      r12,r4,r3,LSL #3      ;426
000086  2301              MOVS     r3,#1                 ;426
000088  fa03f30c          LSL      r3,r3,r12             ;426
00008c  431a              ORRS     r2,r2,r3              ;426
00008e  b2d2              UXTB     r2,r2                 ;426
000090  4620              MOV      r0,r4                 ;426
000092  17e3              ASRS     r3,r4,#31             ;426
000094  eb047353          ADD      r3,r4,r3,LSR #29      ;426
000098  10db              ASRS     r3,r3,#3              ;426
00009a  f80d2003          STRB     r2,[sp,r3]            ;426
                  |L2.158|
00009e  1c60              ADDS     r0,r4,#1              ;422
0000a0  b284              UXTH     r4,r0                 ;422
                  |L2.162|
0000a2  42ac              CMP      r4,r5                 ;422
0000a4  dbdc              BLT      |L2.96|
0000a6  e003              B        |L2.176|
                  |L2.168|
0000a8  2002              MOVS     r0,#2                 ;432
0000aa  4928              LDR      r1,|L2.332|
0000ac  f8810021          STRB     r0,[r1,#0x21]         ;432
                  |L2.176|
0000b0  4826              LDR      r0,|L2.332|
0000b2  f8900021          LDRB     r0,[r0,#0x21]         ;435  ; g_tModS
0000b6  2800              CMP      r0,#0                 ;435
0000b8  d141              BNE      |L2.318|
0000ba  4924              LDR      r1,|L2.332|
0000bc  f88100a2          STRB     r0,[r1,#0xa2]         ;437
0000c0  4608              MOV      r0,r1                 ;438
0000c2  7801              LDRB     r1,[r0,#0]            ;438  ; g_tModS
0000c4  f89020a2          LDRB     r2,[r0,#0xa2]         ;438  ; g_tModS
0000c8  f89000a2          LDRB     r0,[r0,#0xa2]         ;438  ; g_tModS
0000cc  1c40              ADDS     r0,r0,#1              ;438
0000ce  4b1f              LDR      r3,|L2.332|
0000d0  f88300a2          STRB     r0,[r3,#0xa2]         ;438
0000d4  f1030022          ADD      r0,r3,#0x22           ;438
0000d8  5481              STRB     r1,[r0,r2]            ;438
0000da  3822              SUBS     r0,r0,#0x22           ;439
0000dc  7841              LDRB     r1,[r0,#1]            ;439  ; g_tModS
0000de  f89020a2          LDRB     r2,[r0,#0xa2]         ;439  ; g_tModS
0000e2  f89000a2          LDRB     r0,[r0,#0xa2]         ;439  ; g_tModS
0000e6  1c40              ADDS     r0,r0,#1              ;439
0000e8  f88300a2          STRB     r0,[r3,#0xa2]         ;439
0000ec  f1030022          ADD      r0,r3,#0x22           ;439
0000f0  5481              STRB     r1,[r0,r2]            ;439
0000f2  3822              SUBS     r0,r0,#0x22           ;440
0000f4  f89020a2          LDRB     r2,[r0,#0xa2]         ;440  ; g_tModS
0000f8  f89000a2          LDRB     r0,[r0,#0xa2]         ;440  ; g_tModS
0000fc  1c40              ADDS     r0,r0,#1              ;440
0000fe  f88300a2          STRB     r0,[r3,#0xa2]         ;440
000102  f1030022          ADD      r0,r3,#0x22           ;440
000106  5487              STRB     r7,[r0,r2]            ;440
000108  2400              MOVS     r4,#0                 ;442
00010a  e00f              B        |L2.300|
                  |L2.268|
00010c  f81d1004          LDRB     r1,[sp,r4]            ;444
000110  480e              LDR      r0,|L2.332|
000112  f89020a2          LDRB     r2,[r0,#0xa2]         ;444  ; g_tModS
000116  f89000a2          LDRB     r0,[r0,#0xa2]         ;444  ; g_tModS
00011a  1c40              ADDS     r0,r0,#1              ;444
00011c  4b0b              LDR      r3,|L2.332|
00011e  f88300a2          STRB     r0,[r3,#0xa2]         ;444
000122  f1030022          ADD      r0,r3,#0x22           ;444
000126  5481              STRB     r1,[r0,r2]            ;444
000128  1c60              ADDS     r0,r4,#1              ;442
00012a  b284              UXTH     r4,r0                 ;442
                  |L2.300|
00012c  42bc              CMP      r4,r7                 ;442
00012e  dbed              BLT      |L2.268|
000130  4806              LDR      r0,|L2.332|
000132  f89010a2          LDRB     r1,[r0,#0xa2]         ;446  ; g_tModS
000136  3022              ADDS     r0,r0,#0x22           ;446
000138  f7fffffe          BL       MODS_SendWithCRC
00013c  e004              B        |L2.328|
                  |L2.318|
00013e  4903              LDR      r1,|L2.332|
000140  f8910021          LDRB     r0,[r1,#0x21]         ;450  ; g_tModS
000144  f7fffffe          BL       MODS_SendAckErr
                  |L2.328|
000148  bf00              NOP      
00014a  e765              B        |L2.24|
;;;453    
                          ENDP

                  |L2.332|
                          DCD      g_tModS

                          AREA ||i.MODS_03H||, CODE, READONLY, ALIGN=2

                  MODS_03H PROC
;;;522    */
;;;523    static void MODS_03H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;524    {
000002  b090              SUB      sp,sp,#0x40
;;;525    	/*
;;;526    		从机地址为11H。保持寄存器的起始地址为006BH，结束地址为006DH。该次查询总共访问3个保持寄存器。
;;;527    
;;;528    		主机发送:
;;;529    			11 从机地址
;;;530    			03 功能码
;;;531    			00 寄存器地址高字节
;;;532    			6B 寄存器地址低字节
;;;533    			00 寄存器数量高字节
;;;534    			03 寄存器数量低字节
;;;535    			76 CRC高字节
;;;536    			87 CRC低字节
;;;537    
;;;538    		从机应答: 	保持寄存器的长度为2个字节。对于单个保持寄存器而言，寄存器高字节数据先被传输，
;;;539    					低字节数据后被传输。保持寄存器之间，低地址寄存器先被传输，高地址寄存器后被传输。
;;;540    			11 从机地址
;;;541    			03 功能码
;;;542    			06 字节数
;;;543    			00 数据1高字节(006BH)
;;;544    			6B 数据1低字节(006BH)
;;;545    			00 数据2高字节(006CH)
;;;546    			13 数据2 低字节(006CH)
;;;547    			00 数据3高字节(006DH)
;;;548    			00 数据3低字节(006DH)
;;;549    			38 CRC高字节
;;;550    			B9 CRC低字节
;;;551    
;;;552    		例子:
;;;553    			01 03 30 06 00 01  6B0B      ---- 读 3006H, 触发电流
;;;554    			01 03 4000 0010 51C6         ---- 读 4000H 倒数第1条浪涌记录 32字节
;;;555    			01 03 4001 0010 0006         ---- 读 4001H 倒数第1条浪涌记录 32字节
;;;556    
;;;557    			01 03 F000 0008 770C         ---- 读 F000H 倒数第1条告警记录 16字节
;;;558    			01 03 F001 0008 26CC         ---- 读 F001H 倒数第2条告警记录 16字节
;;;559    
;;;560    			01 03 7000 0020 5ED2         ---- 读 7000H 倒数第1条波形记录第1段 64字节
;;;561    			01 03 7001 0020 0F12         ---- 读 7001H 倒数第1条波形记录第2段 64字节
;;;562    
;;;563    			01 03 7040 0020 5F06         ---- 读 7040H 倒数第2条波形记录第1段 64字节
;;;564    	*/
;;;565    	uint16_t reg;
;;;566    	uint16_t num;
;;;567    	uint16_t i;
;;;568    	uint8_t reg_value[64];
;;;569    
;;;570    	g_tModS.RspCode = RSP_OK;
000004  2000              MOVS     r0,#0
000006  4949              LDR      r1,|L3.300|
000008  f8810021          STRB     r0,[r1,#0x21]
;;;571    
;;;572    	if (g_tModS.RxCount != 8)								/* 03H命令必须是8个字节 */
00000c  4608              MOV      r0,r1
00000e  7f80              LDRB     r0,[r0,#0x1e]  ; g_tModS
000010  2808              CMP      r0,#8
000012  d003              BEQ      |L3.28|
;;;573    	{
;;;574    		g_tModS.RspCode = RSP_ERR_VALUE;					/* 数据值域错误 */
000014  2003              MOVS     r0,#3
000016  f8810021          STRB     r0,[r1,#0x21]
;;;575    		goto err_ret;
00001a  e027              B        |L3.108|
                  |L3.28|
;;;576    	}
;;;577    
;;;578    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 				/* 寄存器号 */
00001c  4843              LDR      r0,|L3.300|
00001e  1c80              ADDS     r0,r0,#2
000020  f7fffffe          BL       BEBufToUint16
000024  4606              MOV      r6,r0
;;;579    	num = BEBufToUint16(&g_tModS.RxBuf[4]);					/* 寄存器个数 */
000026  4841              LDR      r0,|L3.300|
000028  1d00              ADDS     r0,r0,#4
00002a  f7fffffe          BL       BEBufToUint16
00002e  4605              MOV      r5,r0
;;;580    	if (num > sizeof(reg_value) / 2)
000030  2d20              CMP      r5,#0x20
000032  d904              BLS      |L3.62|
;;;581    	{
;;;582    		g_tModS.RspCode = RSP_ERR_VALUE;					/* 数据值域错误 */
000034  2003              MOVS     r0,#3
000036  493d              LDR      r1,|L3.300|
000038  f8810021          STRB     r0,[r1,#0x21]
;;;583    		goto err_ret;
00003c  e016              B        |L3.108|
                  |L3.62|
;;;584    	}
;;;585    
;;;586    	for (i = 0; i < num; i++)
00003e  2400              MOVS     r4,#0
000040  e010              B        |L3.100|
                  |L3.66|
;;;587    	{
;;;588    		if (MODS_ReadRegValue(reg, &reg_value[2 * i]) == 0)	/* 读出寄存器值放入reg_value */
000042  4668              MOV      r0,sp
000044  2202              MOVS     r2,#2
000046  fb020104          MLA      r1,r2,r4,r0
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       MODS_ReadRegValue
000050  b920              CBNZ     r0,|L3.92|
;;;589    		{
;;;590    			g_tModS.RspCode = RSP_ERR_REG_ADDR;				/* 寄存器地址错误 */
000052  2002              MOVS     r0,#2
000054  4935              LDR      r1,|L3.300|
000056  f8810021          STRB     r0,[r1,#0x21]
;;;591    			break;
00005a  e005              B        |L3.104|
                  |L3.92|
;;;592    		}
;;;593    		reg++;
00005c  1c70              ADDS     r0,r6,#1
00005e  b286              UXTH     r6,r0
000060  1c60              ADDS     r0,r4,#1              ;586
000062  b284              UXTH     r4,r0                 ;586
                  |L3.100|
000064  42ac              CMP      r4,r5                 ;586
000066  dbec              BLT      |L3.66|
                  |L3.104|
000068  bf00              NOP                            ;591
;;;594    	}
;;;595    
;;;596    err_ret:
00006a  bf00              NOP      
                  |L3.108|
;;;597    	if (g_tModS.RspCode == RSP_OK)							/* 正确应答 */
00006c  482f              LDR      r0,|L3.300|
00006e  f8900021          LDRB     r0,[r0,#0x21]  ; g_tModS
000072  2800              CMP      r0,#0
000074  d152              BNE      |L3.284|
;;;598    	{
;;;599    		g_tModS.TxCount = 0;
000076  492d              LDR      r1,|L3.300|
000078  f88100a2          STRB     r0,[r1,#0xa2]
;;;600    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
00007c  4608              MOV      r0,r1
00007e  7801              LDRB     r1,[r0,#0]  ; g_tModS
000080  f89020a2          LDRB     r2,[r0,#0xa2]  ; g_tModS
000084  f89000a2          LDRB     r0,[r0,#0xa2]  ; g_tModS
000088  1c40              ADDS     r0,r0,#1
00008a  4b28              LDR      r3,|L3.300|
00008c  f88300a2          STRB     r0,[r3,#0xa2]
000090  f1030022          ADD      r0,r3,#0x22
000094  5481              STRB     r1,[r0,r2]
;;;601    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
000096  3822              SUBS     r0,r0,#0x22
000098  7841              LDRB     r1,[r0,#1]  ; g_tModS
00009a  f89020a2          LDRB     r2,[r0,#0xa2]  ; g_tModS
00009e  f89000a2          LDRB     r0,[r0,#0xa2]  ; g_tModS
0000a2  1c40              ADDS     r0,r0,#1
0000a4  f88300a2          STRB     r0,[r3,#0xa2]
0000a8  f1030022          ADD      r0,r3,#0x22
0000ac  5481              STRB     r1,[r0,r2]
;;;602    		g_tModS.TxBuf[g_tModS.TxCount++] = num * 2;			/* 返回字节数 */
0000ae  0668              LSLS     r0,r5,#25
0000b0  0e01              LSRS     r1,r0,#24
0000b2  4618              MOV      r0,r3
0000b4  f89020a2          LDRB     r2,[r0,#0xa2]  ; g_tModS
0000b8  f89000a2          LDRB     r0,[r0,#0xa2]  ; g_tModS
0000bc  1c40              ADDS     r0,r0,#1
0000be  f88300a2          STRB     r0,[r3,#0xa2]
0000c2  f1030022          ADD      r0,r3,#0x22
0000c6  5481              STRB     r1,[r0,r2]
;;;603    
;;;604    		for (i = 0; i < num; i++)
0000c8  2400              MOVS     r4,#0
0000ca  e01e              B        |L3.266|
                  |L3.204|
;;;605    		{
;;;606    			g_tModS.TxBuf[g_tModS.TxCount++] = reg_value[2*i];
0000cc  f81d1014          LDRB     r1,[sp,r4,LSL #1]
0000d0  4816              LDR      r0,|L3.300|
0000d2  f89020a2          LDRB     r2,[r0,#0xa2]  ; g_tModS
0000d6  f89000a2          LDRB     r0,[r0,#0xa2]  ; g_tModS
0000da  1c40              ADDS     r0,r0,#1
0000dc  4b13              LDR      r3,|L3.300|
0000de  f88300a2          STRB     r0,[r3,#0xa2]
0000e2  f1030022          ADD      r0,r3,#0x22
0000e6  5481              STRB     r1,[r0,r2]
;;;607    			g_tModS.TxBuf[g_tModS.TxCount++] = reg_value[2*i+1];
0000e8  0060              LSLS     r0,r4,#1
0000ea  1c40              ADDS     r0,r0,#1
0000ec  f81d1000          LDRB     r1,[sp,r0]
0000f0  4618              MOV      r0,r3
0000f2  f89020a2          LDRB     r2,[r0,#0xa2]  ; g_tModS
0000f6  f89000a2          LDRB     r0,[r0,#0xa2]  ; g_tModS
0000fa  1c40              ADDS     r0,r0,#1
0000fc  f88300a2          STRB     r0,[r3,#0xa2]
000100  f1030022          ADD      r0,r3,#0x22
000104  5481              STRB     r1,[r0,r2]
000106  1c60              ADDS     r0,r4,#1              ;604
000108  b284              UXTH     r4,r0                 ;604
                  |L3.266|
00010a  42ac              CMP      r4,r5                 ;604
00010c  dbde              BLT      |L3.204|
;;;608    		}
;;;609    		MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);	/* 发送正确应答 */
00010e  4807              LDR      r0,|L3.300|
000110  f89010a2          LDRB     r1,[r0,#0xa2]  ; g_tModS
000114  3022              ADDS     r0,r0,#0x22
000116  f7fffffe          BL       MODS_SendWithCRC
00011a  e004              B        |L3.294|
                  |L3.284|
;;;610    	}
;;;611    	else
;;;612    	{
;;;613    		MODS_SendAckErr(g_tModS.RspCode);					/* 发送错误应答 */
00011c  4903              LDR      r1,|L3.300|
00011e  f8910021          LDRB     r0,[r1,#0x21]  ; g_tModS
000122  f7fffffe          BL       MODS_SendAckErr
                  |L3.294|
;;;614    	}
;;;615    }
000126  b010              ADD      sp,sp,#0x40
000128  bd70              POP      {r4-r6,pc}
;;;616    
                          ENDP

00012a  0000              DCW      0x0000
                  |L3.300|
                          DCD      g_tModS

                          AREA ||i.MODS_04H||, CODE, READONLY, ALIGN=2

                  MODS_04H PROC
;;;624    */
;;;625    static void MODS_04H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;626    {
000002  b086              SUB      sp,sp,#0x18
;;;627    	/*
;;;628    		主机发送:
;;;629    			11 从机地址
;;;630    			04 功能码
;;;631    			00 寄存器起始地址高字节
;;;632    			08 寄存器起始地址低字节
;;;633    			00 寄存器个数高字节
;;;634    			02 寄存器个数低字节
;;;635    			F2 CRC高字节
;;;636    			99 CRC低字节
;;;637    
;;;638    		从机应答:  输入寄存器长度为2个字节。对于单个输入寄存器而言，寄存器高字节数据先被传输，
;;;639    				低字节数据后被传输。输入寄存器之间，低地址寄存器先被传输，高地址寄存器后被传输。
;;;640    			11 从机地址
;;;641    			04 功能码
;;;642    			04 字节数
;;;643    			00 数据1高字节(0008H)
;;;644    			0A 数据1低字节(0008H)
;;;645    			00 数据2高字节(0009H)
;;;646    			0B 数据2低字节(0009H)
;;;647    			8B CRC高字节
;;;648    			80 CRC低字节
;;;649    
;;;650    		例子:
;;;651    
;;;652    			01 04 2201 0006 2BB0  --- 读 2201H A01通道模拟量 开始的6个数据
;;;653    			01 04 2201 0001 6A72  --- 读 2201H
;;;654    
;;;655    	*/
;;;656    	uint16_t reg;
;;;657    	uint16_t num;
;;;658    	uint16_t i;
;;;659    	uint16_t status[10];
;;;660    
;;;661    	memset(status, 0, 10);
000004  210a              MOVS     r1,#0xa
000006  a801              ADD      r0,sp,#4
000008  f7fffffe          BL       __aeabi_memclr4
;;;662    
;;;663    	g_tModS.RspCode = RSP_OK;
00000c  2000              MOVS     r0,#0
00000e  494e              LDR      r1,|L4.328|
000010  f8810021          STRB     r0,[r1,#0x21]
;;;664    
;;;665    	if (g_tModS.RxCount != 8)
000014  4608              MOV      r0,r1
000016  7f80              LDRB     r0,[r0,#0x1e]  ; g_tModS
000018  2808              CMP      r0,#8
00001a  d003              BEQ      |L4.36|
;;;666    	{
;;;667    		g_tModS.RspCode = RSP_ERR_VALUE;	/* 数据值域错误 */
00001c  2003              MOVS     r0,#3
00001e  f8810021          STRB     r0,[r1,#0x21]
;;;668    		goto err_ret;
000022  e030              B        |L4.134|
                  |L4.36|
;;;669    	}
;;;670    
;;;671    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
000024  4848              LDR      r0,|L4.328|
000026  1c80              ADDS     r0,r0,#2
000028  f7fffffe          BL       BEBufToUint16
00002c  4606              MOV      r6,r0
;;;672    	num = BEBufToUint16(&g_tModS.RxBuf[4]);	/* 寄存器个数 */
00002e  4846              LDR      r0,|L4.328|
000030  1d00              ADDS     r0,r0,#4
000032  f7fffffe          BL       BEBufToUint16
000036  4605              MOV      r5,r0
;;;673    	
;;;674    	if ((reg >= REG_A01) && (num > 0) && (reg + num <= REG_AXX + 1))
000038  f5b66f80          CMP      r6,#0x400
00003c  dd1e              BLE      |L4.124|
00003e  2d00              CMP      r5,#0
000040  dd1c              BLE      |L4.124|
000042  1970              ADDS     r0,r6,r5
000044  f2404102          MOV      r1,#0x402
000048  4288              CMP      r0,r1
00004a  dc17              BGT      |L4.124|
;;;675    	{	
;;;676    		for (i = 0; i < num; i++)
00004c  2400              MOVS     r4,#0
00004e  e012              B        |L4.118|
                  |L4.80|
;;;677    		{
;;;678    			switch (reg)
000050  f2a64001          SUB      r0,r6,#0x401
000054  b928              CBNZ     r0,|L4.98|
;;;679    			{
;;;680    				/* 测试参数 */
;;;681    				case REG_A01:
;;;682    					status[i] = g_tVar.A01;
000056  483d              LDR      r0,|L4.332|
000058  8880              LDRH     r0,[r0,#4]  ; g_tVar
00005a  a901              ADD      r1,sp,#4
00005c  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;683    					break;
000060  e004              B        |L4.108|
                  |L4.98|
;;;684    					
;;;685    				default:
;;;686    					status[i] = 0;
000062  2000              MOVS     r0,#0
000064  a901              ADD      r1,sp,#4
000066  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;687    					break;
00006a  bf00              NOP      
                  |L4.108|
00006c  bf00              NOP                            ;683
;;;688    			}
;;;689    			reg++;
00006e  1c70              ADDS     r0,r6,#1
000070  b286              UXTH     r6,r0
000072  1c60              ADDS     r0,r4,#1              ;676
000074  b284              UXTH     r4,r0                 ;676
                  |L4.118|
000076  42ac              CMP      r4,r5                 ;676
000078  dbea              BLT      |L4.80|
00007a  e003              B        |L4.132|
                  |L4.124|
;;;690    		}
;;;691    	}
;;;692    	else
;;;693    	{
;;;694    		g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
00007c  2002              MOVS     r0,#2
00007e  4932              LDR      r1,|L4.328|
000080  f8810021          STRB     r0,[r1,#0x21]
                  |L4.132|
;;;695    	}
;;;696    
;;;697    err_ret:
000084  bf00              NOP      
                  |L4.134|
;;;698    	if (g_tModS.RspCode == RSP_OK)		/* 正确应答 */
000086  4830              LDR      r0,|L4.328|
000088  f8900021          LDRB     r0,[r0,#0x21]  ; g_tModS
00008c  2800              CMP      r0,#0
00008e  d153              BNE      |L4.312|
;;;699    	{
;;;700    		g_tModS.TxCount = 0;
000090  492d              LDR      r1,|L4.328|
000092  f88100a2          STRB     r0,[r1,#0xa2]
;;;701    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[0];
000096  4608              MOV      r0,r1
000098  7801              LDRB     r1,[r0,#0]  ; g_tModS
00009a  f89020a2          LDRB     r2,[r0,#0xa2]  ; g_tModS
00009e  f89000a2          LDRB     r0,[r0,#0xa2]  ; g_tModS
0000a2  1c40              ADDS     r0,r0,#1
0000a4  4b28              LDR      r3,|L4.328|
0000a6  f88300a2          STRB     r0,[r3,#0xa2]
0000aa  f1030022          ADD      r0,r3,#0x22
0000ae  5481              STRB     r1,[r0,r2]
;;;702    		g_tModS.TxBuf[g_tModS.TxCount++] = g_tModS.RxBuf[1];
0000b0  3822              SUBS     r0,r0,#0x22
0000b2  7841              LDRB     r1,[r0,#1]  ; g_tModS
0000b4  f89020a2          LDRB     r2,[r0,#0xa2]  ; g_tModS
0000b8  f89000a2          LDRB     r0,[r0,#0xa2]  ; g_tModS
0000bc  1c40              ADDS     r0,r0,#1
0000be  f88300a2          STRB     r0,[r3,#0xa2]
0000c2  f1030022          ADD      r0,r3,#0x22
0000c6  5481              STRB     r1,[r0,r2]
;;;703    		g_tModS.TxBuf[g_tModS.TxCount++] = num * 2;			/* 返回字节数 */
0000c8  0668              LSLS     r0,r5,#25
0000ca  0e01              LSRS     r1,r0,#24
0000cc  4618              MOV      r0,r3
0000ce  f89020a2          LDRB     r2,[r0,#0xa2]  ; g_tModS
0000d2  f89000a2          LDRB     r0,[r0,#0xa2]  ; g_tModS
0000d6  1c40              ADDS     r0,r0,#1
0000d8  f88300a2          STRB     r0,[r3,#0xa2]
0000dc  f1030022          ADD      r0,r3,#0x22
0000e0  5481              STRB     r1,[r0,r2]
;;;704    
;;;705    		for (i = 0; i < num; i++)
0000e2  2400              MOVS     r4,#0
0000e4  e01f              B        |L4.294|
                  |L4.230|
;;;706    		{
;;;707    			g_tModS.TxBuf[g_tModS.TxCount++] = status[i] >> 8;
0000e6  a801              ADD      r0,sp,#4
0000e8  f8300014          LDRH     r0,[r0,r4,LSL #1]
0000ec  1201              ASRS     r1,r0,#8
0000ee  4816              LDR      r0,|L4.328|
0000f0  f89020a2          LDRB     r2,[r0,#0xa2]  ; g_tModS
0000f4  f89000a2          LDRB     r0,[r0,#0xa2]  ; g_tModS
0000f8  1c40              ADDS     r0,r0,#1
0000fa  4b13              LDR      r3,|L4.328|
0000fc  f88300a2          STRB     r0,[r3,#0xa2]
000100  f1030022          ADD      r0,r3,#0x22
000104  5481              STRB     r1,[r0,r2]
;;;708    			g_tModS.TxBuf[g_tModS.TxCount++] = status[i] & 0xFF;
000106  a801              ADD      r0,sp,#4
000108  f8101014          LDRB     r1,[r0,r4,LSL #1]
00010c  4618              MOV      r0,r3
00010e  f89020a2          LDRB     r2,[r0,#0xa2]  ; g_tModS
000112  f89000a2          LDRB     r0,[r0,#0xa2]  ; g_tModS
000116  1c40              ADDS     r0,r0,#1
000118  f88300a2          STRB     r0,[r3,#0xa2]
00011c  f1030022          ADD      r0,r3,#0x22
000120  5481              STRB     r1,[r0,r2]
000122  1c60              ADDS     r0,r4,#1              ;705
000124  b284              UXTH     r4,r0                 ;705
                  |L4.294|
000126  42ac              CMP      r4,r5                 ;705
000128  dbdd              BLT      |L4.230|
;;;709    		}
;;;710    		MODS_SendWithCRC(g_tModS.TxBuf, g_tModS.TxCount);
00012a  4807              LDR      r0,|L4.328|
00012c  f89010a2          LDRB     r1,[r0,#0xa2]  ; g_tModS
000130  3022              ADDS     r0,r0,#0x22
000132  f7fffffe          BL       MODS_SendWithCRC
000136  e004              B        |L4.322|
                  |L4.312|
;;;711    	}
;;;712    	else
;;;713    	{
;;;714    		MODS_SendAckErr(g_tModS.RspCode);	/* 告诉主机命令错误 */
000138  4903              LDR      r1,|L4.328|
00013a  f8910021          LDRB     r0,[r1,#0x21]  ; g_tModS
00013e  f7fffffe          BL       MODS_SendAckErr
                  |L4.322|
;;;715    	}
;;;716    }
000142  b006              ADD      sp,sp,#0x18
000144  bd70              POP      {r4-r6,pc}
;;;717    
                          ENDP

000146  0000              DCW      0x0000
                  |L4.328|
                          DCD      g_tModS
                  |L4.332|
                          DCD      g_tVar

                          AREA ||i.MODS_05H||, CODE, READONLY, ALIGN=2

                  MODS_05H PROC
;;;725    */
;;;726    static void MODS_05H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;727    {
;;;728    	/*
;;;729    		主机发送: 写单个线圈寄存器。FF00H值请求线圈处于ON状态，0000H值请求线圈处于OFF状态
;;;730    		。05H指令设置单个线圈的状态，15H指令可以设置多个线圈的状态。
;;;731    			11 从机地址
;;;732    			05 功能码
;;;733    			00 寄存器地址高字节
;;;734    			AC 寄存器地址低字节
;;;735    			FF 数据1高字节
;;;736    			00 数据2低字节
;;;737    			4E CRC校验高字节
;;;738    			8B CRC校验低字节
;;;739    
;;;740    		从机应答:
;;;741    			11 从机地址
;;;742    			05 功能码
;;;743    			00 寄存器地址高字节
;;;744    			AC 寄存器地址低字节
;;;745    			FF 寄存器1高字节
;;;746    			00 寄存器1低字节
;;;747    			4E CRC校验高字节
;;;748    			8B CRC校验低字节
;;;749    
;;;750    		例子:
;;;751    		01 05 10 01 FF 00   D93A   -- D01打开
;;;752    		01 05 10 01 00 00   98CA   -- D01关闭
;;;753    
;;;754    		01 05 10 02 FF 00   293A   -- D02打开
;;;755    		01 05 10 02 00 00   68CA   -- D02关闭
;;;756    
;;;757    		01 05 10 03 FF 00   78FA   -- D03打开
;;;758    		01 05 10 03 00 00   390A   -- D03关闭
;;;759    	*/
;;;760    	uint16_t reg;
;;;761    	uint16_t value;
;;;762    
;;;763    	g_tModS.RspCode = RSP_OK;
000002  2000              MOVS     r0,#0
000004  4924              LDR      r1,|L5.152|
000006  f8810021          STRB     r0,[r1,#0x21]
;;;764    	
;;;765    	if (g_tModS.RxCount != 8)
00000a  4608              MOV      r0,r1
00000c  7f80              LDRB     r0,[r0,#0x1e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d003              BEQ      |L5.26|
;;;766    	{
;;;767    		g_tModS.RspCode = RSP_ERR_VALUE;		/* 数据值域错误 */
000012  2003              MOVS     r0,#3
000014  f8810021          STRB     r0,[r1,#0x21]
;;;768    		goto err_ret;
000018  e030              B        |L5.124|
                  |L5.26|
;;;769    	}
;;;770    
;;;771    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
00001a  481f              LDR      r0,|L5.152|
00001c  1c80              ADDS     r0,r0,#2
00001e  f7fffffe          BL       BEBufToUint16
000022  4605              MOV      r5,r0
;;;772    	value = BEBufToUint16(&g_tModS.RxBuf[4]);	/* 数据 */
000024  481c              LDR      r0,|L5.152|
000026  1d00              ADDS     r0,r0,#4
000028  f7fffffe          BL       BEBufToUint16
00002c  4604              MOV      r4,r0
;;;773    	
;;;774    	if (value != 0 && value != 1)
00002e  b134              CBZ      r4,|L5.62|
000030  2c01              CMP      r4,#1
000032  d004              BEQ      |L5.62|
;;;775    	{
;;;776    		g_tModS.RspCode = RSP_ERR_VALUE;		/* 数据值域错误 */
000034  2003              MOVS     r0,#3
000036  4918              LDR      r1,|L5.152|
000038  f8810021          STRB     r0,[r1,#0x21]
;;;777    		goto err_ret;
00003c  e01e              B        |L5.124|
                  |L5.62|
;;;778    	}
;;;779    	
;;;780    	if (reg == REG_D01)
00003e  f2401001          MOV      r0,#0x101
000042  4285              CMP      r5,r0
000044  d102              BNE      |L5.76|
;;;781    	{
;;;782    		g_tVar.D01 = value;
000046  4815              LDR      r0,|L5.156|
000048  80c4              STRH     r4,[r0,#6]
00004a  e016              B        |L5.122|
                  |L5.76|
;;;783    	}
;;;784    	else if (reg == REG_D02)
00004c  f5b57f81          CMP      r5,#0x102
000050  d102              BNE      |L5.88|
;;;785    	{
;;;786    		g_tVar.D02 = value;
000052  4812              LDR      r0,|L5.156|
000054  8104              STRH     r4,[r0,#8]
000056  e010              B        |L5.122|
                  |L5.88|
;;;787    	}
;;;788    	else if (reg == REG_D03)
000058  f2401003          MOV      r0,#0x103
00005c  4285              CMP      r5,r0
00005e  d102              BNE      |L5.102|
;;;789    	{
;;;790    		g_tVar.D03 = value;
000060  480e              LDR      r0,|L5.156|
000062  8144              STRH     r4,[r0,#0xa]
000064  e009              B        |L5.122|
                  |L5.102|
;;;791    	}
;;;792    	else if (reg == REG_D04)
000066  f5b57f82          CMP      r5,#0x104
00006a  d102              BNE      |L5.114|
;;;793    	{
;;;794    		g_tVar.D04 = value;
00006c  480b              LDR      r0,|L5.156|
00006e  8184              STRH     r4,[r0,#0xc]
000070  e003              B        |L5.122|
                  |L5.114|
;;;795    	}
;;;796    	else
;;;797    	{
;;;798    		g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
000072  2002              MOVS     r0,#2
000074  4908              LDR      r1,|L5.152|
000076  f8810021          STRB     r0,[r1,#0x21]
                  |L5.122|
;;;799    	}
;;;800    err_ret:
00007a  bf00              NOP      
                  |L5.124|
;;;801    	if (g_tModS.RspCode == RSP_OK)				/* 正确应答 */
00007c  4806              LDR      r0,|L5.152|
00007e  f8900021          LDRB     r0,[r0,#0x21]  ; g_tModS
000082  b910              CBNZ     r0,|L5.138|
;;;802    	{
;;;803    		MODS_SendAckOk();
000084  f7fffffe          BL       MODS_SendAckOk
000088  e004              B        |L5.148|
                  |L5.138|
;;;804    	}
;;;805    	else
;;;806    	{
;;;807    		MODS_SendAckErr(g_tModS.RspCode);		/* 告诉主机命令错误 */
00008a  4903              LDR      r1,|L5.152|
00008c  f8910021          LDRB     r0,[r1,#0x21]  ; g_tModS
000090  f7fffffe          BL       MODS_SendAckErr
                  |L5.148|
;;;808    	}
;;;809    }
000094  bd70              POP      {r4-r6,pc}
;;;810    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      g_tModS
                  |L5.156|
                          DCD      g_tVar

                          AREA ||i.MODS_06H||, CODE, READONLY, ALIGN=2

                  MODS_06H PROC
;;;818    */
;;;819    static void MODS_06H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;820    {
;;;821    
;;;822    	/*
;;;823    		写保持寄存器。注意06指令只能操作单个保持寄存器，16指令可以设置单个或多个保持寄存器
;;;824    
;;;825    		主机发送:
;;;826    			11 从机地址
;;;827    			06 功能码
;;;828    			00 寄存器地址高字节
;;;829    			01 寄存器地址低字节
;;;830    			00 数据1高字节
;;;831    			01 数据1低字节
;;;832    			9A CRC校验高字节
;;;833    			9B CRC校验低字节
;;;834    
;;;835    		从机响应:
;;;836    			11 从机地址
;;;837    			06 功能码
;;;838    			00 寄存器地址高字节
;;;839    			01 寄存器地址低字节
;;;840    			00 数据1高字节
;;;841    			01 数据1低字节
;;;842    			1B CRC校验高字节
;;;843    			5A	CRC校验低字节
;;;844    
;;;845    		例子:
;;;846    			01 06 30 06 00 25  A710    ---- 触发电流设置为 2.5
;;;847    			01 06 30 06 00 10  6707    ---- 触发电流设置为 1.0
;;;848    
;;;849    
;;;850    			01 06 30 1B 00 00  F6CD    ---- SMA 滤波系数 = 0 关闭滤波
;;;851    			01 06 30 1B 00 01  370D    ---- SMA 滤波系数 = 1
;;;852    			01 06 30 1B 00 02  770C    ---- SMA 滤波系数 = 2
;;;853    			01 06 30 1B 00 05  36CE    ---- SMA 滤波系数 = 5
;;;854    
;;;855    			01 06 30 07 00 01  F6CB    ---- 测试模式修改为 T1
;;;856    			01 06 30 07 00 02  B6CA    ---- 测试模式修改为 T2
;;;857    
;;;858    			01 06 31 00 00 00  8736    ---- 擦除浪涌记录区
;;;859    			01 06 31 01 00 00  D6F6    ---- 擦除告警记录区
;;;860    
;;;861    */
;;;862    
;;;863    	uint16_t reg;
;;;864    	uint16_t value;
;;;865    
;;;866    	g_tModS.RspCode = RSP_OK;
000002  2000              MOVS     r0,#0
000004  4916              LDR      r1,|L6.96|
000006  f8810021          STRB     r0,[r1,#0x21]
;;;867    
;;;868    	if (g_tModS.RxCount != 8)
00000a  4608              MOV      r0,r1
00000c  7f80              LDRB     r0,[r0,#0x1e]  ; g_tModS
00000e  2808              CMP      r0,#8
000010  d003              BEQ      |L6.26|
;;;869    	{
;;;870    		g_tModS.RspCode = RSP_ERR_VALUE;		/* 数据值域错误 */
000012  2003              MOVS     r0,#3
000014  f8810021          STRB     r0,[r1,#0x21]
;;;871    		goto err_ret;
000018  e014              B        |L6.68|
                  |L6.26|
;;;872    	}
;;;873    
;;;874    	reg = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
00001a  4811              LDR      r0,|L6.96|
00001c  1c80              ADDS     r0,r0,#2
00001e  f7fffffe          BL       BEBufToUint16
000022  4605              MOV      r5,r0
;;;875    	value = BEBufToUint16(&g_tModS.RxBuf[4]);	/* 寄存器值 */
000024  480e              LDR      r0,|L6.96|
000026  1d00              ADDS     r0,r0,#4
000028  f7fffffe          BL       BEBufToUint16
00002c  4604              MOV      r4,r0
;;;876    
;;;877    	if (MODS_WriteRegValue(reg, value) == 1)	/* 该函数会把写入的值存入寄存器 */
00002e  4621              MOV      r1,r4
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       MODS_WriteRegValue
000036  2801              CMP      r0,#1
000038  d003              BEQ      |L6.66|
;;;878    	{
;;;879    		;
;;;880    	}
;;;881    	else
;;;882    	{
;;;883    		g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
00003a  2002              MOVS     r0,#2
00003c  4908              LDR      r1,|L6.96|
00003e  f8810021          STRB     r0,[r1,#0x21]
                  |L6.66|
;;;884    	}
;;;885    
;;;886    err_ret:
000042  bf00              NOP      
                  |L6.68|
;;;887    	if (g_tModS.RspCode == RSP_OK)				/* 正确应答 */
000044  4806              LDR      r0,|L6.96|
000046  f8900021          LDRB     r0,[r0,#0x21]  ; g_tModS
00004a  b910              CBNZ     r0,|L6.82|
;;;888    	{
;;;889    		MODS_SendAckOk();
00004c  f7fffffe          BL       MODS_SendAckOk
000050  e004              B        |L6.92|
                  |L6.82|
;;;890    	}
;;;891    	else
;;;892    	{
;;;893    		MODS_SendAckErr(g_tModS.RspCode);		/* 告诉主机命令错误 */
000052  4903              LDR      r1,|L6.96|
000054  f8910021          LDRB     r0,[r1,#0x21]  ; g_tModS
000058  f7fffffe          BL       MODS_SendAckErr
                  |L6.92|
;;;894    	}
;;;895    }
00005c  bd70              POP      {r4-r6,pc}
;;;896    
                          ENDP

00005e  0000              DCW      0x0000
                  |L6.96|
                          DCD      g_tModS

                          AREA ||i.MODS_10H||, CODE, READONLY, ALIGN=2

                  MODS_10H PROC
;;;904    */
;;;905    static void MODS_10H(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;906    {
;;;907    	/*
;;;908    		从机地址为11H。保持寄存器的其实地址为0001H，寄存器的结束地址为0002H。总共访问2个寄存器。
;;;909    		保持寄存器0001H的内容为000AH，保持寄存器0002H的内容为0102H。
;;;910    
;;;911    		主机发送:
;;;912    			11 从机地址
;;;913    			10 功能码
;;;914    			00 寄存器起始地址高字节
;;;915    			01 寄存器起始地址低字节
;;;916    			00 寄存器数量高字节
;;;917    			02 寄存器数量低字节
;;;918    			04 字节数
;;;919    			00 数据1高字节
;;;920    			0A 数据1低字节
;;;921    			01 数据2高字节
;;;922    			02 数据2低字节
;;;923    			C6 CRC校验高字节
;;;924    			F0 CRC校验低字节
;;;925    
;;;926    		从机响应:
;;;927    			11 从机地址
;;;928    			06 功能码
;;;929    			00 寄存器地址高字节
;;;930    			01 寄存器地址低字节
;;;931    			00 数据1高字节
;;;932    			01 数据1低字节
;;;933    			1B CRC校验高字节
;;;934    			5A	CRC校验低字节
;;;935    
;;;936    		例子:
;;;937    			01 10 30 00 00 06 0C  07 DE  00 0A  00 01  00 08  00 0C  00 00     389A    ---- 写时钟 2014-10-01 08:12:00
;;;938    			01 10 30 00 00 06 0C  07 DF  00 01  00 1F  00 17  00 3B  00 39     5549    ---- 写时钟 2015-01-31 23:59:57
;;;939    
;;;940    	*/
;;;941    	uint16_t reg_addr;
;;;942    	uint16_t reg_num;
;;;943    	uint8_t byte_num;
;;;944    	uint8_t i;
;;;945    	uint16_t value;
;;;946    	
;;;947    	g_tModS.RspCode = RSP_OK;
000004  2000              MOVS     r0,#0
000006  4920              LDR      r1,|L7.136|
000008  f8810021          STRB     r0,[r1,#0x21]
;;;948    
;;;949    	if (g_tModS.RxCount < 11)
00000c  4608              MOV      r0,r1
00000e  7f80              LDRB     r0,[r0,#0x1e]  ; g_tModS
000010  280b              CMP      r0,#0xb
000012  da03              BGE      |L7.28|
;;;950    	{
;;;951    		g_tModS.RspCode = RSP_ERR_VALUE;			/* 数据值域错误 */
000014  2003              MOVS     r0,#3
000016  f8810021          STRB     r0,[r1,#0x21]
;;;952    		goto err_ret;
00001a  e026              B        |L7.106|
                  |L7.28|
;;;953    	}
;;;954    
;;;955    	reg_addr = BEBufToUint16(&g_tModS.RxBuf[2]); 	/* 寄存器号 */
00001c  481a              LDR      r0,|L7.136|
00001e  1c80              ADDS     r0,r0,#2
000020  f7fffffe          BL       BEBufToUint16
000024  4606              MOV      r6,r0
;;;956    	reg_num = BEBufToUint16(&g_tModS.RxBuf[4]);		/* 寄存器个数 */
000026  4818              LDR      r0,|L7.136|
000028  1d00              ADDS     r0,r0,#4
00002a  f7fffffe          BL       BEBufToUint16
00002e  4605              MOV      r5,r0
;;;957    	byte_num = g_tModS.RxBuf[6];					/* 后面的数据体字节数 */
000030  4815              LDR      r0,|L7.136|
000032  7987              LDRB     r7,[r0,#6]  ; g_tModS
;;;958    
;;;959    	if (byte_num != 2 * reg_num)
;;;960    	{
;;;961    		;
;;;962    	}
;;;963    	
;;;964    	for (i = 0; i < reg_num; i++)
000034  2400              MOVS     r4,#0
000036  e014              B        |L7.98|
                  |L7.56|
;;;965    	{
;;;966    		value = BEBufToUint16(&g_tModS.RxBuf[7 + 2 * i]);	/* 寄存器值 */
000038  0061              LSLS     r1,r4,#1
00003a  1dc9              ADDS     r1,r1,#7
00003c  4a12              LDR      r2,|L7.136|
00003e  1888              ADDS     r0,r1,r2
000040  f7fffffe          BL       BEBufToUint16
000044  4680              MOV      r8,r0
;;;967    
;;;968    		if (MODS_WriteRegValue(reg_addr + i, value) == 1)
000046  1931              ADDS     r1,r6,r4
000048  b288              UXTH     r0,r1
00004a  4641              MOV      r1,r8
00004c  f7fffffe          BL       MODS_WriteRegValue
000050  2801              CMP      r0,#1
000052  d004              BEQ      |L7.94|
;;;969    		{
;;;970    			;
;;;971    		}
;;;972    		else
;;;973    		{
;;;974    			g_tModS.RspCode = RSP_ERR_REG_ADDR;		/* 寄存器地址错误 */
000054  2002              MOVS     r0,#2
000056  490c              LDR      r1,|L7.136|
000058  f8810021          STRB     r0,[r1,#0x21]
;;;975    			break;
00005c  e003              B        |L7.102|
                  |L7.94|
00005e  1c60              ADDS     r0,r4,#1              ;964
000060  b2c4              UXTB     r4,r0                 ;964
                  |L7.98|
000062  42ac              CMP      r4,r5                 ;964
000064  dbe8              BLT      |L7.56|
                  |L7.102|
000066  bf00              NOP      
;;;976    		}
;;;977    	}
;;;978    
;;;979    err_ret:
000068  bf00              NOP      
                  |L7.106|
;;;980    	if (g_tModS.RspCode == RSP_OK)					/* 正确应答 */
00006a  4807              LDR      r0,|L7.136|
00006c  f8900021          LDRB     r0,[r0,#0x21]  ; g_tModS
000070  b910              CBNZ     r0,|L7.120|
;;;981    	{
;;;982    		MODS_SendAckOk();
000072  f7fffffe          BL       MODS_SendAckOk
000076  e004              B        |L7.130|
                  |L7.120|
;;;983    	}
;;;984    	else
;;;985    	{
;;;986    		MODS_SendAckErr(g_tModS.RspCode);			/* 告诉主机命令错误 */
000078  4903              LDR      r1,|L7.136|
00007a  f8910021          LDRB     r0,[r1,#0x21]  ; g_tModS
00007e  f7fffffe          BL       MODS_SendAckErr
                  |L7.130|
;;;987    	}
;;;988    }
000082  e8bd81f0          POP      {r4-r8,pc}
;;;989    
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
                          DCD      g_tModS

                          AREA ||i.MODS_AnalyzeApp||, CODE, READONLY, ALIGN=2

                  MODS_AnalyzeApp PROC
;;;214    */
;;;215    static void MODS_AnalyzeApp(void)
000000  b510              PUSH     {r4,lr}
;;;216    {
;;;217    	switch (g_tModS.RxBuf[1])				/* 第2个字节 功能码 */
000002  4827              LDR      r0,|L8.160|
000004  7840              LDRB     r0,[r0,#1]  ; g_tModS
000006  2804              CMP      r0,#4
000008  d023              BEQ      |L8.82|
00000a  dc06              BGT      |L8.26|
00000c  2801              CMP      r0,#1
00000e  d00b              BEQ      |L8.40|
000010  2802              CMP      r0,#2
000012  d010              BEQ      |L8.54|
000014  2803              CMP      r0,#3
000016  d138              BNE      |L8.138|
000018  e014              B        |L8.68|
                  |L8.26|
00001a  2805              CMP      r0,#5
00001c  d020              BEQ      |L8.96|
00001e  2806              CMP      r0,#6
000020  d025              BEQ      |L8.110|
000022  2810              CMP      r0,#0x10
000024  d131              BNE      |L8.138|
000026  e029              B        |L8.124|
                  |L8.40|
;;;218    	{
;;;219    		case 0x01:							/* 读取线圈状态（此例程用led代替）*/
;;;220    			MODS_01H();
000028  f7fffffe          BL       MODS_01H
;;;221    			bsp_PutMsg(MSG_MODS_01H, 0);	/* 发送消息,主程序处理 */
00002c  2100              MOVS     r1,#0
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       bsp_PutMsg
;;;222    			break;
000034  e032              B        |L8.156|
                  |L8.54|
;;;223    
;;;224    		case 0x02:							/* 读取输入状态（按键状态）*/
;;;225    			MODS_02H();
000036  f7fffffe          BL       MODS_02H
;;;226    			bsp_PutMsg(MSG_MODS_02H, 0);
00003a  2100              MOVS     r1,#0
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       bsp_PutMsg
;;;227    			break;
000042  e02b              B        |L8.156|
                  |L8.68|
;;;228    		
;;;229    		case 0x03:							/* 读取保持寄存器（此例程存在g_tVar中）*/
;;;230    			MODS_03H();
000044  f7fffffe          BL       MODS_03H
;;;231    			bsp_PutMsg(MSG_MODS_03H, 0);
000048  2100              MOVS     r1,#0
00004a  2003              MOVS     r0,#3
00004c  f7fffffe          BL       bsp_PutMsg
;;;232    			break;
000050  e024              B        |L8.156|
                  |L8.82|
;;;233    		
;;;234    		case 0x04:							/* 读取输入寄存器（ADC的值）*/
;;;235    			MODS_04H();
000052  f7fffffe          BL       MODS_04H
;;;236    			bsp_PutMsg(MSG_MODS_04H, 0);
000056  2100              MOVS     r1,#0
000058  2004              MOVS     r0,#4
00005a  f7fffffe          BL       bsp_PutMsg
;;;237    			break;
00005e  e01d              B        |L8.156|
                  |L8.96|
;;;238    		
;;;239    		case 0x05:							/* 强制单线圈（设置led）*/
;;;240    			MODS_05H();
000060  f7fffffe          BL       MODS_05H
;;;241    			bsp_PutMsg(MSG_MODS_05H, 0);
000064  2100              MOVS     r1,#0
000066  2005              MOVS     r0,#5
000068  f7fffffe          BL       bsp_PutMsg
;;;242    			break;
00006c  e016              B        |L8.156|
                  |L8.110|
;;;243    		
;;;244    		case 0x06:							/* 写单个保存寄存器（此例程改写g_tVar中的参数）*/
;;;245    			MODS_06H();	
00006e  f7fffffe          BL       MODS_06H
;;;246    			bsp_PutMsg(MSG_MODS_06H, 0);
000072  2100              MOVS     r1,#0
000074  2006              MOVS     r0,#6
000076  f7fffffe          BL       bsp_PutMsg
;;;247    			break;
00007a  e00f              B        |L8.156|
                  |L8.124|
;;;248    			
;;;249    		case 0x10:							/* 写多个保存寄存器（此例程存在g_tVar中的参数）*/
;;;250    			MODS_10H();
00007c  f7fffffe          BL       MODS_10H
;;;251    			bsp_PutMsg(MSG_MODS_10H, 0);
000080  2100              MOVS     r1,#0
000082  2007              MOVS     r0,#7
000084  f7fffffe          BL       bsp_PutMsg
;;;252    			break;
000088  e008              B        |L8.156|
                  |L8.138|
;;;253    		
;;;254    		default:
;;;255    			g_tModS.RspCode = RSP_ERR_CMD;
00008a  2001              MOVS     r0,#1
00008c  4904              LDR      r1,|L8.160|
00008e  f8810021          STRB     r0,[r1,#0x21]
;;;256    			MODS_SendAckErr(g_tModS.RspCode);	/* 告诉主机命令错误 */
000092  f8910021          LDRB     r0,[r1,#0x21]  ; g_tModS
000096  f7fffffe          BL       MODS_SendAckErr
;;;257    			break;
00009a  bf00              NOP      
                  |L8.156|
00009c  bf00              NOP                            ;222
;;;258    	}
;;;259    }
00009e  bd10              POP      {r4,pc}
;;;260    
                          ENDP

                  |L8.160|
                          DCD      g_tModS

                          AREA ||i.MODS_Poll||, CODE, READONLY, ALIGN=2

                  MODS_Poll PROC
;;;48     */
;;;49     void MODS_Poll(void)
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
;;;51     	uint16_t addr;
;;;52     	uint16_t crc1;
;;;53     	/* 超过3.5个字符时间后执行MODH_RxTimeOut()函数。全局变量 g_rtu_timeout = 1; 通知主程序开始解码 */
;;;54     	if (g_mods_timeout == 0)	
000002  4812              LDR      r0,|L9.76|
000004  7800              LDRB     r0,[r0,#0]  ; g_mods_timeout
000006  b900              CBNZ     r0,|L9.10|
                  |L9.8|
;;;55     	{
;;;56     		return;								/* 没有超时，继续接收。不要清零 g_tModS.RxCount */
;;;57     	}
;;;58     	
;;;59     	g_mods_timeout = 0;	 					/* 清标志 */
;;;60     
;;;61     	if (g_tModS.RxCount < 4)				/* 接收到的数据小于4个字节就认为错误 */
;;;62     	{
;;;63     		goto err_ret;
;;;64     	}
;;;65     
;;;66     	/* 计算CRC校验和 */
;;;67     	crc1 = CRC16_Modbus(g_tModS.RxBuf, g_tModS.RxCount);
;;;68     	if (crc1 != 0)
;;;69     	{
;;;70     		goto err_ret;
;;;71     	}
;;;72     
;;;73     	/* 站地址 (1字节） */
;;;74     	addr = g_tModS.RxBuf[0];				/* 第1字节 站号 */
;;;75     	if (addr != SADDR485)		 			/* 判断主机发送的命令地址是否符合 */
;;;76     	{
;;;77     		goto err_ret;
;;;78     	}
;;;79     
;;;80     	/* 分析应用层协议 */
;;;81     	MODS_AnalyzeApp();						
;;;82     	bsp_LedToggle(2); //MODBUS 通讯一次 闪烁一次D5
;;;83     err_ret:
;;;84     #if 0										/* 此部分为了串口打印结果,实际运用中可不要 */
;;;85     	g_tPrint.Rxlen = g_tModS.RxCount;
;;;86     	memcpy(g_tPrint.RxBuf, g_tModS.RxBuf, g_tModS.RxCount);
;;;87     #endif
;;;88     	
;;;89     	g_tModS.RxCount = 0;					/* 必须清零计数器，方便下次帧同步 */
;;;90     }
000008  bd70              POP      {r4-r6,pc}
                  |L9.10|
00000a  2000              MOVS     r0,#0                 ;59
00000c  490f              LDR      r1,|L9.76|
00000e  7008              STRB     r0,[r1,#0]            ;59
000010  480f              LDR      r0,|L9.80|
000012  7f80              LDRB     r0,[r0,#0x1e]         ;61  ; g_tModS
000014  2804              CMP      r0,#4                 ;61
000016  da00              BGE      |L9.26|
000018  e013              B        |L9.66|
                  |L9.26|
00001a  480d              LDR      r0,|L9.80|
00001c  7f81              LDRB     r1,[r0,#0x1e]         ;67  ; g_tModS
00001e  f7fffffe          BL       CRC16_Modbus
000022  4604              MOV      r4,r0                 ;67
000024  b104              CBZ      r4,|L9.40|
000026  e00c              B        |L9.66|
                  |L9.40|
000028  4809              LDR      r0,|L9.80|
00002a  7805              LDRB     r5,[r0,#0]            ;74  ; g_tModS
00002c  4809              LDR      r0,|L9.84|
00002e  7800              LDRB     r0,[r0,#0]            ;75  ; SADDR485
000030  4285              CMP      r5,r0                 ;75
000032  d000              BEQ      |L9.54|
000034  e005              B        |L9.66|
                  |L9.54|
000036  f7fffffe          BL       MODS_AnalyzeApp
00003a  2002              MOVS     r0,#2                 ;82
00003c  f7fffffe          BL       bsp_LedToggle
000040  bf00              NOP                            ;83
                  |L9.66|
000042  2000              MOVS     r0,#0                 ;89
000044  4902              LDR      r1,|L9.80|
000046  7788              STRB     r0,[r1,#0x1e]         ;89
000048  bf00              NOP      
00004a  e7dd              B        |L9.8|
;;;91     
                          ENDP

                  |L9.76|
                          DCD      g_mods_timeout
                  |L9.80|
                          DCD      g_tModS
                  |L9.84|
                          DCD      SADDR485

                          AREA ||i.MODS_ReadRegValue||, CODE, READONLY, ALIGN=2

                  MODS_ReadRegValue PROC
;;;462    */
;;;463    static uint8_t MODS_ReadRegValue(uint16_t reg_addr, uint8_t *reg_value)
000000  4603              MOV      r3,r0
;;;464    {
000002  460a              MOV      r2,r1
;;;465    	uint16_t value;
;;;466    	
;;;467    	switch (reg_addr)									/* 判断寄存器地址 */
000004  b113              CBZ      r3,|L10.12|
000006  2b01              CMP      r3,#1
000008  d106              BNE      |L10.24|
00000a  e002              B        |L10.18|
                  |L10.12|
;;;468    	{
;;;469    		case SLAVE_REG_P01:
;;;470    			value =	g_tVar.P01;	
00000c  4806              LDR      r0,|L10.40|
00000e  8801              LDRH     r1,[r0,#0]  ; g_tVar
;;;471    			break;
000010  e004              B        |L10.28|
                  |L10.18|
;;;472    
;;;473    		case SLAVE_REG_P02:
;;;474    			value =	g_tVar.P02;							/* 将寄存器值读出 */
000012  4805              LDR      r0,|L10.40|
000014  8841              LDRH     r1,[r0,#2]  ; g_tVar
;;;475    			break;
000016  e001              B        |L10.28|
                  |L10.24|
;;;476    	
;;;477    		default:
;;;478    			return 0;									/* 参数异常，返回 0 */
000018  2000              MOVS     r0,#0
                  |L10.26|
;;;479    	}
;;;480    
;;;481    	reg_value[0] = value >> 8;
;;;482    	reg_value[1] = value;
;;;483    
;;;484    	return 1;											/* 读取成功 */
;;;485    }
00001a  4770              BX       lr
                  |L10.28|
00001c  bf00              NOP                            ;471
00001e  1208              ASRS     r0,r1,#8              ;481
000020  7010              STRB     r0,[r2,#0]            ;481
000022  7051              STRB     r1,[r2,#1]            ;482
000024  2001              MOVS     r0,#1                 ;484
000026  e7f8              B        |L10.26|
;;;486    
                          ENDP

                  |L10.40|
                          DCD      g_tVar

                          AREA ||i.MODS_ReciveNew||, CODE, READONLY, ALIGN=2

                  MODS_ReciveNew PROC
;;;99     */
;;;100    void MODS_ReciveNew(uint8_t _byte)
000000  b570              PUSH     {r4-r6,lr}
;;;101    {
000002  4604              MOV      r4,r0
;;;102    	/*
;;;103    		3.5个字符的时间间隔，只是用在RTU模式下面，因为RTU模式没有开始符和结束符，
;;;104    		两个数据包之间只能靠时间间隔来区分，Modbus定义在不同的波特率下，间隔时间是不一样的，
;;;105    		所以就是3.5个字符的时间，波特率高，这个时间间隔就小，波特率低，这个时间间隔相应就大
;;;106    
;;;107    		4800  = 7.297ms
;;;108    		9600  = 3.646ms
;;;109    		19200  = 1.771ms
;;;110    		38400  = 0.885ms
;;;111    	*/
;;;112    	uint32_t timeout;
;;;113    
;;;114    	g_mods_timeout = 0;
000004  2000              MOVS     r0,#0
000006  490b              LDR      r1,|L11.52|
000008  7008              STRB     r0,[r1,#0]
;;;115    	
;;;116    //	timeout = 35000000 / SBAUD485;			/* 计算超时时间，单位us 35000000*/
;;;117        timeout = 45000000 / SBAUD485;			/* 计算超时时间，单位us 35000000*/
00000a  f241254f          MOV      r5,#0x124f
;;;118    	
;;;119    	/* 硬件定时中断，定时精度us 硬件定时器1用于ADC, 定时器2用于Modbus */
;;;120    	bsp_StartHardTimer(1, timeout, (void *)MODS_RxTimeOut);
00000e  4a0a              LDR      r2,|L11.56|
000010  4629              MOV      r1,r5
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       bsp_StartHardTimer
;;;121    
;;;122    	if (g_tModS.RxCount < S_RX_BUF_SIZE)
000018  4808              LDR      r0,|L11.60|
00001a  7f80              LDRB     r0,[r0,#0x1e]  ; g_tModS
00001c  281e              CMP      r0,#0x1e
00001e  da07              BGE      |L11.48|
;;;123    	{
;;;124    		g_tModS.RxBuf[g_tModS.RxCount++] = _byte;
000020  4806              LDR      r0,|L11.60|
000022  7f81              LDRB     r1,[r0,#0x1e]  ; g_tModS
000024  7f80              LDRB     r0,[r0,#0x1e]  ; g_tModS
000026  1c40              ADDS     r0,r0,#1
000028  4a04              LDR      r2,|L11.60|
00002a  7790              STRB     r0,[r2,#0x1e]
00002c  4610              MOV      r0,r2
00002e  5444              STRB     r4,[r0,r1]
                  |L11.48|
;;;125    	}
;;;126    }
000030  bd70              POP      {r4-r6,pc}
;;;127    
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      g_mods_timeout
                  |L11.56|
                          DCD      MODS_RxTimeOut
                  |L11.60|
                          DCD      g_tModS

                          AREA ||i.MODS_RxTimeOut||, CODE, READONLY, ALIGN=2

                  MODS_RxTimeOut PROC
;;;135    */
;;;136    static void MODS_RxTimeOut(void)
000000  2001              MOVS     r0,#1
;;;137    {
;;;138    	g_mods_timeout = 1;
000002  4901              LDR      r1,|L12.8|
000004  7008              STRB     r0,[r1,#0]
;;;139    }
000006  4770              BX       lr
;;;140    
                          ENDP

                  |L12.8|
                          DCD      g_mods_timeout

                          AREA ||i.MODS_SendAckErr||, CODE, READONLY, ALIGN=2

                  MODS_SendAckErr PROC
;;;175    */
;;;176    static void MODS_SendAckErr(uint8_t _ucErrCode)
000000  b538              PUSH     {r3-r5,lr}
;;;177    {
000002  4604              MOV      r4,r0
;;;178    	uint8_t txbuf[3];
;;;179    
;;;180    	txbuf[0] = g_tModS.RxBuf[0];					/* 485地址 */
000004  4808              LDR      r0,|L13.40|
000006  7800              LDRB     r0,[r0,#0]  ; g_tModS
000008  f88d0000          STRB     r0,[sp,#0]
;;;181    	txbuf[1] = g_tModS.RxBuf[1] | 0x80;				/* 异常的功能码 */
00000c  4806              LDR      r0,|L13.40|
00000e  7840              LDRB     r0,[r0,#1]  ; g_tModS
000010  f0400080          ORR      r0,r0,#0x80
000014  f88d0001          STRB     r0,[sp,#1]
;;;182    	txbuf[2] = _ucErrCode;							/* 错误代码(01,02,03,04) */
000018  f88d4002          STRB     r4,[sp,#2]
;;;183    
;;;184    	MODS_SendWithCRC(txbuf, 3);
00001c  2103              MOVS     r1,#3
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       MODS_SendWithCRC
;;;185    }
000024  bd38              POP      {r3-r5,pc}
;;;186    
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      g_tModS

                          AREA ||i.MODS_SendAckOk||, CODE, READONLY, ALIGN=2

                  MODS_SendAckOk PROC
;;;194    */
;;;195    static void MODS_SendAckOk(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;196    {
;;;197    	uint8_t txbuf[6];
;;;198    	uint8_t i;
;;;199    
;;;200    	for (i = 0; i < 6; i++)
000002  2400              MOVS     r4,#0
000004  e005              B        |L14.18|
                  |L14.6|
;;;201    	{
;;;202    		txbuf[i] = g_tModS.RxBuf[i];
000006  4806              LDR      r0,|L14.32|
000008  5d00              LDRB     r0,[r0,r4]
00000a  f80d0004          STRB     r0,[sp,r4]
00000e  1c60              ADDS     r0,r4,#1              ;200
000010  b2c4              UXTB     r4,r0                 ;200
                  |L14.18|
000012  2c06              CMP      r4,#6                 ;200
000014  dbf7              BLT      |L14.6|
;;;203    	}
;;;204    	MODS_SendWithCRC(txbuf, 6);
000016  2106              MOVS     r1,#6
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       MODS_SendWithCRC
;;;205    }
00001e  bd1c              POP      {r2-r4,pc}
;;;206    
                          ENDP

                  |L14.32|
                          DCD      g_tModS

                          AREA ||i.MODS_SendWithCRC||, CODE, READONLY, ALIGN=1

                  MODS_SendWithCRC PROC
;;;149    */
;;;150    static void MODS_SendWithCRC(uint8_t *_pBuf, uint8_t _ucLen)
000000  b570              PUSH     {r4-r6,lr}
;;;151    {
000002  b0a0              SUB      sp,sp,#0x80
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;152    	uint16_t crc;
;;;153    	uint8_t buf[S_TX_BUF_SIZE];
;;;154    
;;;155    	memcpy(buf, _pBuf, _ucLen);
000008  4622              MOV      r2,r4
00000a  4629              MOV      r1,r5
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy
;;;156    	crc = CRC16_Modbus(_pBuf, _ucLen);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       CRC16_Modbus
00001a  4606              MOV      r6,r0
;;;157    	buf[_ucLen++] = crc >> 8;
00001c  1232              ASRS     r2,r6,#8
00001e  4620              MOV      r0,r4
000020  1c61              ADDS     r1,r4,#1
000022  b2cc              UXTB     r4,r1
000024  f80d2000          STRB     r2,[sp,r0]
;;;158    	buf[_ucLen++] = crc;
000028  b2f2              UXTB     r2,r6
00002a  4620              MOV      r0,r4
00002c  1c61              ADDS     r1,r4,#1
00002e  b2cc              UXTB     r4,r1
000030  f80d2000          STRB     r2,[sp,r0]
;;;159    
;;;160    	RS485_SendBuf(buf, _ucLen);
000034  4621              MOV      r1,r4
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       RS485_SendBuf
;;;161    	
;;;162    #if 0									/* 此部分为了串口打印结果,实际运用中可不要 */
;;;163    	g_tPrint.Txlen = _ucLen;
;;;164    	memcpy(g_tPrint.TxBuf, buf, _ucLen);
;;;165    #endif
;;;166    }
00003c  b020              ADD      sp,sp,#0x80
00003e  bd70              POP      {r4-r6,pc}
;;;167    
                          ENDP


                          AREA ||i.MODS_WriteRegValue||, CODE, READONLY, ALIGN=2

                  MODS_WriteRegValue PROC
;;;495    */
;;;496    static uint8_t MODS_WriteRegValue(uint16_t reg_addr, uint16_t reg_value)
000000  4602              MOV      r2,r0
;;;497    {
;;;498    	switch (reg_addr)							/* 判断寄存器地址 */
000002  b112              CBZ      r2,|L16.10|
000004  2a01              CMP      r2,#1
000006  d106              BNE      |L16.22|
000008  e002              B        |L16.16|
                  |L16.10|
;;;499    	{	
;;;500    		case SLAVE_REG_P01:
;;;501    			g_tVar.P01 = reg_value;				/* 将值写入保存寄存器 */
00000a  4805              LDR      r0,|L16.32|
00000c  8001              STRH     r1,[r0,#0]
;;;502    			break;
00000e  e004              B        |L16.26|
                  |L16.16|
;;;503    		
;;;504    		case SLAVE_REG_P02:
;;;505    			g_tVar.P02 = reg_value;				/* 将值写入保存寄存器 */
000010  4803              LDR      r0,|L16.32|
000012  8041              STRH     r1,[r0,#2]
;;;506    			break;
000014  e001              B        |L16.26|
                  |L16.22|
;;;507    		
;;;508    		default:
;;;509    			return 0;		/* 参数异常，返回 0 */
000016  2000              MOVS     r0,#0
                  |L16.24|
;;;510    	}
;;;511    
;;;512    	return 1;		/* 读取成功 */
;;;513    }
000018  4770              BX       lr
                  |L16.26|
00001a  bf00              NOP                            ;502
00001c  2001              MOVS     r0,#1                 ;512
00001e  e7fb              B        |L16.24|
;;;514    
                          ENDP

                  |L16.32|
                          DCD      g_tVar

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_tModS
                          %        164
                  g_tVar
                          %        14

                          AREA ||.data||, DATA, ALIGN=0

                  g_mods_timeout
000000  00                DCB      0x00
                  SADDR485
000001  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\modbus_slave.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_modbus_slave_c_SADDR485____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_modbus_slave_c_SADDR485____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_modbus_slave_c_SADDR485____REVSH|
#line 128
|__asm___14_modbus_slave_c_SADDR485____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
