; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\modbus_host.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\modbus_host.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\User -I..\..\User\bsp\inc -I..\..\User\bsp -I..\..\User\app\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\modbus_host.crf ..\..\User\app\src\modbus_host.c]
                          THUMB

                          AREA ||i.MODH_AnalyzeApp||, CODE, READONLY, ALIGN=2

                  MODH_AnalyzeApp PROC
;;;85     */
;;;86     static void MODH_AnalyzeApp(void)
000000  b510              PUSH     {r4,lr}
;;;87     {	
;;;88     	switch (g_tModH.RxBuf[1])			/* 第2个字节 功能码 */
000002  4815              LDR      r0,|L1.88|
000004  7840              LDRB     r0,[r0,#1]  ; g_tModH
000006  2804              CMP      r0,#4
000008  d017              BEQ      |L1.58|
00000a  dc06              BGT      |L1.26|
00000c  2801              CMP      r0,#1
00000e  d00b              BEQ      |L1.40|
000010  2802              CMP      r0,#2
000012  d00c              BEQ      |L1.46|
000014  2803              CMP      r0,#3
000016  d11c              BNE      |L1.82|
000018  e00c              B        |L1.52|
                  |L1.26|
00001a  2805              CMP      r0,#5
00001c  d010              BEQ      |L1.64|
00001e  2806              CMP      r0,#6
000020  d011              BEQ      |L1.70|
000022  2810              CMP      r0,#0x10
000024  d115              BNE      |L1.82|
000026  e011              B        |L1.76|
                  |L1.40|
;;;89     	{
;;;90     		case 0x01:	/* 读取线圈状态 */
;;;91     			MODH_Read_01H();
000028  f7fffffe          BL       MODH_Read_01H
;;;92     			break;
00002c  e012              B        |L1.84|
                  |L1.46|
;;;93     
;;;94     		case 0x02:	/* 读取输入状态 */
;;;95     			MODH_Read_02H();
00002e  f7fffffe          BL       MODH_Read_02H
;;;96     			break;
000032  e00f              B        |L1.84|
                  |L1.52|
;;;97     
;;;98     		case 0x03:	/* 读取保持寄存器 在一个或多个保持寄存器中取得当前的二进制值 */
;;;99     			MODH_Read_03H();
000034  f7fffffe          BL       MODH_Read_03H
;;;100    			break;
000038  e00c              B        |L1.84|
                  |L1.58|
;;;101    
;;;102    		case 0x04:	/* 读取输入寄存器 */
;;;103    			MODH_Read_04H();
00003a  f7fffffe          BL       MODH_Read_04H
;;;104    			break;
00003e  e009              B        |L1.84|
                  |L1.64|
;;;105    
;;;106    		case 0x05:	/* 强制单线圈 */
;;;107    			MODH_Read_05H();
000040  f7fffffe          BL       MODH_Read_05H
;;;108    			break;
000044  e006              B        |L1.84|
                  |L1.70|
;;;109    
;;;110    		case 0x06:	/* 写单个寄存器 */
;;;111    			MODH_Read_06H();
000046  f7fffffe          BL       MODH_Read_06H
;;;112    			break;		
00004a  e003              B        |L1.84|
                  |L1.76|
;;;113    
;;;114    		case 0x10:	/* 写多个寄存器 */
;;;115    			MODH_Read_10H();
00004c  f7fffffe          BL       MODH_Read_10H
;;;116    			break;
000050  e000              B        |L1.84|
                  |L1.82|
;;;117    		
;;;118    		default:
;;;119    			break;
000052  bf00              NOP      
                  |L1.84|
000054  bf00              NOP                            ;92
;;;120    	}
;;;121    }
000056  bd10              POP      {r4,pc}
;;;122    
                          ENDP

                  |L1.88|
                          DCD      g_tModH

                          AREA ||i.MODH_Poll||, CODE, READONLY, ALIGN=2

                  MODH_Poll PROC
;;;368    */
;;;369    void MODH_Poll(void)
000000  b510              PUSH     {r4,lr}
;;;370    {	
;;;371    	uint16_t crc1;
;;;372    	
;;;373    	if (g_modh_timeout == 0)	/* 超过3.5个字符时间后执行MODH_RxTimeOut()函数。全局变量 g_rtu_timeout = 1 */
000002  4815              LDR      r0,|L2.88|
000004  7800              LDRB     r0,[r0,#0]  ; g_modh_timeout
000006  b900              CBNZ     r0,|L2.10|
                  |L2.8|
;;;374    	{
;;;375    		/* 没有超时，继续接收。不要清零 g_tModH.RxCount */
;;;376    		return ;
;;;377    	}
;;;378    
;;;379    	/* 收到命令
;;;380    		05 06 00 88 04 57 3B70 (8 字节)
;;;381    			05    :  数码管屏的号站，
;;;382    			06    :  指令
;;;383    			00 88 :  数码管屏的显示寄存器
;;;384    			04 57 :  数据,,,转换成 10 进制是 1111.高位在前,
;;;385    			3B70  :  二个字节 CRC 码	从05到 57的校验
;;;386    	*/
;;;387    	g_modh_timeout = 0;
;;;388    
;;;389    	if (g_tModH.RxCount < 4)
;;;390    	{
;;;391    		goto err_ret;
;;;392    	}
;;;393    
;;;394    	/* 计算CRC校验和 */
;;;395    	crc1 = CRC16_Modbus(g_tModH.RxBuf, g_tModH.RxCount);
;;;396    	if (crc1 != 0)
;;;397    	{
;;;398    		goto err_ret;
;;;399    	}
;;;400    	
;;;401    	/* 分析应用层协议 */
;;;402    	MODH_AnalyzeApp();
;;;403    
;;;404    err_ret:
;;;405    #if 1	/* 此部分为了串口打印结果,实际运用中可不要 */
;;;406    	g_tPrint.Rxlen = g_tModH.RxCount;
;;;407    	memcpy(g_tPrint.RxBuf, g_tModH.RxBuf, g_tModH.RxCount);
;;;408    #endif
;;;409    	
;;;410    	g_tModH.RxCount = 0;	/* 必须清零计数器，方便下次帧同步 */
;;;411    }
000008  bd10              POP      {r4,pc}
                  |L2.10|
00000a  2000              MOVS     r0,#0                 ;387
00000c  4912              LDR      r1,|L2.88|
00000e  7008              STRB     r0,[r1,#0]            ;387
000010  4812              LDR      r0,|L2.92|
000012  f8900040          LDRB     r0,[r0,#0x40]         ;389  ; g_tModH
000016  2804              CMP      r0,#4                 ;389
000018  da00              BGE      |L2.28|
00001a  e00a              B        |L2.50|
                  |L2.28|
00001c  480f              LDR      r0,|L2.92|
00001e  f8901040          LDRB     r1,[r0,#0x40]         ;395  ; g_tModH
000022  f7fffffe          BL       CRC16_Modbus
000026  4604              MOV      r4,r0                 ;395
000028  b104              CBZ      r4,|L2.44|
00002a  e002              B        |L2.50|
                  |L2.44|
00002c  f7fffffe          BL       MODH_AnalyzeApp
000030  bf00              NOP                            ;404
                  |L2.50|
000032  480a              LDR      r0,|L2.92|
000034  f8900040          LDRB     r0,[r0,#0x40]         ;406  ; g_tModH
000038  4909              LDR      r1,|L2.96|
00003a  7008              STRB     r0,[r1,#0]            ;406
00003c  4807              LDR      r0,|L2.92|
00003e  f8902040          LDRB     r2,[r0,#0x40]         ;407  ; g_tModH
000042  4601              MOV      r1,r0                 ;407
000044  4806              LDR      r0,|L2.96|
000046  1c40              ADDS     r0,r0,#1              ;407
000048  f7fffffe          BL       __aeabi_memcpy
00004c  2000              MOVS     r0,#0                 ;410
00004e  4903              LDR      r1,|L2.92|
000050  f8810040          STRB     r0,[r1,#0x40]         ;410
000054  bf00              NOP      
000056  e7d7              B        |L2.8|
;;;412    
                          ENDP

                  |L2.88|
                          DCD      g_modh_timeout
                  |L2.92|
                          DCD      g_tModH
                  |L2.96|
                          DCD      g_tPrint

                          AREA ||i.MODH_ReadParam_01H||, CODE, READONLY, ALIGN=2

                  MODH_ReadParam_01H PROC
;;;624    */
;;;625    uint8_t MODH_ReadParam_01H(uint16_t _reg, uint16_t _num)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;626    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;627    	int32_t time1;
;;;628    	uint8_t i;
;;;629    	
;;;630    	for (i = 0; i < NUM; i++)
000008  2600              MOVS     r6,#0
00000a  e020              B        |L3.78|
                  |L3.12|
;;;631    	{
;;;632    		MODH_Send01H (SlaveAddr, _reg, _num);		  /* 发送命令 */
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       MODH_Send01H
;;;633    		time1 = bsp_GetRunTime();	/* 记录命令发送的时刻 */
000016  f7fffffe          BL       bsp_GetRunTime
00001a  4607              MOV      r7,r0
;;;634    		
;;;635    		while (1)				/* 等待应答,超时或接收到应答则break  */
00001c  e00d              B        |L3.58|
                  |L3.30|
;;;636    		{
;;;637    			bsp_Idle();
00001e  f7fffffe          BL       bsp_Idle
;;;638    
;;;639    			if (bsp_CheckRunTime(time1) > TIMEOUT)		
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       bsp_CheckRunTime
000028  2864              CMP      r0,#0x64
00002a  dd00              BLE      |L3.46|
;;;640    			{
;;;641    				break;		/* 通信超时了 */
00002c  e006              B        |L3.60|
                  |L3.46|
;;;642    			}
;;;643    			
;;;644    			if (g_tModH.fAck01H > 0)
00002e  480e              LDR      r0,|L3.104|
000030  f89000cf          LDRB     r0,[r0,#0xcf]  ; g_tModH
000034  2800              CMP      r0,#0
000036  dd00              BLE      |L3.58|
;;;645    			{
;;;646    				break;		/* 接收到应答 */
000038  e000              B        |L3.60|
                  |L3.58|
00003a  e7f0              B        |L3.30|
                  |L3.60|
00003c  bf00              NOP                            ;641
;;;647    			}
;;;648    		}
;;;649    		
;;;650    		if (g_tModH.fAck01H > 0)
00003e  480a              LDR      r0,|L3.104|
000040  f89000cf          LDRB     r0,[r0,#0xcf]  ; g_tModH
000044  2800              CMP      r0,#0
000046  dd00              BLE      |L3.74|
;;;651    		{
;;;652    			break;			/* 循环NUM次，如果接收到命令则break循环 */
000048  e003              B        |L3.82|
                  |L3.74|
00004a  1c70              ADDS     r0,r6,#1              ;630
00004c  b2c6              UXTB     r6,r0                 ;630
                  |L3.78|
00004e  2e01              CMP      r6,#1                 ;630
000050  dbdc              BLT      |L3.12|
                  |L3.82|
000052  bf00              NOP      
;;;653    		}
;;;654    	}
;;;655    	
;;;656    	if (g_tModH.fAck01H == 0)
000054  4804              LDR      r0,|L3.104|
000056  f89000cf          LDRB     r0,[r0,#0xcf]  ; g_tModH
00005a  b910              CBNZ     r0,|L3.98|
;;;657    	{
;;;658    		return 0;
00005c  2000              MOVS     r0,#0
                  |L3.94|
;;;659    	}
;;;660    	else 
;;;661    	{
;;;662    		return 1;	/* 01H 读成功 */
;;;663    	}
;;;664    }
00005e  e8bd81f0          POP      {r4-r8,pc}
                  |L3.98|
000062  2001              MOVS     r0,#1                 ;662
000064  e7fb              B        |L3.94|
;;;665    
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
                          DCD      g_tModH

                          AREA ||i.MODH_ReadParam_02H||, CODE, READONLY, ALIGN=2

                  MODH_ReadParam_02H PROC
;;;673    */
;;;674    uint8_t MODH_ReadParam_02H(uint16_t _reg, uint16_t _num)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;675    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;676    	int32_t time1;
;;;677    	uint8_t i;
;;;678    	
;;;679    	for (i = 0; i < NUM; i++)
000008  2600              MOVS     r6,#0
00000a  e020              B        |L4.78|
                  |L4.12|
;;;680    	{
;;;681    		MODH_Send02H (SlaveAddr, _reg, _num);
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       MODH_Send02H
;;;682    		time1 = bsp_GetRunTime();	/* 记录命令发送的时刻 */
000016  f7fffffe          BL       bsp_GetRunTime
00001a  4607              MOV      r7,r0
;;;683    		
;;;684    		while (1)
00001c  e00d              B        |L4.58|
                  |L4.30|
;;;685    		{
;;;686    			bsp_Idle();
00001e  f7fffffe          BL       bsp_Idle
;;;687    
;;;688    			if (bsp_CheckRunTime(time1) > TIMEOUT)		
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       bsp_CheckRunTime
000028  2864              CMP      r0,#0x64
00002a  dd00              BLE      |L4.46|
;;;689    			{
;;;690    				break;		/* 通信超时了 */
00002c  e006              B        |L4.60|
                  |L4.46|
;;;691    			}
;;;692    			
;;;693    			if (g_tModH.fAck02H > 0)
00002e  480e              LDR      r0,|L4.104|
000030  f89000d0          LDRB     r0,[r0,#0xd0]  ; g_tModH
000034  2800              CMP      r0,#0
000036  dd00              BLE      |L4.58|
;;;694    			{
;;;695    				break;
000038  e000              B        |L4.60|
                  |L4.58|
00003a  e7f0              B        |L4.30|
                  |L4.60|
00003c  bf00              NOP                            ;690
;;;696    			}
;;;697    		}
;;;698    		
;;;699    		if (g_tModH.fAck02H > 0)
00003e  480a              LDR      r0,|L4.104|
000040  f89000d0          LDRB     r0,[r0,#0xd0]  ; g_tModH
000044  2800              CMP      r0,#0
000046  dd00              BLE      |L4.74|
;;;700    		{
;;;701    			break;
000048  e003              B        |L4.82|
                  |L4.74|
00004a  1c70              ADDS     r0,r6,#1              ;679
00004c  b2c6              UXTB     r6,r0                 ;679
                  |L4.78|
00004e  2e01              CMP      r6,#1                 ;679
000050  dbdc              BLT      |L4.12|
                  |L4.82|
000052  bf00              NOP      
;;;702    		}
;;;703    	}
;;;704    	
;;;705    	if (g_tModH.fAck02H == 0)
000054  4804              LDR      r0,|L4.104|
000056  f89000d0          LDRB     r0,[r0,#0xd0]  ; g_tModH
00005a  b910              CBNZ     r0,|L4.98|
;;;706    	{
;;;707    		return 0;
00005c  2000              MOVS     r0,#0
                  |L4.94|
;;;708    	}
;;;709    	else 
;;;710    	{
;;;711    		return 1;	/* 02H 读成功 */
;;;712    	}
;;;713    }
00005e  e8bd81f0          POP      {r4-r8,pc}
                  |L4.98|
000062  2001              MOVS     r0,#1                 ;711
000064  e7fb              B        |L4.94|
;;;714    /*
                          ENDP

000066  0000              DCW      0x0000
                  |L4.104|
                          DCD      g_tModH

                          AREA ||i.MODH_ReadParam_03H||, CODE, READONLY, ALIGN=2

                  MODH_ReadParam_03H PROC
;;;721    */
;;;722    uint8_t MODH_ReadParam_03H(uint16_t _reg, uint16_t _num)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;723    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;724    	int32_t time1;
;;;725    	uint8_t i;
;;;726    	
;;;727    	for (i = 0; i < NUM; i++)
000008  2600              MOVS     r6,#0
00000a  e020              B        |L5.78|
                  |L5.12|
;;;728    	{
;;;729    		MODH_Send03H (SlaveAddr, _reg, _num);
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       MODH_Send03H
;;;730    		time1 = bsp_GetRunTime();	/* 记录命令发送的时刻 */
000016  f7fffffe          BL       bsp_GetRunTime
00001a  4607              MOV      r7,r0
;;;731    		
;;;732    		while (1)
00001c  e00d              B        |L5.58|
                  |L5.30|
;;;733    		{
;;;734    			bsp_Idle();
00001e  f7fffffe          BL       bsp_Idle
;;;735    
;;;736    			if (bsp_CheckRunTime(time1) > TIMEOUT)		
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       bsp_CheckRunTime
000028  2864              CMP      r0,#0x64
00002a  dd00              BLE      |L5.46|
;;;737    			{
;;;738    				break;		/* 通信超时了 */
00002c  e006              B        |L5.60|
                  |L5.46|
;;;739    			}
;;;740    			
;;;741    			if (g_tModH.fAck03H > 0)
00002e  480e              LDR      r0,|L5.104|
000030  f89000d1          LDRB     r0,[r0,#0xd1]  ; g_tModH
000034  2800              CMP      r0,#0
000036  dd00              BLE      |L5.58|
;;;742    			{
;;;743    				break;
000038  e000              B        |L5.60|
                  |L5.58|
00003a  e7f0              B        |L5.30|
                  |L5.60|
00003c  bf00              NOP                            ;738
;;;744    			}
;;;745    		}
;;;746    		
;;;747    		if (g_tModH.fAck03H > 0)
00003e  480a              LDR      r0,|L5.104|
000040  f89000d1          LDRB     r0,[r0,#0xd1]  ; g_tModH
000044  2800              CMP      r0,#0
000046  dd00              BLE      |L5.74|
;;;748    		{
;;;749    			break;
000048  e003              B        |L5.82|
                  |L5.74|
00004a  1c70              ADDS     r0,r6,#1              ;727
00004c  b2c6              UXTB     r6,r0                 ;727
                  |L5.78|
00004e  2e01              CMP      r6,#1                 ;727
000050  dbdc              BLT      |L5.12|
                  |L5.82|
000052  bf00              NOP      
;;;750    		}
;;;751    	}
;;;752    	
;;;753    	if (g_tModH.fAck03H == 0)
000054  4804              LDR      r0,|L5.104|
000056  f89000d1          LDRB     r0,[r0,#0xd1]  ; g_tModH
00005a  b910              CBNZ     r0,|L5.98|
;;;754    	{
;;;755    		return 0;	/* 通信超时了 */
00005c  2000              MOVS     r0,#0
                  |L5.94|
;;;756    	}
;;;757    	else 
;;;758    	{
;;;759    		return 1;	/* 写入03H参数成功 */
;;;760    	}
;;;761    }
00005e  e8bd81f0          POP      {r4-r8,pc}
                  |L5.98|
000062  2001              MOVS     r0,#1                 ;759
000064  e7fb              B        |L5.94|
;;;762    
                          ENDP

000066  0000              DCW      0x0000
                  |L5.104|
                          DCD      g_tModH

                          AREA ||i.MODH_ReadParam_04H||, CODE, READONLY, ALIGN=2

                  MODH_ReadParam_04H PROC
;;;771    */
;;;772    uint8_t MODH_ReadParam_04H(uint16_t _reg, uint16_t _num)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;773    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;774    	int32_t time1;
;;;775    	uint8_t i;
;;;776    	
;;;777    	for (i = 0; i < NUM; i++)
000008  2600              MOVS     r6,#0
00000a  e020              B        |L6.78|
                  |L6.12|
;;;778    	{
;;;779    		MODH_Send04H (SlaveAddr, _reg, _num);
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       MODH_Send04H
;;;780    		time1 = bsp_GetRunTime();	/* 记录命令发送的时刻 */
000016  f7fffffe          BL       bsp_GetRunTime
00001a  4607              MOV      r7,r0
;;;781    		
;;;782    		while (1)
00001c  e00d              B        |L6.58|
                  |L6.30|
;;;783    		{
;;;784    			bsp_Idle();
00001e  f7fffffe          BL       bsp_Idle
;;;785    
;;;786    			if (bsp_CheckRunTime(time1) > TIMEOUT)		
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       bsp_CheckRunTime
000028  2864              CMP      r0,#0x64
00002a  dd00              BLE      |L6.46|
;;;787    			{
;;;788    				break;		/* 通信超时了 */
00002c  e006              B        |L6.60|
                  |L6.46|
;;;789    			}
;;;790    			
;;;791    			if (g_tModH.fAck04H > 0)
00002e  480e              LDR      r0,|L6.104|
000030  f89000d2          LDRB     r0,[r0,#0xd2]  ; g_tModH
000034  2800              CMP      r0,#0
000036  dd00              BLE      |L6.58|
;;;792    			{
;;;793    				break;
000038  e000              B        |L6.60|
                  |L6.58|
00003a  e7f0              B        |L6.30|
                  |L6.60|
00003c  bf00              NOP                            ;788
;;;794    			}
;;;795    		}
;;;796    		
;;;797    		if (g_tModH.fAck04H > 0)
00003e  480a              LDR      r0,|L6.104|
000040  f89000d2          LDRB     r0,[r0,#0xd2]  ; g_tModH
000044  2800              CMP      r0,#0
000046  dd00              BLE      |L6.74|
;;;798    		{
;;;799    			break;
000048  e003              B        |L6.82|
                  |L6.74|
00004a  1c70              ADDS     r0,r6,#1              ;777
00004c  b2c6              UXTB     r6,r0                 ;777
                  |L6.78|
00004e  2e01              CMP      r6,#1                 ;777
000050  dbdc              BLT      |L6.12|
                  |L6.82|
000052  bf00              NOP      
;;;800    		}
;;;801    	}
;;;802    	
;;;803    	if (g_tModH.fAck04H == 0)
000054  4804              LDR      r0,|L6.104|
000056  f89000d2          LDRB     r0,[r0,#0xd2]  ; g_tModH
00005a  b910              CBNZ     r0,|L6.98|
;;;804    	{
;;;805    		return 0;	/* 通信超时了 */
00005c  2000              MOVS     r0,#0
                  |L6.94|
;;;806    	}
;;;807    	else 
;;;808    	{
;;;809    		return 1;	/* 04H 读成功 */
;;;810    	}
;;;811    }
00005e  e8bd81f0          POP      {r4-r8,pc}
                  |L6.98|
000062  2001              MOVS     r0,#1                 ;809
000064  e7fb              B        |L6.94|
;;;812    /*
                          ENDP

000066  0000              DCW      0x0000
                  |L6.104|
                          DCD      g_tModH

                          AREA ||i.MODH_Read_01H||, CODE, READONLY, ALIGN=2

                  MODH_Read_01H PROC
;;;421    */
;;;422    static void MODH_Read_01H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;423    {
;;;424    	uint8_t bytes;
;;;425    	uint8_t *p;
;;;426    	
;;;427    	if (g_tModH.RxCount > 0)
000002  4817              LDR      r0,|L7.96|
000004  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModH
000008  2800              CMP      r0,#0
00000a  dd28              BLE      |L7.94|
;;;428    	{
;;;429    		bytes = g_tModH.RxBuf[2];	/* 数据长度 字节数 */				
00000c  4814              LDR      r0,|L7.96|
00000e  7885              LDRB     r5,[r0,#2]  ; g_tModH
;;;430    		switch (g_tModH.Reg01H)
000010  f8b000c6          LDRH     r0,[r0,#0xc6]  ; g_tModH
000014  f2a01001          SUB      r0,r0,#0x101
000018  bb00              CBNZ     r0,|L7.92|
;;;431    		{
;;;432    			case REG_D01:
;;;433    				if (bytes == 8)
00001a  2d08              CMP      r5,#8
00001c  d11d              BNE      |L7.90|
;;;434    				{
;;;435    					p = &g_tModH.RxBuf[3];	
00001e  4c10              LDR      r4,|L7.96|
000020  1ce4              ADDS     r4,r4,#3
;;;436    					
;;;437    					g_tVar.D01 = BEBufToUint16(p); p += 2;	/* 寄存器 */	
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       BEBufToUint16
000028  490e              LDR      r1,|L7.100|
00002a  8188              STRH     r0,[r1,#0xc]
00002c  1ca4              ADDS     r4,r4,#2
;;;438    					g_tVar.D02 = BEBufToUint16(p); p += 2;	/* 寄存器 */	
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       BEBufToUint16
000034  490b              LDR      r1,|L7.100|
000036  81c8              STRH     r0,[r1,#0xe]
000038  1ca4              ADDS     r4,r4,#2
;;;439    					g_tVar.D03 = BEBufToUint16(p); p += 2;	/* 寄存器 */	
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       BEBufToUint16
000040  4908              LDR      r1,|L7.100|
000042  8208              STRH     r0,[r1,#0x10]
000044  1ca4              ADDS     r4,r4,#2
;;;440    					g_tVar.D04 = BEBufToUint16(p); p += 2;	/* 寄存器 */
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       BEBufToUint16
00004c  4905              LDR      r1,|L7.100|
00004e  8248              STRH     r0,[r1,#0x12]
000050  1ca4              ADDS     r4,r4,#2
;;;441    					
;;;442    					g_tModH.fAck01H = 1;
000052  2001              MOVS     r0,#1
000054  4902              LDR      r1,|L7.96|
000056  f88100cf          STRB     r0,[r1,#0xcf]
                  |L7.90|
;;;443    				}
;;;444    				break;
00005a  bf00              NOP      
                  |L7.92|
00005c  bf00              NOP      
                  |L7.94|
;;;445    		}
;;;446    	}
;;;447    }
00005e  bd70              POP      {r4-r6,pc}
;;;448    
                          ENDP

                  |L7.96|
                          DCD      g_tModH
                  |L7.100|
                          DCD      g_tVar

                          AREA ||i.MODH_Read_02H||, CODE, READONLY, ALIGN=2

                  MODH_Read_02H PROC
;;;456    */
;;;457    static void MODH_Read_02H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;458    {
;;;459    	uint8_t bytes;
;;;460    	uint8_t *p;
;;;461    	
;;;462    	if (g_tModH.RxCount > 0)
000002  4814              LDR      r0,|L8.84|
000004  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModH
000008  2800              CMP      r0,#0
00000a  dd22              BLE      |L8.82|
;;;463    	{
;;;464    		bytes = g_tModH.RxBuf[2];	/* 数据长度 字节数 */				
00000c  4811              LDR      r0,|L8.84|
00000e  7885              LDRB     r5,[r0,#2]  ; g_tModH
;;;465    		switch (g_tModH.Reg02H)
000010  f8b000c8          LDRH     r0,[r0,#0xc8]  ; g_tModH
000014  f2a02001          SUB      r0,r0,#0x201
000018  b9d0              CBNZ     r0,|L8.80|
;;;466    		{
;;;467    			case REG_T01:
;;;468    				if (bytes == 6)
00001a  2d06              CMP      r5,#6
00001c  d117              BNE      |L8.78|
;;;469    				{
;;;470    					p = &g_tModH.RxBuf[3];	
00001e  4c0d              LDR      r4,|L8.84|
000020  1ce4              ADDS     r4,r4,#3
;;;471    					
;;;472    					g_tVar.T01 = BEBufToUint16(p); p += 2;	/* 寄存器 */	
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       BEBufToUint16
000028  490b              LDR      r1,|L8.88|
00002a  8088              STRH     r0,[r1,#4]
00002c  1ca4              ADDS     r4,r4,#2
;;;473    					g_tVar.T02 = BEBufToUint16(p); p += 2;	/* 寄存器 */	
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       BEBufToUint16
000034  4908              LDR      r1,|L8.88|
000036  80c8              STRH     r0,[r1,#6]
000038  1ca4              ADDS     r4,r4,#2
;;;474    					g_tVar.T03 = BEBufToUint16(p); p += 2;	/* 寄存器 */	
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       BEBufToUint16
000040  4905              LDR      r1,|L8.88|
000042  8108              STRH     r0,[r1,#8]
000044  1ca4              ADDS     r4,r4,#2
;;;475    					
;;;476    					g_tModH.fAck02H = 1;
000046  2001              MOVS     r0,#1
000048  4902              LDR      r1,|L8.84|
00004a  f88100d0          STRB     r0,[r1,#0xd0]
                  |L8.78|
;;;477    				}
;;;478    				break;
00004e  bf00              NOP      
                  |L8.80|
000050  bf00              NOP      
                  |L8.82|
;;;479    		}
;;;480    	}
;;;481    }
000052  bd70              POP      {r4-r6,pc}
;;;482    
                          ENDP

                  |L8.84|
                          DCD      g_tModH
                  |L8.88|
                          DCD      g_tVar

                          AREA ||i.MODH_Read_03H||, CODE, READONLY, ALIGN=2

                  MODH_Read_03H PROC
;;;561    */
;;;562    void MODH_Read_03H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;563    {
;;;564    	uint8_t bytes;
;;;565    	uint8_t *p;
;;;566    	
;;;567    	if (g_tModH.RxCount > 0)
000002  4810              LDR      r0,|L9.68|
000004  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModH
000008  2800              CMP      r0,#0
00000a  dd1a              BLE      |L9.66|
;;;568    	{
;;;569    		bytes = g_tModH.RxBuf[2];	/* 数据长度 字节数 */				
00000c  480d              LDR      r0,|L9.68|
00000e  7885              LDRB     r5,[r0,#2]  ; g_tModH
;;;570    		switch (g_tModH.Reg03H)
000010  f8b000ca          LDRH     r0,[r0,#0xca]  ; g_tModH
000014  b9a0              CBNZ     r0,|L9.64|
;;;571    		{
;;;572    			case REG_P01:
;;;573    				if (bytes == 32)
000016  2d20              CMP      r5,#0x20
000018  d111              BNE      |L9.62|
;;;574    				{
;;;575    					p = &g_tModH.RxBuf[3];	
00001a  4c0a              LDR      r4,|L9.68|
00001c  1ce4              ADDS     r4,r4,#3
;;;576    					
;;;577    					g_tVar.P01 = BEBufToUint16(p); p += 2;	/* 寄存器 */	
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       BEBufToUint16
000024  4908              LDR      r1,|L9.72|
000026  8008              STRH     r0,[r1,#0]
000028  1ca4              ADDS     r4,r4,#2
;;;578    					g_tVar.P02 = BEBufToUint16(p); p += 2;	/* 寄存器 */	
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       BEBufToUint16
000030  4905              LDR      r1,|L9.72|
000032  8048              STRH     r0,[r1,#2]
000034  1ca4              ADDS     r4,r4,#2
;;;579    		
;;;580    					g_tModH.fAck03H = 1;
000036  2001              MOVS     r0,#1
000038  1fe1              SUBS     r1,r4,#7
00003a  f88100d1          STRB     r0,[r1,#0xd1]
                  |L9.62|
;;;581    				}
;;;582    				break;
00003e  bf00              NOP      
                  |L9.64|
000040  bf00              NOP      
                  |L9.66|
;;;583    		}
;;;584    	}
;;;585    }
000042  bd70              POP      {r4-r6,pc}
;;;586    
                          ENDP

                  |L9.68|
                          DCD      g_tModH
                  |L9.72|
                          DCD      g_tVar

                          AREA ||i.MODH_Read_04H||, CODE, READONLY, ALIGN=2

                  MODH_Read_04H PROC
;;;490    */
;;;491    static void MODH_Read_04H(void)
000000  b570              PUSH     {r4-r6,lr}
;;;492    {
;;;493    	uint8_t bytes;
;;;494    	uint8_t *p;
;;;495    	
;;;496    	if (g_tModH.RxCount > 0)
000002  480e              LDR      r0,|L10.60|
000004  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModH
000008  2800              CMP      r0,#0
00000a  dd16              BLE      |L10.58|
;;;497    	{
;;;498    		bytes = g_tModH.RxBuf[2];	/* 数据长度 字节数 */				
00000c  480b              LDR      r0,|L10.60|
00000e  7884              LDRB     r4,[r0,#2]  ; g_tModH
;;;499    		switch (g_tModH.Reg04H)
000010  f8b000cc          LDRH     r0,[r0,#0xcc]  ; g_tModH
000014  f2a02001          SUB      r0,r0,#0x201
000018  b970              CBNZ     r0,|L10.56|
;;;500    		{
;;;501    			case REG_T01:
;;;502    				if (bytes == 2)
00001a  2c02              CMP      r4,#2
00001c  d10b              BNE      |L10.54|
;;;503    				{
;;;504    					p = &g_tModH.RxBuf[3];	
00001e  4d07              LDR      r5,|L10.60|
000020  1ced              ADDS     r5,r5,#3
;;;505    					
;;;506    					g_tVar.A01 = BEBufToUint16(p); p += 2;	/* 寄存器 */	
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       BEBufToUint16
000028  4905              LDR      r1,|L10.64|
00002a  8148              STRH     r0,[r1,#0xa]
00002c  1cad              ADDS     r5,r5,#2
;;;507    					
;;;508    					g_tModH.fAck04H = 1;
00002e  2001              MOVS     r0,#1
000030  1f69              SUBS     r1,r5,#5
000032  f88100d2          STRB     r0,[r1,#0xd2]
                  |L10.54|
;;;509    				}
;;;510    				break;
000036  bf00              NOP      
                  |L10.56|
000038  bf00              NOP      
                  |L10.58|
;;;511    		}
;;;512    	}
;;;513    }
00003a  bd70              POP      {r4-r6,pc}
;;;514    
                          ENDP

                  |L10.60|
                          DCD      g_tModH
                  |L10.64|
                          DCD      g_tVar

                          AREA ||i.MODH_Read_05H||, CODE, READONLY, ALIGN=2

                  MODH_Read_05H PROC
;;;522    */
;;;523    static void MODH_Read_05H(void)
000000  4806              LDR      r0,|L11.28|
;;;524    {
;;;525    	if (g_tModH.RxCount > 0)
000002  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModH
000006  2800              CMP      r0,#0
000008  dd06              BLE      |L11.24|
;;;526    	{
;;;527    		if (g_tModH.RxBuf[0] == SlaveAddr)		
00000a  4804              LDR      r0,|L11.28|
00000c  7800              LDRB     r0,[r0,#0]  ; g_tModH
00000e  2801              CMP      r0,#1
000010  d102              BNE      |L11.24|
;;;528    		{
;;;529    			g_tModH.fAck05H = 1;		/* 接收到应答 */
000012  4902              LDR      r1,|L11.28|
000014  f88100d3          STRB     r0,[r1,#0xd3]
                  |L11.24|
;;;530    		}
;;;531    	};
;;;532    }
000018  4770              BX       lr
;;;533    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      g_tModH

                          AREA ||i.MODH_Read_06H||, CODE, READONLY, ALIGN=2

                  MODH_Read_06H PROC
;;;541    */
;;;542    static void MODH_Read_06H(void)
000000  4806              LDR      r0,|L12.28|
;;;543    {
;;;544    	if (g_tModH.RxCount > 0)
000002  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModH
000006  2800              CMP      r0,#0
000008  dd06              BLE      |L12.24|
;;;545    	{
;;;546    		if (g_tModH.RxBuf[0] == SlaveAddr)		
00000a  4804              LDR      r0,|L12.28|
00000c  7800              LDRB     r0,[r0,#0]  ; g_tModH
00000e  2801              CMP      r0,#1
000010  d102              BNE      |L12.24|
;;;547    		{
;;;548    			g_tModH.fAck06H = 1;		/* 接收到应答 */
000012  4902              LDR      r1,|L12.28|
000014  f88100d4          STRB     r0,[r1,#0xd4]
                  |L12.24|
;;;549    		}
;;;550    	}
;;;551    }
000018  4770              BX       lr
;;;552    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      g_tModH

                          AREA ||i.MODH_Read_10H||, CODE, READONLY, ALIGN=2

                  MODH_Read_10H PROC
;;;594    */
;;;595    void MODH_Read_10H(void)
000000  4806              LDR      r0,|L13.28|
;;;596    {
;;;597    	/*
;;;598    		10H指令的应答:
;;;599    			从机地址                11
;;;600    			功能码                  10
;;;601    			寄存器起始地址高字节	00
;;;602    			寄存器起始地址低字节    01
;;;603    			寄存器数量高字节        00
;;;604    			寄存器数量低字节        02
;;;605    			CRC校验高字节           12
;;;606    			CRC校验低字节           98
;;;607    	*/
;;;608    	if (g_tModH.RxCount > 0)
000002  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModH
000006  2800              CMP      r0,#0
000008  dd06              BLE      |L13.24|
;;;609    	{
;;;610    		if (g_tModH.RxBuf[0] == SlaveAddr)		
00000a  4804              LDR      r0,|L13.28|
00000c  7800              LDRB     r0,[r0,#0]  ; g_tModH
00000e  2801              CMP      r0,#1
000010  d102              BNE      |L13.24|
;;;611    		{
;;;612    			g_tModH.fAck10H = 1;		/* 接收到应答 */
000012  4902              LDR      r1,|L13.28|
000014  f88100d5          STRB     r0,[r1,#0xd5]
                  |L13.24|
;;;613    		}
;;;614    	}
;;;615    }
000018  4770              BX       lr
;;;616    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      g_tModH

                          AREA ||i.MODH_ReciveNew||, CODE, READONLY, ALIGN=2

                  MODH_ReciveNew PROC
;;;320    */
;;;321    void MODH_ReciveNew(uint8_t _data)
000000  b570              PUSH     {r4-r6,lr}
;;;322    {
000002  4604              MOV      r4,r0
;;;323    	/*
;;;324    		3.5个字符的时间间隔，只是用在RTU模式下面，因为RTU模式没有开始符和结束符，
;;;325    		两个数据包之间只能靠时间间隔来区分，Modbus定义在不同的波特率下，间隔时间是不一样的，
;;;326    		所以就是3.5个字符的时间，波特率高，这个时间间隔就小，波特率低，这个时间间隔相应就大
;;;327    
;;;328    		4800  = 7.297ms
;;;329    		9600  = 3.646ms
;;;330    		19200  = 1.771ms
;;;331    		38400  = 0.885ms
;;;332    	*/
;;;333    	uint32_t timeout;
;;;334    
;;;335    	g_modh_timeout = 0;
000004  2000              MOVS     r0,#0
000006  490d              LDR      r1,|L14.60|
000008  7008              STRB     r0,[r1,#0]
;;;336    	
;;;337    	timeout = 35000000 / HBAUD485;		/* 计算超时时间，单位us 35000000*/
00000a  f240152f          MOV      r5,#0x12f
;;;338    	
;;;339    	/* 硬件定时中断，定时精度us 硬件定时器2用于MODBUS从机, 定时器3用于MODBUS从机主机*/
;;;340    	bsp_StartHardTimer(3, timeout, (void *)MODH_RxTimeOut);
00000e  4a0c              LDR      r2,|L14.64|
000010  4629              MOV      r1,r5
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       bsp_StartHardTimer
;;;341    
;;;342    	if (g_tModH.RxCount < H_RX_BUF_SIZE)
000018  480a              LDR      r0,|L14.68|
00001a  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModH
00001e  2840              CMP      r0,#0x40
000020  da0a              BGE      |L14.56|
;;;343    	{
;;;344    		g_tModH.RxBuf[g_tModH.RxCount++] = _data;
000022  4808              LDR      r0,|L14.68|
000024  f8901040          LDRB     r1,[r0,#0x40]  ; g_tModH
000028  f8900040          LDRB     r0,[r0,#0x40]  ; g_tModH
00002c  1c40              ADDS     r0,r0,#1
00002e  4a05              LDR      r2,|L14.68|
000030  f8820040          STRB     r0,[r2,#0x40]
000034  4610              MOV      r0,r2
000036  5444              STRB     r4,[r0,r1]
                  |L14.56|
;;;345    	}
;;;346    }
000038  bd70              POP      {r4-r6,pc}
;;;347    
                          ENDP

00003a  0000              DCW      0x0000
                  |L14.60|
                          DCD      g_modh_timeout
                  |L14.64|
                          DCD      MODH_RxTimeOut
                  |L14.68|
                          DCD      g_tModH

                          AREA ||i.MODH_RxTimeOut||, CODE, READONLY, ALIGN=2

                  MODH_RxTimeOut PROC
;;;355    */
;;;356    static void MODH_RxTimeOut(void)
000000  2001              MOVS     r0,#1
;;;357    {
;;;358    	g_modh_timeout = 1;
000002  4901              LDR      r1,|L15.8|
000004  7008              STRB     r0,[r1,#0]
;;;359    }
000006  4770              BX       lr
;;;360    
                          ENDP

                  |L15.8|
                          DCD      g_modh_timeout

                          AREA ||i.MODH_Send01H||, CODE, READONLY, ALIGN=2

                  MODH_Send01H PROC
;;;132    */
;;;133    void MODH_Send01H(uint8_t _addr, uint16_t _reg, uint16_t _num)
000000  b570              PUSH     {r4-r6,lr}
;;;134    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;135    	g_tModH.TxCount = 0;
000008  2000              MOVS     r0,#0
00000a  492b              LDR      r1,|L16.184|
00000c  f88100c4          STRB     r0,[r1,#0xc4]
;;;136    	g_tModH.TxBuf[g_tModH.TxCount++] = _addr;		/* 从站地址 */
000010  4608              MOV      r0,r1
000012  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModH
000016  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00001a  1c40              ADDS     r0,r0,#1
00001c  4a26              LDR      r2,|L16.184|
00001e  f88200c4          STRB     r0,[r2,#0xc4]
000022  f1020044          ADD      r0,r2,#0x44
000026  5446              STRB     r6,[r0,r1]
;;;137    	g_tModH.TxBuf[g_tModH.TxCount++] = 0x01;		/* 功能码 */	
000028  2101              MOVS     r1,#1
00002a  3844              SUBS     r0,r0,#0x44
00002c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000030  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000034  1c40              ADDS     r0,r0,#1
000036  4b20              LDR      r3,|L16.184|
000038  f88300c4          STRB     r0,[r3,#0xc4]
00003c  f1030044          ADD      r0,r3,#0x44
000040  5481              STRB     r1,[r0,r2]
;;;138    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg >> 8;	/* 寄存器编号 高字节 */
000042  1221              ASRS     r1,r4,#8
000044  3844              SUBS     r0,r0,#0x44
000046  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00004a  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00004e  1c40              ADDS     r0,r0,#1
000050  f88300c4          STRB     r0,[r3,#0xc4]
000054  f1030044          ADD      r0,r3,#0x44
000058  5481              STRB     r1,[r0,r2]
;;;139    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg;		/* 寄存器编号 低字节 */
00005a  3844              SUBS     r0,r0,#0x44
00005c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000060  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000064  1c40              ADDS     r0,r0,#1
000066  f88300c4          STRB     r0,[r3,#0xc4]
00006a  f1030044          ADD      r0,r3,#0x44
00006e  5484              STRB     r4,[r0,r2]
;;;140    	g_tModH.TxBuf[g_tModH.TxCount++] = _num >> 8;	/* 寄存器个数 高字节 */
000070  1229              ASRS     r1,r5,#8
000072  3844              SUBS     r0,r0,#0x44
000074  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000078  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00007c  1c40              ADDS     r0,r0,#1
00007e  f88300c4          STRB     r0,[r3,#0xc4]
000082  f1030044          ADD      r0,r3,#0x44
000086  5481              STRB     r1,[r0,r2]
;;;141    	g_tModH.TxBuf[g_tModH.TxCount++] = _num;		/* 寄存器个数 低字节 */
000088  3844              SUBS     r0,r0,#0x44
00008a  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00008e  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000092  1c40              ADDS     r0,r0,#1
000094  f88300c4          STRB     r0,[r3,#0xc4]
000098  f1030044          ADD      r0,r3,#0x44
00009c  5485              STRB     r5,[r0,r2]
;;;142    	
;;;143    	MODH_SendAckWithCRC();		/* 发送数据，自动加CRC */
00009e  f7fffffe          BL       MODH_SendAckWithCRC
;;;144    	g_tModH.fAck01H = 0;		/* 清接收标志 */
0000a2  2000              MOVS     r0,#0
0000a4  4904              LDR      r1,|L16.184|
0000a6  f88100cf          STRB     r0,[r1,#0xcf]
;;;145    	g_tModH.RegNum = _num;		/* 寄存器个数 */
0000aa  f88150ce          STRB     r5,[r1,#0xce]
;;;146    	g_tModH.Reg01H = _reg;		/* 保存03H指令中的寄存器地址，方便对应答数据进行分类 */	
0000ae  4608              MOV      r0,r1
0000b0  f8a040c6          STRH     r4,[r0,#0xc6]
;;;147    }
0000b4  bd70              POP      {r4-r6,pc}
;;;148    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L16.184|
                          DCD      g_tModH

                          AREA ||i.MODH_Send02H||, CODE, READONLY, ALIGN=2

                  MODH_Send02H PROC
;;;158    */
;;;159    void MODH_Send02H(uint8_t _addr, uint16_t _reg, uint16_t _num)
000000  b570              PUSH     {r4-r6,lr}
;;;160    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;161    	g_tModH.TxCount = 0;
000008  2000              MOVS     r0,#0
00000a  492b              LDR      r1,|L17.184|
00000c  f88100c4          STRB     r0,[r1,#0xc4]
;;;162    	g_tModH.TxBuf[g_tModH.TxCount++] = _addr;		/* 从站地址 */
000010  4608              MOV      r0,r1
000012  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModH
000016  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00001a  1c40              ADDS     r0,r0,#1
00001c  4a26              LDR      r2,|L17.184|
00001e  f88200c4          STRB     r0,[r2,#0xc4]
000022  f1020044          ADD      r0,r2,#0x44
000026  5446              STRB     r6,[r0,r1]
;;;163    	g_tModH.TxBuf[g_tModH.TxCount++] = 0x02;		/* 功能码 */	
000028  2102              MOVS     r1,#2
00002a  3844              SUBS     r0,r0,#0x44
00002c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000030  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000034  1c40              ADDS     r0,r0,#1
000036  4b20              LDR      r3,|L17.184|
000038  f88300c4          STRB     r0,[r3,#0xc4]
00003c  f1030044          ADD      r0,r3,#0x44
000040  5481              STRB     r1,[r0,r2]
;;;164    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg >> 8;	/* 寄存器编号 高字节 */
000042  1221              ASRS     r1,r4,#8
000044  3844              SUBS     r0,r0,#0x44
000046  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00004a  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00004e  1c40              ADDS     r0,r0,#1
000050  f88300c4          STRB     r0,[r3,#0xc4]
000054  f1030044          ADD      r0,r3,#0x44
000058  5481              STRB     r1,[r0,r2]
;;;165    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg;		/* 寄存器编号 低字节 */
00005a  3844              SUBS     r0,r0,#0x44
00005c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000060  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000064  1c40              ADDS     r0,r0,#1
000066  f88300c4          STRB     r0,[r3,#0xc4]
00006a  f1030044          ADD      r0,r3,#0x44
00006e  5484              STRB     r4,[r0,r2]
;;;166    	g_tModH.TxBuf[g_tModH.TxCount++] = _num >> 8;	/* 寄存器个数 高字节 */
000070  1229              ASRS     r1,r5,#8
000072  3844              SUBS     r0,r0,#0x44
000074  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000078  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00007c  1c40              ADDS     r0,r0,#1
00007e  f88300c4          STRB     r0,[r3,#0xc4]
000082  f1030044          ADD      r0,r3,#0x44
000086  5481              STRB     r1,[r0,r2]
;;;167    	g_tModH.TxBuf[g_tModH.TxCount++] = _num;		/* 寄存器个数 低字节 */
000088  3844              SUBS     r0,r0,#0x44
00008a  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00008e  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000092  1c40              ADDS     r0,r0,#1
000094  f88300c4          STRB     r0,[r3,#0xc4]
000098  f1030044          ADD      r0,r3,#0x44
00009c  5485              STRB     r5,[r0,r2]
;;;168    	
;;;169    	MODH_SendAckWithCRC();		/* 发送数据，自动加CRC */
00009e  f7fffffe          BL       MODH_SendAckWithCRC
;;;170    	g_tModH.fAck02H = 0;		/* 清接收标志 */
0000a2  2000              MOVS     r0,#0
0000a4  4904              LDR      r1,|L17.184|
0000a6  f88100d0          STRB     r0,[r1,#0xd0]
;;;171    	g_tModH.RegNum = _num;		/* 寄存器个数 */
0000aa  f88150ce          STRB     r5,[r1,#0xce]
;;;172    	g_tModH.Reg02H = _reg;		/* 保存03H指令中的寄存器地址，方便对应答数据进行分类 */	
0000ae  4608              MOV      r0,r1
0000b0  f8a040c8          STRH     r4,[r0,#0xc8]
;;;173    }
0000b4  bd70              POP      {r4-r6,pc}
;;;174    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L17.184|
                          DCD      g_tModH

                          AREA ||i.MODH_Send03H||, CODE, READONLY, ALIGN=2

                  MODH_Send03H PROC
;;;184    */
;;;185    void MODH_Send03H(uint8_t _addr, uint16_t _reg, uint16_t _num)
000000  b570              PUSH     {r4-r6,lr}
;;;186    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;187    	g_tModH.TxCount = 0;
000008  2000              MOVS     r0,#0
00000a  492b              LDR      r1,|L18.184|
00000c  f88100c4          STRB     r0,[r1,#0xc4]
;;;188    	g_tModH.TxBuf[g_tModH.TxCount++] = _addr;		/* 从站地址 */
000010  4608              MOV      r0,r1
000012  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModH
000016  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00001a  1c40              ADDS     r0,r0,#1
00001c  4a26              LDR      r2,|L18.184|
00001e  f88200c4          STRB     r0,[r2,#0xc4]
000022  f1020044          ADD      r0,r2,#0x44
000026  5446              STRB     r6,[r0,r1]
;;;189    	g_tModH.TxBuf[g_tModH.TxCount++] = 0x03;		/* 功能码 */	
000028  2103              MOVS     r1,#3
00002a  3844              SUBS     r0,r0,#0x44
00002c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000030  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000034  1c40              ADDS     r0,r0,#1
000036  4b20              LDR      r3,|L18.184|
000038  f88300c4          STRB     r0,[r3,#0xc4]
00003c  f1030044          ADD      r0,r3,#0x44
000040  5481              STRB     r1,[r0,r2]
;;;190    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg >> 8;	/* 寄存器编号 高字节 */
000042  1221              ASRS     r1,r4,#8
000044  3844              SUBS     r0,r0,#0x44
000046  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00004a  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00004e  1c40              ADDS     r0,r0,#1
000050  f88300c4          STRB     r0,[r3,#0xc4]
000054  f1030044          ADD      r0,r3,#0x44
000058  5481              STRB     r1,[r0,r2]
;;;191    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg;		/* 寄存器编号 低字节 */
00005a  3844              SUBS     r0,r0,#0x44
00005c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000060  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000064  1c40              ADDS     r0,r0,#1
000066  f88300c4          STRB     r0,[r3,#0xc4]
00006a  f1030044          ADD      r0,r3,#0x44
00006e  5484              STRB     r4,[r0,r2]
;;;192    	g_tModH.TxBuf[g_tModH.TxCount++] = _num >> 8;	/* 寄存器个数 高字节 */
000070  1229              ASRS     r1,r5,#8
000072  3844              SUBS     r0,r0,#0x44
000074  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000078  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00007c  1c40              ADDS     r0,r0,#1
00007e  f88300c4          STRB     r0,[r3,#0xc4]
000082  f1030044          ADD      r0,r3,#0x44
000086  5481              STRB     r1,[r0,r2]
;;;193    	g_tModH.TxBuf[g_tModH.TxCount++] = _num;		/* 寄存器个数 低字节 */
000088  3844              SUBS     r0,r0,#0x44
00008a  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00008e  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000092  1c40              ADDS     r0,r0,#1
000094  f88300c4          STRB     r0,[r3,#0xc4]
000098  f1030044          ADD      r0,r3,#0x44
00009c  5485              STRB     r5,[r0,r2]
;;;194    	
;;;195    	MODH_SendAckWithCRC();		/* 发送数据，自动加CRC */
00009e  f7fffffe          BL       MODH_SendAckWithCRC
;;;196    	g_tModH.fAck03H = 0;		/* 清接收标志 */
0000a2  2000              MOVS     r0,#0
0000a4  4904              LDR      r1,|L18.184|
0000a6  f88100d1          STRB     r0,[r1,#0xd1]
;;;197    	g_tModH.RegNum = _num;		/* 寄存器个数 */
0000aa  f88150ce          STRB     r5,[r1,#0xce]
;;;198    	g_tModH.Reg03H = _reg;		/* 保存03H指令中的寄存器地址，方便对应答数据进行分类 */	
0000ae  4608              MOV      r0,r1
0000b0  f8a040ca          STRH     r4,[r0,#0xca]
;;;199    }
0000b4  bd70              POP      {r4-r6,pc}
;;;200    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L18.184|
                          DCD      g_tModH

                          AREA ||i.MODH_Send04H||, CODE, READONLY, ALIGN=2

                  MODH_Send04H PROC
;;;210    */
;;;211    void MODH_Send04H(uint8_t _addr, uint16_t _reg, uint16_t _num)
000000  b570              PUSH     {r4-r6,lr}
;;;212    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;213    	g_tModH.TxCount = 0;
000008  2000              MOVS     r0,#0
00000a  492b              LDR      r1,|L19.184|
00000c  f88100c4          STRB     r0,[r1,#0xc4]
;;;214    	g_tModH.TxBuf[g_tModH.TxCount++] = _addr;		/* 从站地址 */
000010  4608              MOV      r0,r1
000012  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModH
000016  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00001a  1c40              ADDS     r0,r0,#1
00001c  4a26              LDR      r2,|L19.184|
00001e  f88200c4          STRB     r0,[r2,#0xc4]
000022  f1020044          ADD      r0,r2,#0x44
000026  5446              STRB     r6,[r0,r1]
;;;215    	g_tModH.TxBuf[g_tModH.TxCount++] = 0x04;		/* 功能码 */	
000028  2104              MOVS     r1,#4
00002a  3844              SUBS     r0,r0,#0x44
00002c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000030  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000034  1c40              ADDS     r0,r0,#1
000036  4b20              LDR      r3,|L19.184|
000038  f88300c4          STRB     r0,[r3,#0xc4]
00003c  f1030044          ADD      r0,r3,#0x44
000040  5481              STRB     r1,[r0,r2]
;;;216    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg >> 8;	/* 寄存器编号 高字节 */
000042  1221              ASRS     r1,r4,#8
000044  3844              SUBS     r0,r0,#0x44
000046  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00004a  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00004e  1c40              ADDS     r0,r0,#1
000050  f88300c4          STRB     r0,[r3,#0xc4]
000054  f1030044          ADD      r0,r3,#0x44
000058  5481              STRB     r1,[r0,r2]
;;;217    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg;		/* 寄存器编号 低字节 */
00005a  3844              SUBS     r0,r0,#0x44
00005c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000060  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000064  1c40              ADDS     r0,r0,#1
000066  f88300c4          STRB     r0,[r3,#0xc4]
00006a  f1030044          ADD      r0,r3,#0x44
00006e  5484              STRB     r4,[r0,r2]
;;;218    	g_tModH.TxBuf[g_tModH.TxCount++] = _num >> 8;	/* 寄存器个数 高字节 */
000070  1229              ASRS     r1,r5,#8
000072  3844              SUBS     r0,r0,#0x44
000074  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000078  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00007c  1c40              ADDS     r0,r0,#1
00007e  f88300c4          STRB     r0,[r3,#0xc4]
000082  f1030044          ADD      r0,r3,#0x44
000086  5481              STRB     r1,[r0,r2]
;;;219    	g_tModH.TxBuf[g_tModH.TxCount++] = _num;		/* 寄存器个数 低字节 */
000088  3844              SUBS     r0,r0,#0x44
00008a  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00008e  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000092  1c40              ADDS     r0,r0,#1
000094  f88300c4          STRB     r0,[r3,#0xc4]
000098  f1030044          ADD      r0,r3,#0x44
00009c  5485              STRB     r5,[r0,r2]
;;;220    	
;;;221    	MODH_SendAckWithCRC();		/* 发送数据，自动加CRC */
00009e  f7fffffe          BL       MODH_SendAckWithCRC
;;;222    	g_tModH.fAck04H = 0;		/* 清接收标志 */
0000a2  2000              MOVS     r0,#0
0000a4  4904              LDR      r1,|L19.184|
0000a6  f88100d2          STRB     r0,[r1,#0xd2]
;;;223    	g_tModH.RegNum = _num;		/* 寄存器个数 */
0000aa  f88150ce          STRB     r5,[r1,#0xce]
;;;224    	g_tModH.Reg04H = _reg;		/* 保存03H指令中的寄存器地址，方便对应答数据进行分类 */	
0000ae  4608              MOV      r0,r1
0000b0  f8a040cc          STRH     r4,[r0,#0xcc]
;;;225    }
0000b4  bd70              POP      {r4-r6,pc}
;;;226    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L19.184|
                          DCD      g_tModH

                          AREA ||i.MODH_Send05H||, CODE, READONLY, ALIGN=2

                  MODH_Send05H PROC
;;;236    */
;;;237    void MODH_Send05H(uint8_t _addr, uint16_t _reg, uint16_t _value)
000000  b570              PUSH     {r4-r6,lr}
;;;238    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;239    	g_tModH.TxCount = 0;
000008  2000              MOVS     r0,#0
00000a  4928              LDR      r1,|L20.172|
00000c  f88100c4          STRB     r0,[r1,#0xc4]
;;;240    	g_tModH.TxBuf[g_tModH.TxCount++] = _addr;			/* 从站地址 */
000010  4608              MOV      r0,r1
000012  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModH
000016  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00001a  1c40              ADDS     r0,r0,#1
00001c  4a23              LDR      r2,|L20.172|
00001e  f88200c4          STRB     r0,[r2,#0xc4]
000022  f1020044          ADD      r0,r2,#0x44
000026  5446              STRB     r6,[r0,r1]
;;;241    	g_tModH.TxBuf[g_tModH.TxCount++] = 0x05;			/* 功能码 */	
000028  2105              MOVS     r1,#5
00002a  3844              SUBS     r0,r0,#0x44
00002c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000030  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000034  1c40              ADDS     r0,r0,#1
000036  4b1d              LDR      r3,|L20.172|
000038  f88300c4          STRB     r0,[r3,#0xc4]
00003c  f1030044          ADD      r0,r3,#0x44
000040  5481              STRB     r1,[r0,r2]
;;;242    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg >> 8;		/* 寄存器编号 高字节 */
000042  1221              ASRS     r1,r4,#8
000044  3844              SUBS     r0,r0,#0x44
000046  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00004a  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00004e  1c40              ADDS     r0,r0,#1
000050  f88300c4          STRB     r0,[r3,#0xc4]
000054  f1030044          ADD      r0,r3,#0x44
000058  5481              STRB     r1,[r0,r2]
;;;243    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg;			/* 寄存器编号 低字节 */
00005a  3844              SUBS     r0,r0,#0x44
00005c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000060  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000064  1c40              ADDS     r0,r0,#1
000066  f88300c4          STRB     r0,[r3,#0xc4]
00006a  f1030044          ADD      r0,r3,#0x44
00006e  5484              STRB     r4,[r0,r2]
;;;244    	g_tModH.TxBuf[g_tModH.TxCount++] = _value >> 8;		/* 寄存器值 高字节 */
000070  1229              ASRS     r1,r5,#8
000072  3844              SUBS     r0,r0,#0x44
000074  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000078  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00007c  1c40              ADDS     r0,r0,#1
00007e  f88300c4          STRB     r0,[r3,#0xc4]
000082  f1030044          ADD      r0,r3,#0x44
000086  5481              STRB     r1,[r0,r2]
;;;245    	g_tModH.TxBuf[g_tModH.TxCount++] = _value;			/* 寄存器值 低字节 */
000088  3844              SUBS     r0,r0,#0x44
00008a  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00008e  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000092  1c40              ADDS     r0,r0,#1
000094  f88300c4          STRB     r0,[r3,#0xc4]
000098  f1030044          ADD      r0,r3,#0x44
00009c  5485              STRB     r5,[r0,r2]
;;;246    	
;;;247    	MODH_SendAckWithCRC();		/* 发送数据，自动加CRC */
00009e  f7fffffe          BL       MODH_SendAckWithCRC
;;;248    
;;;249    	g_tModH.fAck05H = 0;		/* 如果收到从机的应答，则这个标志会设为1 */
0000a2  2000              MOVS     r0,#0
0000a4  4901              LDR      r1,|L20.172|
0000a6  f88100d3          STRB     r0,[r1,#0xd3]
;;;250    }
0000aa  bd70              POP      {r4-r6,pc}
;;;251    
                          ENDP

                  |L20.172|
                          DCD      g_tModH

                          AREA ||i.MODH_Send06H||, CODE, READONLY, ALIGN=2

                  MODH_Send06H PROC
;;;261    */
;;;262    void MODH_Send06H(uint8_t _addr, uint16_t _reg, uint16_t _value)
000000  b570              PUSH     {r4-r6,lr}
;;;263    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;264    	g_tModH.TxCount = 0;
000008  2000              MOVS     r0,#0
00000a  4928              LDR      r1,|L21.172|
00000c  f88100c4          STRB     r0,[r1,#0xc4]
;;;265    	g_tModH.TxBuf[g_tModH.TxCount++] = _addr;			/* 从站地址 */
000010  4608              MOV      r0,r1
000012  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModH
000016  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00001a  1c40              ADDS     r0,r0,#1
00001c  4a23              LDR      r2,|L21.172|
00001e  f88200c4          STRB     r0,[r2,#0xc4]
000022  f1020044          ADD      r0,r2,#0x44
000026  5446              STRB     r6,[r0,r1]
;;;266    	g_tModH.TxBuf[g_tModH.TxCount++] = 0x06;			/* 功能码 */	
000028  2106              MOVS     r1,#6
00002a  3844              SUBS     r0,r0,#0x44
00002c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000030  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000034  1c40              ADDS     r0,r0,#1
000036  4b1d              LDR      r3,|L21.172|
000038  f88300c4          STRB     r0,[r3,#0xc4]
00003c  f1030044          ADD      r0,r3,#0x44
000040  5481              STRB     r1,[r0,r2]
;;;267    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg >> 8;		/* 寄存器编号 高字节 */
000042  1221              ASRS     r1,r4,#8
000044  3844              SUBS     r0,r0,#0x44
000046  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00004a  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00004e  1c40              ADDS     r0,r0,#1
000050  f88300c4          STRB     r0,[r3,#0xc4]
000054  f1030044          ADD      r0,r3,#0x44
000058  5481              STRB     r1,[r0,r2]
;;;268    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg;			/* 寄存器编号 低字节 */
00005a  3844              SUBS     r0,r0,#0x44
00005c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000060  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000064  1c40              ADDS     r0,r0,#1
000066  f88300c4          STRB     r0,[r3,#0xc4]
00006a  f1030044          ADD      r0,r3,#0x44
00006e  5484              STRB     r4,[r0,r2]
;;;269    	g_tModH.TxBuf[g_tModH.TxCount++] = _value >> 8;		/* 寄存器值 高字节 */
000070  1229              ASRS     r1,r5,#8
000072  3844              SUBS     r0,r0,#0x44
000074  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000078  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00007c  1c40              ADDS     r0,r0,#1
00007e  f88300c4          STRB     r0,[r3,#0xc4]
000082  f1030044          ADD      r0,r3,#0x44
000086  5481              STRB     r1,[r0,r2]
;;;270    	g_tModH.TxBuf[g_tModH.TxCount++] = _value;			/* 寄存器值 低字节 */
000088  3844              SUBS     r0,r0,#0x44
00008a  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00008e  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000092  1c40              ADDS     r0,r0,#1
000094  f88300c4          STRB     r0,[r3,#0xc4]
000098  f1030044          ADD      r0,r3,#0x44
00009c  5485              STRB     r5,[r0,r2]
;;;271    	
;;;272    	MODH_SendAckWithCRC();		/* 发送数据，自动加CRC */
00009e  f7fffffe          BL       MODH_SendAckWithCRC
;;;273    	
;;;274    	g_tModH.fAck06H = 0;		/* 如果收到从机的应答，则这个标志会设为1 */
0000a2  2000              MOVS     r0,#0
0000a4  4901              LDR      r1,|L21.172|
0000a6  f88100d4          STRB     r0,[r1,#0xd4]
;;;275    }
0000aa  bd70              POP      {r4-r6,pc}
;;;276    
                          ENDP

                  |L21.172|
                          DCD      g_tModH

                          AREA ||i.MODH_Send10H||, CODE, READONLY, ALIGN=2

                  MODH_Send10H PROC
;;;287    */
;;;288    void MODH_Send10H(uint8_t _addr, uint16_t _reg, uint8_t _num, uint8_t *_buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;289    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
;;;290    	uint16_t i;
;;;291    	
;;;292    	g_tModH.TxCount = 0;
00000c  2000              MOVS     r0,#0
00000e  493c              LDR      r1,|L22.256|
000010  f88100c4          STRB     r0,[r1,#0xc4]
;;;293    	g_tModH.TxBuf[g_tModH.TxCount++] = _addr;		/* 从站地址 */
000014  4608              MOV      r0,r1
000016  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModH
00001a  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00001e  1c40              ADDS     r0,r0,#1
000020  4a37              LDR      r2,|L22.256|
000022  f88200c4          STRB     r0,[r2,#0xc4]
000026  f1020044          ADD      r0,r2,#0x44
00002a  5447              STRB     r7,[r0,r1]
;;;294    	g_tModH.TxBuf[g_tModH.TxCount++] = 0x10;		/* 从站地址 */	
00002c  2110              MOVS     r1,#0x10
00002e  3844              SUBS     r0,r0,#0x44
000030  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000034  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000038  1c40              ADDS     r0,r0,#1
00003a  4b31              LDR      r3,|L22.256|
00003c  f88300c4          STRB     r0,[r3,#0xc4]
000040  f1030044          ADD      r0,r3,#0x44
000044  5481              STRB     r1,[r0,r2]
;;;295    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg >> 8;	/* 寄存器编号 高字节 */
000046  1229              ASRS     r1,r5,#8
000048  3844              SUBS     r0,r0,#0x44
00004a  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00004e  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000052  1c40              ADDS     r0,r0,#1
000054  f88300c4          STRB     r0,[r3,#0xc4]
000058  f1030044          ADD      r0,r3,#0x44
00005c  5481              STRB     r1,[r0,r2]
;;;296    	g_tModH.TxBuf[g_tModH.TxCount++] = _reg;		/* 寄存器编号 低字节 */
00005e  3844              SUBS     r0,r0,#0x44
000060  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000064  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000068  1c40              ADDS     r0,r0,#1
00006a  f88300c4          STRB     r0,[r3,#0xc4]
00006e  f1030044          ADD      r0,r3,#0x44
000072  5485              STRB     r5,[r0,r2]
;;;297    	g_tModH.TxBuf[g_tModH.TxCount++] = _num >> 8;	/* 寄存器个数 高字节 */
000074  1221              ASRS     r1,r4,#8
000076  3844              SUBS     r0,r0,#0x44
000078  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00007c  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000080  1c40              ADDS     r0,r0,#1
000082  f88300c4          STRB     r0,[r3,#0xc4]
000086  f1030044          ADD      r0,r3,#0x44
00008a  5481              STRB     r1,[r0,r2]
;;;298    	g_tModH.TxBuf[g_tModH.TxCount++] = _num;		/* 寄存器个数 低字节 */
00008c  3844              SUBS     r0,r0,#0x44
00008e  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModH
000092  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000096  1c40              ADDS     r0,r0,#1
000098  461a              MOV      r2,r3
00009a  f88200c4          STRB     r0,[r2,#0xc4]
00009e  f1020044          ADD      r0,r2,#0x44
0000a2  5444              STRB     r4,[r0,r1]
;;;299    	g_tModH.TxBuf[g_tModH.TxCount++] = 2 * _num;	/* 数据字节数 */
0000a4  0660              LSLS     r0,r4,#25
0000a6  0e01              LSRS     r1,r0,#24
0000a8  4610              MOV      r0,r2
0000aa  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
0000ae  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
0000b2  1c40              ADDS     r0,r0,#1
0000b4  f88300c4          STRB     r0,[r3,#0xc4]
0000b8  f1030044          ADD      r0,r3,#0x44
0000bc  5481              STRB     r1,[r0,r2]
;;;300    	
;;;301    	for (i = 0; i < 2 * _num; i++)
0000be  2600              MOVS     r6,#0
0000c0  e016              B        |L22.240|
                  |L22.194|
;;;302    	{
;;;303    		if (g_tModH.TxCount > H_RX_BUF_SIZE - 3)
0000c2  480f              LDR      r0,|L22.256|
0000c4  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
0000c8  283d              CMP      r0,#0x3d
0000ca  dd01              BLE      |L22.208|
                  |L22.204|
;;;304    		{
;;;305    			return;		/* 数据超过缓冲区超度，直接丢弃不发送 */
;;;306    		}
;;;307    		g_tModH.TxBuf[g_tModH.TxCount++] = _buf[i];		/* 后面的数据长度 */
;;;308    	}
;;;309    	
;;;310    	MODH_SendAckWithCRC();	/* 发送数据，自动加CRC */
;;;311    }
0000cc  e8bd81f0          POP      {r4-r8,pc}
                  |L22.208|
0000d0  f8181006          LDRB     r1,[r8,r6]            ;307
0000d4  480a              LDR      r0,|L22.256|
0000d6  f89020c4          LDRB     r2,[r0,#0xc4]         ;307  ; g_tModH
0000da  f89000c4          LDRB     r0,[r0,#0xc4]         ;307  ; g_tModH
0000de  1c40              ADDS     r0,r0,#1              ;307
0000e0  4b07              LDR      r3,|L22.256|
0000e2  f88300c4          STRB     r0,[r3,#0xc4]         ;307
0000e6  f1030044          ADD      r0,r3,#0x44           ;307
0000ea  5481              STRB     r1,[r0,r2]            ;307
0000ec  1c70              ADDS     r0,r6,#1              ;301
0000ee  b286              UXTH     r6,r0                 ;301
                  |L22.240|
0000f0  0060              LSLS     r0,r4,#1              ;301
0000f2  42b0              CMP      r0,r6                 ;301
0000f4  dce5              BGT      |L22.194|
0000f6  f7fffffe          BL       MODH_SendAckWithCRC
0000fa  bf00              NOP      
0000fc  e7e6              B        |L22.204|
;;;312    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L22.256|
                          DCD      g_tModH

                          AREA ||i.MODH_SendAckWithCRC||, CODE, READONLY, ALIGN=2

                  MODH_SendAckWithCRC PROC
;;;62     */
;;;63     static void MODH_SendAckWithCRC(void)
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65     	uint16_t crc;
;;;66     	
;;;67     	crc = CRC16_Modbus(g_tModH.TxBuf, g_tModH.TxCount);
000002  481a              LDR      r0,|L23.108|
000004  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModH
000008  3044              ADDS     r0,r0,#0x44
00000a  f7fffffe          BL       CRC16_Modbus
00000e  4604              MOV      r4,r0
;;;68     	g_tModH.TxBuf[g_tModH.TxCount++] = crc >> 8;
000010  1221              ASRS     r1,r4,#8
000012  4816              LDR      r0,|L23.108|
000014  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000018  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
00001c  1c40              ADDS     r0,r0,#1
00001e  4b13              LDR      r3,|L23.108|
000020  f88300c4          STRB     r0,[r3,#0xc4]
000024  f1030044          ADD      r0,r3,#0x44
000028  5481              STRB     r1,[r0,r2]
;;;69     	g_tModH.TxBuf[g_tModH.TxCount++] = crc;	
00002a  3844              SUBS     r0,r0,#0x44
00002c  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
000030  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000034  1c40              ADDS     r0,r0,#1
000036  f88300c4          STRB     r0,[r3,#0xc4]
00003a  f1030044          ADD      r0,r3,#0x44
00003e  5484              STRB     r4,[r0,r2]
;;;70     	MODH_SendPacket(g_tModH.TxBuf, g_tModH.TxCount);
000040  3844              SUBS     r0,r0,#0x44
000042  f89010c4          LDRB     r1,[r0,#0xc4]  ; g_tModH
000046  3044              ADDS     r0,r0,#0x44
000048  f7fffffe          BL       MODH_SendPacket
;;;71     	
;;;72     #if 1	/* 此部分为了串口打印结果,实际运用中可不要 */
;;;73     	g_tPrint.Txlen = g_tModH.TxCount;
00004c  4807              LDR      r0,|L23.108|
00004e  f89000c4          LDRB     r0,[r0,#0xc4]  ; g_tModH
000052  4907              LDR      r1,|L23.112|
000054  7548              STRB     r0,[r1,#0x15]
;;;74     	memcpy(g_tPrint.TxBuf, g_tModH.TxBuf, g_tModH.TxCount);
000056  4805              LDR      r0,|L23.108|
000058  f89020c4          LDRB     r2,[r0,#0xc4]  ; g_tModH
00005c  f1000144          ADD      r1,r0,#0x44
000060  4803              LDR      r0,|L23.112|
000062  3016              ADDS     r0,r0,#0x16
000064  f7fffffe          BL       __aeabi_memcpy
;;;75     #endif
;;;76     }
000068  bd10              POP      {r4,pc}
;;;77     
                          ENDP

00006a  0000              DCW      0x0000
                  |L23.108|
                          DCD      g_tModH
                  |L23.112|
                          DCD      g_tPrint

                          AREA ||i.MODH_SendPacket||, CODE, READONLY, ALIGN=1

                  MODH_SendPacket PROC
;;;49     */
;;;50     void MODH_SendPacket(uint8_t *_buf, uint16_t _len)
000000  b570              PUSH     {r4-r6,lr}
;;;51     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;52     	RS485_SendBuf(_buf, _len);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       RS485_SendBuf
;;;53     }
00000e  bd70              POP      {r4-r6,pc}
;;;54     
                          ENDP


                          AREA ||i.MODH_WriteParam_05H||, CODE, READONLY, ALIGN=2

                  MODH_WriteParam_05H PROC
;;;819    */
;;;820    uint8_t MODH_WriteParam_05H(uint16_t _reg, uint16_t _value)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;821    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;822    	int32_t time1;
;;;823    	uint8_t i;
;;;824    
;;;825    	for (i = 0; i < NUM; i++)
000008  2600              MOVS     r6,#0
00000a  e020              B        |L25.78|
                  |L25.12|
;;;826    	{
;;;827    		MODH_Send05H (SlaveAddr, _reg, _value);
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       MODH_Send05H
;;;828    		time1 = bsp_GetRunTime();	/* 记录命令发送的时刻 */
000016  f7fffffe          BL       bsp_GetRunTime
00001a  4607              MOV      r7,r0
;;;829    		
;;;830    		while (1)
00001c  e00d              B        |L25.58|
                  |L25.30|
;;;831    		{
;;;832    			bsp_Idle();
00001e  f7fffffe          BL       bsp_Idle
;;;833    			
;;;834    			/* 超时大于 TIMEOUT，则认为异常 */
;;;835    			if (bsp_CheckRunTime(time1) > TIMEOUT)		
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       bsp_CheckRunTime
000028  2864              CMP      r0,#0x64
00002a  dd00              BLE      |L25.46|
;;;836    			{
;;;837    				break;	/* 通信超时了 */
00002c  e006              B        |L25.60|
                  |L25.46|
;;;838    			}
;;;839    			
;;;840    			if (g_tModH.fAck05H > 0)
00002e  480e              LDR      r0,|L25.104|
000030  f89000d3          LDRB     r0,[r0,#0xd3]  ; g_tModH
000034  2800              CMP      r0,#0
000036  dd00              BLE      |L25.58|
;;;841    			{
;;;842    				break;
000038  e000              B        |L25.60|
                  |L25.58|
00003a  e7f0              B        |L25.30|
                  |L25.60|
00003c  bf00              NOP                            ;837
;;;843    			}
;;;844    		}
;;;845    		
;;;846    		if (g_tModH.fAck05H > 0)
00003e  480a              LDR      r0,|L25.104|
000040  f89000d3          LDRB     r0,[r0,#0xd3]  ; g_tModH
000044  2800              CMP      r0,#0
000046  dd00              BLE      |L25.74|
;;;847    		{
;;;848    			break;
000048  e003              B        |L25.82|
                  |L25.74|
00004a  1c70              ADDS     r0,r6,#1              ;825
00004c  b2c6              UXTB     r6,r0                 ;825
                  |L25.78|
00004e  2e01              CMP      r6,#1                 ;825
000050  dbdc              BLT      |L25.12|
                  |L25.82|
000052  bf00              NOP      
;;;849    		}
;;;850    	}
;;;851    	
;;;852    	if (g_tModH.fAck05H == 0)
000054  4804              LDR      r0,|L25.104|
000056  f89000d3          LDRB     r0,[r0,#0xd3]  ; g_tModH
00005a  b910              CBNZ     r0,|L25.98|
;;;853    	{
;;;854    		return 0;	/* 通信超时了 */
00005c  2000              MOVS     r0,#0
                  |L25.94|
;;;855    	}
;;;856    	else
;;;857    	{
;;;858    		return 1;	/* 05H 写成功 */
;;;859    	}
;;;860    }
00005e  e8bd81f0          POP      {r4-r8,pc}
                  |L25.98|
000062  2001              MOVS     r0,#1                 ;858
000064  e7fb              B        |L25.94|
;;;861    
                          ENDP

000066  0000              DCW      0x0000
                  |L25.104|
                          DCD      g_tModH

                          AREA ||i.MODH_WriteParam_06H||, CODE, READONLY, ALIGN=2

                  MODH_WriteParam_06H PROC
;;;869    */
;;;870    uint8_t MODH_WriteParam_06H(uint16_t _reg, uint16_t _value)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;871    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;872    	int32_t time1;
;;;873    	uint8_t i;
;;;874    	
;;;875    	for (i = 0; i < NUM; i++)
000008  2600              MOVS     r6,#0
00000a  e020              B        |L26.78|
                  |L26.12|
;;;876    	{	
;;;877    		MODH_Send06H (SlaveAddr, _reg, _value);
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       MODH_Send06H
;;;878    		time1 = bsp_GetRunTime();	/* 记录命令发送的时刻 */
000016  f7fffffe          BL       bsp_GetRunTime
00001a  4607              MOV      r7,r0
;;;879    				
;;;880    		while (1)
00001c  e00d              B        |L26.58|
                  |L26.30|
;;;881    		{
;;;882    			bsp_Idle();
00001e  f7fffffe          BL       bsp_Idle
;;;883    		
;;;884    			if (bsp_CheckRunTime(time1) > TIMEOUT)		
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       bsp_CheckRunTime
000028  2864              CMP      r0,#0x64
00002a  dd00              BLE      |L26.46|
;;;885    			{
;;;886    				break;
00002c  e006              B        |L26.60|
                  |L26.46|
;;;887    			}
;;;888    			
;;;889    			if (g_tModH.fAck06H > 0)
00002e  480e              LDR      r0,|L26.104|
000030  f89000d4          LDRB     r0,[r0,#0xd4]  ; g_tModH
000034  2800              CMP      r0,#0
000036  dd00              BLE      |L26.58|
;;;890    			{
;;;891    				break;
000038  e000              B        |L26.60|
                  |L26.58|
00003a  e7f0              B        |L26.30|
                  |L26.60|
00003c  bf00              NOP                            ;886
;;;892    			}
;;;893    		}
;;;894    		
;;;895    		if (g_tModH.fAck06H > 0)
00003e  480a              LDR      r0,|L26.104|
000040  f89000d4          LDRB     r0,[r0,#0xd4]  ; g_tModH
000044  2800              CMP      r0,#0
000046  dd00              BLE      |L26.74|
;;;896    		{
;;;897    			break;
000048  e003              B        |L26.82|
                  |L26.74|
00004a  1c70              ADDS     r0,r6,#1              ;875
00004c  b2c6              UXTB     r6,r0                 ;875
                  |L26.78|
00004e  2e01              CMP      r6,#1                 ;875
000050  dbdc              BLT      |L26.12|
                  |L26.82|
000052  bf00              NOP      
;;;898    		}
;;;899    	}
;;;900    	
;;;901    	if (g_tModH.fAck06H == 0)
000054  4804              LDR      r0,|L26.104|
000056  f89000d4          LDRB     r0,[r0,#0xd4]  ; g_tModH
00005a  b910              CBNZ     r0,|L26.98|
;;;902    	{
;;;903    		return 0;	/* 通信超时了 */
00005c  2000              MOVS     r0,#0
                  |L26.94|
;;;904    	}
;;;905    	else
;;;906    	{
;;;907    		return 1;	/* 写入06H参数成功 */
;;;908    	}
;;;909    }
00005e  e8bd81f0          POP      {r4-r8,pc}
                  |L26.98|
000062  2001              MOVS     r0,#1                 ;907
000064  e7fb              B        |L26.94|
;;;910    
                          ENDP

000066  0000              DCW      0x0000
                  |L26.104|
                          DCD      g_tModH

                          AREA ||i.MODH_WriteParam_10H||, CODE, READONLY, ALIGN=2

                  MODH_WriteParam_10H PROC
;;;918    */
;;;919    uint8_t MODH_WriteParam_10H(uint16_t _reg, uint8_t _num, uint8_t *_buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;920    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;921    	int32_t time1;
;;;922    	uint8_t i;
;;;923    	
;;;924    	for (i = 0; i < NUM; i++)
00000a  2700              MOVS     r7,#0
00000c  e021              B        |L27.82|
                  |L27.14|
;;;925    	{	
;;;926    		MODH_Send10H(SlaveAddr, _reg, _num, _buf);
00000e  4633              MOV      r3,r6
000010  462a              MOV      r2,r5
000012  4621              MOV      r1,r4
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       MODH_Send10H
;;;927    		time1 = bsp_GetRunTime();	/* 记录命令发送的时刻 */
00001a  f7fffffe          BL       bsp_GetRunTime
00001e  4680              MOV      r8,r0
;;;928    				
;;;929    		while (1)
000020  e00d              B        |L27.62|
                  |L27.34|
;;;930    		{
;;;931    			bsp_Idle();
000022  f7fffffe          BL       bsp_Idle
;;;932    		
;;;933    			if (bsp_CheckRunTime(time1) > TIMEOUT)		
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       bsp_CheckRunTime
00002c  2864              CMP      r0,#0x64
00002e  dd00              BLE      |L27.50|
;;;934    			{
;;;935    				break;
000030  e006              B        |L27.64|
                  |L27.50|
;;;936    			}
;;;937    			
;;;938    			if (g_tModH.fAck10H > 0)
000032  480e              LDR      r0,|L27.108|
000034  f89000d5          LDRB     r0,[r0,#0xd5]  ; g_tModH
000038  2800              CMP      r0,#0
00003a  dd00              BLE      |L27.62|
;;;939    			{
;;;940    				break;
00003c  e000              B        |L27.64|
                  |L27.62|
00003e  e7f0              B        |L27.34|
                  |L27.64|
000040  bf00              NOP                            ;935
;;;941    			}
;;;942    		}
;;;943    		
;;;944    		if (g_tModH.fAck10H > 0)
000042  480a              LDR      r0,|L27.108|
000044  f89000d5          LDRB     r0,[r0,#0xd5]  ; g_tModH
000048  2800              CMP      r0,#0
00004a  dd00              BLE      |L27.78|
;;;945    		{
;;;946    			break;
00004c  e003              B        |L27.86|
                  |L27.78|
00004e  1c78              ADDS     r0,r7,#1              ;924
000050  b2c7              UXTB     r7,r0                 ;924
                  |L27.82|
000052  2f01              CMP      r7,#1                 ;924
000054  dbdb              BLT      |L27.14|
                  |L27.86|
000056  bf00              NOP      
;;;947    		}
;;;948    	}
;;;949    	
;;;950    	if (g_tModH.fAck10H == 0)
000058  4804              LDR      r0,|L27.108|
00005a  f89000d5          LDRB     r0,[r0,#0xd5]  ; g_tModH
00005e  b910              CBNZ     r0,|L27.102|
;;;951    	{
;;;952    		return 0;	/* 通信超时了 */
000060  2000              MOVS     r0,#0
                  |L27.98|
;;;953    	}
;;;954    	else
;;;955    	{
;;;956    		return 1;	/* 写入10H参数成功 */
;;;957    	}
;;;958    }
000062  e8bd81f0          POP      {r4-r8,pc}
                  |L27.102|
000066  2001              MOVS     r0,#1                 ;956
000068  e7fb              B        |L27.98|
;;;959    
                          ENDP

00006a  0000              DCW      0x0000
                  |L27.108|
                          DCD      g_tModH

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_tModH
                          %        214
                  g_tVar
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  g_modh_timeout
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\modbus_host.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_modbus_host_c_cc1c7d42____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_modbus_host_c_cc1c7d42____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_modbus_host_c_cc1c7d42____REVSH|
#line 128
|__asm___13_modbus_host_c_cc1c7d42____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
